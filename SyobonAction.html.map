{"version":3,"file":"SyobonAction.html","sources":["main.cpp","./main.h","/Users/mozilla/src/emscripten/system/include/libcxx/iosfwd","/Users/mozilla/src/emscripten/system/include/libcxx/memory","/Users/mozilla/src/emscripten/system/include/libcxx/string","loadg.cpp","DxLib.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;ACoOA;;AAAA;;;;;ACk8CA;AAAA;;;;;AC8oBA;;;AA3LA;;;AAAA;;;AC3oBA;;;ADg4BA;;;AAnLA;AC7sBA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;;;AH3wCA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;ADAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;AAkuBA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AACA;;AACA;;AAVA;AAAA;AAAA;AAAA;;AAWA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;;AARA;AAAA;AAAA;AAAA;;AASA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AACA;;AACA;AACA;AACA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;;AACA;AAAA;AAAA;;AAEA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAUA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AACA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;;;AAEA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;;AAQA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;;AACA;;AACA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAWA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;;AACA;;AALA;AAAA;AAAA;AAAA;;AAMA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;;;;;;;;;;AACA;;AACA;;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAWA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AASA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAUA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAnIA;AAAA;AAAA;AAAA;;AAoIA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AACA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AACA;;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;;AACA;;AACA;;AARA;AAAA;AAAA;AAAA;;AASA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;;;AAGA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;;AACA;;AACA;;AARA;AAAA;AAAA;AAAA;;AASA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AACA;;AACA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;;AACA;;AACA;;AAPA;AAAA;AAAA;AAAA;;AAQA;AACA;;AACA;;AACA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;;AACA;;AACA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;;AACA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;;AACA;;AACA;;AAjjBA;AAAA;AAAA;AAAA;;AAkjBA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;AACA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;AACA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;AACA;;AACA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAJA;AAAA;AAAA;AAAA;;AAKA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;;AARA;AAAA;AAAA;AAAA;;AASA;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;;AARA;AAAA;AAAA;AAAA;;AASA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;;;AAEA;;AACA;;AAtWA;AAAA;AAAA;AAAA;;AAuWA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;AAMA;;AAMA;;AASA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;AAEA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;;;AAUA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AACA;;AACA;;AAQA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;;AAbA;AAAA;AAAA;AAAA;;AAcA;;AACA;;AAnNA;AAAA;AAAA;AAAA;;AAoNA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;AAEA;;AAjBA;AAAA;AAAA;AAAA;;AAkBA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAGA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAjCA;AAAA;AAAA;AAAA;;AAkCA;;AACA;;AAxCA;AAAA;AAAA;AAAA;;AAyCA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBA;AAAA;AAAA;AACA;AAAA;AACA;;AACA;;AACA;;AA5BA;AAAA;AAAA;AAAA;;AA6BA;;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;;AAEA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAEA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;;AAbA;AAAA;AAAA;AAAA;;AAcA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;;AACA;AAEA;AAAA;AACA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;;AA1BA;AAAA;AAAA;AAAA;;AA2BA;;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;;AACA;;AACA;;AAlCA;AAAA;AAAA;AAAA;;AAmCA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAEA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;AACA;AACA;;AACA;;AAhBA;AAAA;AAAA;AAAA;;AAiBA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;AACA;AACA;;AACA;;AAhBA;AAAA;AAAA;AAAA;;AAiBA;;AAEA;AACA;;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAeA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;;AACA;;AAtCA;AAAA;AAAA;AAAA;;AAuCA;;AACA;;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AAEA;AAAA;AAAA;AACA;AACA;;AAkGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;;;AAEA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;;AAGA;;;;AACA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;;AACA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEA;;AACA;AAAA;AAAA;;;AAEA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;AACA;;AAeA;AAAA;AAAA;AACA;;AACA;;AACA;;AACA;AAAA;AAAA;;;AAEA;;AA/8BA;AAAA;AAAA;AAAA;;AAg9BA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAFA;AAAA;AAAA;AAAA;;AAGA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AAFA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAFA;AAAA;AAAA;AAAA;;AAGA;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAFA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AACA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;;AAIA;;;;;;;;;;;;;;;AA/vHA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;;AACA;AACA;AAEA;AAUA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;;;AAEA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AACA;;AAxCA;AAAA;AAAA;AAAA;;AAyCA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;;AAtCA;AAAA;AAAA;AAAA;;AAuCA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;AACA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;;AACA;;AAzDA;AAAA;AAAA;AAAA;;AA0DA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AACA;;AACA;;;AAEA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;;AAnJA;AAAA;AAAA;AAAA;;AAoJA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;;AACA;;AAhFA;AAAA;AAAA;AAAA;;AAiFA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;AANA;AAAA;AAAA;AAAA;;AAOA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;AANA;AAAA;AAAA;AAAA;;AAOA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;;AATA;AAAA;AAAA;AAAA;;AAUA;;AAXA;AAAA;AAAA;AAAA;;AAYA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;AANA;AAAA;AAAA;AAAA;;AAOA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AASA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;;AATA;AAAA;AAAA;AAAA;;AAUA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;;AATA;AAAA;AAAA;AAAA;;AAUA;;AACA;;AArDA;AAAA;AAAA;AAAA;;AAsDA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;;AACA;;AApMA;AAAA;AAAA;AAAA;;AAqMA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;AANA;AAAA;AAAA;AAAA;;AAOA;;AARA;AAAA;AAAA;AAAA;;AASA;;AACA;;AACA;;AA9CA;AAAA;AAAA;AAAA;;AA+CA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;;AAzBA;AAAA;AAAA;AAAA;;AA0BA;;AACA;;AACA;;AArCA;AAAA;AAAA;AAAA;;AAsCA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AI8bA;AAAA;AJ5bA;AAAA;AAAA;;;;;AI4bA;AAAA;AJ3bA;;AACA;AAAA;AAAA;;;;;AI0bA;AAAA;AJzbA;;AACA;AAAA;AAAA;;;;;AIwbA;AAAA;AJvbA;;AACA;AAAA;AAAA;;;;;AIsbA;AAAA;AJrbA;;AACA;AAAA;AAAA;;;;;AIobA;AAAA;AJnbA;;AACA;AAAA;AAAA;;;;;AIkbA;AAAA;AJjbA;;AACA;AAAA;AAAA;;;;;AIgbA;AAAA;AJ/aA;;AACA;AAAA;AAAA;;;;;AI8aA;AAAA;AJ7aA;;AACA;AAAA;AAAA;;;;;AI4aA;AAAA;AJ3aA;;AACA;AAAA;AAAA;;;;;AI0aA;AAAA;AJzaA;;AACA;AAAA;AAAA;;;;;AIwaA;AAAA;AJvaA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AACA;;;;AAJA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AAEA;;AAAA;AAAA;;AAAA;;AAEA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AI6ZA;AAAA;AJ3ZA;AAAA;AAAA;AAAA;AAAA;;;;;AI2ZA;AAAA;AJ1ZA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIyZA;AAAA;AJxZA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIuZA;AAAA;AJtZA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIqZA;AAAA;AJpZA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AImZA;AAAA;AJlZA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIiZA;AAAA;AJhZA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AI+YA;AAAA;AJ9YA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AI6YA;AAAA;AJ5YA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AI2YA;AAAA;AJ1YA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIyYA;AAAA;AJxYA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIuYA;AAAA;AJtYA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIqYA;AAAA;AJpYA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AImYA;AAAA;AJlYA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIiYA;AAAA;AJhYA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AI+XA;AAAA;AJ9XA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AI6XA;AAAA;AJ5XA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AI2XA;AAAA;AJ1XA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIyXA;AAAA;AJxXA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIuXA;AAAA;AJtXA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIqXA;AAAA;AJpXA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AImXA;AAAA;AJlXA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIiXA;AAAA;AJhXA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AI+WA;AAAA;AJ9WA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;AI4WA;AAAA;AJ3WA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AI0WA;AAAA;AJzWA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIwWA;AAAA;AJvWA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIsWA;AAAA;AJrWA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIoWA;AAAA;AJnWA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIkWA;AAAA;AJjWA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIgWA;AAAA;AJ/VA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AI8VA;AAAA;AJ7VA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AI4VA;AAAA;AJ3VA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AI0VA;AAAA;AJzVA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIwVA;AAAA;AJvVA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIsVA;AAAA;AJrVA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIoVA;AAAA;AJnVA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIkVA;AAAA;AJjVA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIgVA;AAAA;AJ/UA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AI8UA;AAAA;AJ7UA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AI4UA;AAAA;AJ3UA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AI0UA;AAAA;AJzUA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIwUA;AAAA;AJvUA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIsUA;AAAA;AJrUA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIoUA;AAAA;AJnUA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIkUA;AAAA;AJjUA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AIgUA;AAAA;AJ/TA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;;AAAA;AACA;AACA;;;;AAFA;;AAAA;AAAA;;AAAA;;AAGA;;AA7GA;AAAA;AAAA;AAAA;;AA8GA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AACA;;;;;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;;AAGA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;;AACA;;AACA;;AACA;AAAA;AAAA;;AACA;;;;AEu1BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJr1BA;AAAA;AAAA;;AAAA;;;;AEs1BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJn1BA;AAAA;AAAA;;AAAA;;;;AEo1BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJl1BA;AAAA;AAAA;;AAAA;;;;AEm1BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJj1BA;AAAA;AAAA;;AAAA;;;;AEk1BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJh1BA;AAAA;AAAA;;AAAA;;;;AEi1BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ/0BA;AAAA;AAAA;;AAAA;;;;AEg1BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ90BA;AAAA;AAAA;;AAAA;;;;AE+0BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ70BA;AAAA;AAAA;;AAAA;;;;AE80BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ50BA;AAAA;AAAA;;AAAA;;;;AE60BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ30BA;AAAA;AAAA;;AAAA;;;;AE40BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ10BA;AAAA;AAAA;;AAAA;;;;AE20BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJz0BA;AAAA;AAAA;;AAAA;;;;AE00BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJx0BA;AAAA;AAAA;;AAAA;;;;AEy0BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJv0BA;AAAA;AAAA;;AAAA;;;;AEw0BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJt0BA;AAAA;AAAA;;AAAA;;;;AEu0BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJp0BA;AAAA;AAAA;;AAAA;;;;AEq0BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJn0BA;AAAA;AAAA;;AAAA;;;;AEo0BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJj0BA;AAAA;AAAA;;AAAA;;;;AEk0BA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJh0BA;AAAA;AAAA;;AAAA;AACA;;;;AAtBA;;AAAA;AAAA;;AAAA;;;;AAEA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AAEA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AAEA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;;;AE2yBA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJzyBA;;AAAA;AACA;;;;AADA;;AAAA;AAAA;;AAAA;;AAEA;AAAA;;AACA;;AAzNA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;AAiuGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAmCA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAWA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;AApBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AArBA;AACA;;;;;;;;;;;;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AArBA;AACA;;;;;;;;;;;;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;AAqDA;AAAA;;;;;;;;;AI9lFA;;;AD27BA;;;AAnLA;ACxwBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqDA;;;;AAZA;;;ADk5BA;;;AAnLA;AC/tBA;AAAA;AAAA;AAAA;AAYA;;;;AANA;;;AD44BA;;;AAnLA;ACztBA;AAAA;AAAA;AAAA;AAMA;;AAAA;AJyiFA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqhKA;AACA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AACA;AACA;;;;AE30OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ60OA;;AAAA;AACA;;;;AADA;;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;;AACA;;;;AE/0OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJi1OA;;AAAA;;;;AEh1OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJk1OA;;AAAA;;;;AEj1OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJm1OA;;AAAA;;;;AEl1OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJo1OA;;AAAA;;;;AEn1OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJq1OA;;AAAA;;;;AEp1OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJu1OA;;AAAA;AACA;;;;AAPA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AAEA;;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;;;;;AEx1OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ01OA;;AAAA;;;;AEz1OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ21OA;;AAAA;AACA;;;;AAFA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;;;;;AE51OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ81OA;;AAAA;;;;AE71OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ+1OA;;AAAA;AACA;;;;AAFA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;;;;;AEh2OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJk2OA;;AAAA;;;;AEj2OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJm2OA;;AAAA;AACA;;;;AAFA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;;;;;AEp2OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJs2OA;;AAAA;;;;AEr2OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJu2OA;;AAAA;;;;AEt2OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJw2OA;;AAAA;;;;AEv2OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJy2OA;;AAAA;AACA;;;;AAJA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;;;;;AE12OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ42OA;;AAAA;;;;AE32OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ62OA;;AAAA;;;;AE52OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ82OA;;AAAA;;;;AE72OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJi3OA;;AAAA;AACA;;;;AANA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AAGA;;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;;;;;AEl3OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJo3OA;;AAAA;;;;AEn3OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJq3OA;;AAAA;;;;AEp3OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJs3OA;;AAAA;;;;AEr3OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJu3OA;;AAAA;AACA;;;;AAJA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;;;;;AEx3OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ03OA;;AAAA;;;;AEz3OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ23OA;;AAAA;;;;AE13OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ43OA;;AAAA;AACA;;;;AAHA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;;;;;AE73OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ+3OA;;AAAA;;;;AE93OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJg4OA;;AAAA;;;;AE/3OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJi4OA;;AAAA;AACA;;;;AAHA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;;;;;AEl4OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJo4OA;;AAAA;;;;AEn4OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJu4OA;;AAAA;;;;AEt4OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJw4OA;;AAAA;AACA;;;;AALA;;AAAA;AAAA;;AAAA;;;;AAGA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;;;;;AEz4OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ24OA;;AAAA;;;;AE14OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ44OA;;AAAA;;;;AE34OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ64OA;;AAAA;;;;AE54OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJ84OA;;AAAA;;;;AE74OA;;;;AALA;AAAA;;;;;AC+kBA;;;AA3LA;;;AAAA;AChZA;AAAA;;AAnnCA;AAAA;AAmnCA;AJg5OA;;AAAA;AACA;;;;AANA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AACA;;AAAA;AAAA;;AAAA;;;;AAEA;;AAAA;AAAA;;AAAA;;AAEA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;;AACA;;AAhFA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;AAhgKA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AARA;AAAA;AAAA;AAAA;;AASA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAPA;AAAA;AAAA;AAAA;;AAQA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAdA;AAAA;AAAA;AAAA;;AAeA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAdA;AAAA;AAAA;AAAA;;AAeA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AANA;AAAA;AAAA;AAAA;;AAOA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AANA;AAAA;AAAA;AAAA;;AAOA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AATA;AAAA;AAAA;AAAA;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AA2gKA;AAAA;AAAA;AAEA;;;;;;;;;AAhIA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;;;AACA;;;;;;;;;AA/4JA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;;AAlGA;AAAA;AAAA;AAAA;;AAmGA;;AApGA;AAAA;AAAA;AAAA;;AAqGA;AAAA;AAAA;;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AAVA;AAAA;AAAA;AAAA;;AAWA;AAAA;AAAA;AAAA;AACA;;AACA;;;;;;;;AA5UA;AAAA;AAAA;AAAA;;;;;;AAkIA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkmKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;;;;;;;;;;AAjIA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAdA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAwIA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAyBA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AACA;;AACA;;AACA;;AAnEA;AAAA;AAAA;AAAA;;AAoEA;;;;;;;;;AAr+KA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;;AACA;;AAzCA;AAAA;AAAA;AAAA;;AA0CA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;;AACA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;;;;AACA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;AACA;AACA;;AACA;;AACA;;AAvHA;AAAA;AAAA;AAAA;;AAwHA;;;;;;;;;;;;;;AAYA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AACA;;AAFA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuTA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AA8RA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAiFA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;AACA;AACA;AAuVA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AAFA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;AACA;AAyHA;AAAA;AAQA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AA6TA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;AACA;AACA;AA4DA;AAAA;AACA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AA0DA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;AACA;AACA;AAiXA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;AACA;AAoPA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;AAiCA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;AACA;AACA;AAqSA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;AACA;AACA;AAiFA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;AACA;AAiRA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AASA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AACA;AAiFA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;AACA;AAwCA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;AACA;AAmRA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;AACA;AAmQA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AALA;AAAA;AAAA;AAAA;;AAMA;;;AACA;;;;;;AAl1NA;AAAA;;;;;;;;;AKzrEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAFA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AACA;;AAFA;AAAA;AAAA;AAAA;;AAqBA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AALA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAFA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAFA;AAAA;AAAA;AAAA;;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAYA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;;AAXA;AAAA;AAAA;AAAA;;AAYA;AACA;AACA;AACA;AAGA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;;AAVA;AAAA;AAAA;AAAA;;AA8BA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAUA;;;;;;;;;;;;;;AAKA;AAAA;AAAA;;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;;;;;;;;;;;;AC/PA;AACA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AAKA;AAAA;AAAA;AAAA;;AAGA;AACA;AAAA;;AAGA;AAEA;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AAKA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAEA;AAAA;;AACA;;AAAA;;;;;;;;;;;;;;;;AN4lSA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;;;;AADA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;AMjlSA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;AAEA;;;AACA;;;;;;;;AAKA;AAAA;AACA;;;;AAoFA;AAAA;AAAA;AAAA;;;;;;;;;;AAKA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAvFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;;;;;;;;;;;;;;;;;AAyFA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;AACA;;;;;;;;;;;;;;;;;;;;AA3FA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;;AACA;;;;;;;;;;;AAYA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AACA;;;;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AACA;;;;;AAEA;;;;AACA;;AACA;;AAEA;AACA;;AAEA;;;AACA;;;;;;;;;;;AAgBA;;AACA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;;AACA;;;;;;;;;;;;;;;;;;AAqBA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;AACA;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;AACA;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;;;;;AAeA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;;AAAA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;;AAAA;;;;;;;;;;;;;AA9BA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA","sourcesContent":["#include \"main.h\"\n#ifdef EMSCRIPTEN\n#include <emscripten/emscripten.h>\nvoid EmscriptenLoop() {\n    if (!(ProcessMessage() == 0 && CheckHitKey(KEY_INPUT_ESCAPE) == 0)) {\n        emscripten_cancel_main_loop();\n        return;\n    }\n    UpdateKeys();\n    maint = 0;\n    Mainprogram();\n    if (maint == 3)\n        emscripten_cancel_main_loop();\n}\n#endif\nint main(int argc, char *argv[])\n{\n    parseArgs(argc, argv);\n    if (DxLib_Init() == -1)\n\treturn 1;\n    loadg();\n    SetFontSize(16);\n#ifdef EMSCRIPTEN\n    emscripten_set_main_loop(EmscriptenLoop, 60, true);\n#else\n    while (ProcessMessage() == 0 && CheckHitKey(KEY_INPUT_ESCAPE) == 0) {\n\tUpdateKeys();\n\tmaint = 0;\n\tMainprogram();\n\tif (maint == 3)\n\t    break;\n    }\n#endif\n    end();\n}\nvoid rpaint()\n{\n    setcolor(0, 0, 0);\n    if (stagecolor == 1)\n\tsetcolor(160, 180, 250);\n    if (stagecolor == 2)\n\tsetcolor(10, 10, 10);\n    if (stagecolor == 3)\n\tsetcolor(160, 180, 250);\n    if (stagecolor == 4)\n\tsetcolor(10, 10, 10);\n    if (stagecolor == 5) {\n\tsetcolor(160, 180, 250);\n\tmrzimen = 1;\n    } else {\n\tmrzimen = 0;\n    }\n    FillScreen();\n    if (mainZ == 1 && zxon >= 1) {\n\tfor (t = 0; t < nmax; t++) {\n\t    xx[0] = na[t] - fx;\n\t    xx[1] = nb[t] - fy;\n\t    xx[2] = ne[ntype[t]] * 100;\n\t    xx[3] = nf[ntype[t]] * 100;\n\t    xx[2] = 16000;\n\t    xx[3] = 16000;\n\t    if (xx[0] + xx[2] >= -10 && xx[0] <= fxmax\n\t\t&& xx[1] + xx[3] >= -10 && xx[3] <= fymax) {\n\t\tif (ntype[t] != 3) {\n\t\t    if ((ntype[t] == 1 || ntype[t] == 2)\n\t\t\t&& stagecolor == 5) {\n\t\t\tdrawimage(grap[ntype[t] + 30]\n\t\t\t\t  [4], xx[0] / 100, xx[1] / 100);\n\t\t    } else {\n\t\t\tdrawimage(grap[ntype[t]][4],\n\t\t\t\t  xx[0] / 100, xx[1] / 100);\n\t\t    }\n\t\t}\n\t\tif (ntype[t] == 3)\n\t\t    drawimage(grap[ntype[t]][4],\n\t\t\t      xx[0] / 100 - 5, xx[1] / 100);\n\t\tif (ntype[t] == 100) {\n\t\t    DrawFormatString(xx[0] / 100 + fma,\n\t\t\t\t     xx[1] / 100 + fmb,\n\t\t\t\t     GetColor(255, 255, 255), \"51\");\n\t\t}\n\t\tif (ntype[t] == 101)\n\t\t    DrawFormatString(xx[0] / 100 + fma,\n\t\t\t\t     xx[1] / 100 + fmb,\n\t\t\t\t     GetColor(255, 255,\n\t\t\t\t\t      255),\n\t\t\t\t     \"\");\n\t\tif (ntype[t] == 102)\n\t\t    DrawFormatString(xx[0] / 100 + fma,\n\t\t\t\t     xx[1] / 100 + fmb,\n\t\t\t\t     GetColor(255, 255,\n\t\t\t\t\t      255),\n\t\t\t\t     \"\");\n\t    }\n\t}\n\tfor (t = 0; t < emax; t++) {\n\t    xx[0] = ea[t] - fx;\n\t    xx[1] = eb[t] - fy;\n\t    xx[2] = enobia[t] / 100;\n\t    xx[3] = enobib[t] / 100;\n\t    if (xx[0] + xx[2] * 100 >= -10 && xx[1] <= fxmax\n\t\t&& xx[1] + xx[3] * 100 >= -10 - 8000 && xx[3] <= fymax) {\n\t\tif (egtype[t] == 0)\n\t\t    drawimage(grap[0][2], xx[0] / 100, xx[1] / 100);\n\t\tif (egtype[t] == 1) {\n\t\t    if (stagecolor == 1 || stagecolor == 3\n\t\t\t|| stagecolor == 5)\n\t\t\tsetcolor(9 * 16, 6 * 16, 3 * 16);\n\t\t    if (stagecolor == 2)\n\t\t\tsetcolor(0, 120, 160);\n\t\t    if (stagecolor == 4)\n\t\t\tsetcolor(192, 192, 192);\n\t\t    fillarc(xx[0] / 100, xx[1] / 100, 7, 7);\n\t\t    setcolor(0, 0, 0);\n\t\t    drawarc(xx[0] / 100, xx[1] / 100, 7, 7);\n\t\t}\n\t\tif (egtype[t] == 2 || egtype[t] == 3) {\n\t\t    if (egtype[t] == 3)\n\t\t\tmirror = 1;\n\t\t    drawimage(grap[0][5], xx[0] / 100, xx[1] / 100);\n\t\t    mirror = 0;\n\t\t}\n\t\tif (egtype[t] == 4) {\n\t\t    setc1();\n\t\t    fillrect((xx[0]) / 100 + 10, (xx[1]) / 100, 10, xx[3]);\n\t\t    setc0();\n\t\t    drawrect((xx[0]) / 100 + 10, (xx[1]) / 100, 10, xx[3]);\n\t\t    setcolor(250, 250, 0);\n\t\t    fillarc((xx[0]) / 100 + 15 - 1, (xx[1]) / 100, 10, 10);\n\t\t    setc0();\n\t\t    drawarc((xx[0]) / 100 + 15 - 1, (xx[1]) / 100, 10, 10);\n\t\t}\n\t    }\n\t}\n\tfor (t = 0; t < srmax; t++) {\n\t    xx[0] = sra[t] - fx;\n\t    xx[1] = srb[t] - fy;\n\t    if (xx[0] + src[t] >= -10 && xx[1] <= fxmax + 12100\n\t\t&& src[t] / 100 >= 1) {\n\t\txx[2] = 14;\n\t\tif (srsp[t] == 1) {\n\t\t    xx[2] = 12;\n\t\t}\n\t\tif (srsp[t] <= 9 || srsp[t] >= 20) {\n\t\t    setcolor(220, 220, 0);\n\t\t    if (srsp[t] == 2 || srsp[t] == 3) {\n\t\t\tsetcolor(0, 220, 0);\n\t\t    }\n\t\t    if (srsp[t] == 21) {\n\t\t\tsetcolor(180, 180, 180);\n\t\t    }\n\t\t    fillrect((sra[t] - fx) / 100,\n\t\t\t     (srb[t] - fy) / 100, src[t] / 100, xx[2]);\n\t\t    setcolor(180, 180, 0);\n\t\t    if (srsp[t] == 2 || srsp[t] == 3) {\n\t\t\tsetcolor(0, 180, 0);\n\t\t    }\n\t\t    if (srsp[t] == 21) {\n\t\t\tsetcolor(150, 150, 150);\n\t\t    }\n\t\t    drawrect((sra[t] - fx) / 100,\n\t\t\t     (srb[t] - fy) / 100, src[t] / 100, xx[2]);\n\t\t} else if (srsp[t] <= 14) {\n\t\t    if (src[t] >= 5000) {\n\t\t\tsetcolor(0, 200, 0);\n\t\t\tfillrect((sra[t] - fx) / 100,\n\t\t\t\t (srb[t] - fy) / 100, src[t] / 100, 30);\n\t\t\tsetcolor(0, 160, 0);\n\t\t\tdrawrect((sra[t] - fx) / 100,\n\t\t\t\t (srb[t] - fy) / 100, src[t] / 100, 30);\n\t\t\tsetcolor(180, 120, 60);\n\t\t\tfillrect((sra[t] - fx) / 100 +\n\t\t\t\t 20,\n\t\t\t\t (srb[t] - fy) / 100 +\n\t\t\t\t 30, src[t] / 100 - 40, 480);\n\t\t\tsetcolor(100, 80, 20);\n\t\t\tdrawrect((sra[t] - fx) / 100 +\n\t\t\t\t 20,\n\t\t\t\t (srb[t] - fy) / 100 +\n\t\t\t\t 30, src[t] / 100 - 40, 480);\n\t\t    }\n\t\t}\n\t\tif (srsp[t] == 15) {\n\t\t    for (t2 = 0; t2 <= 2; t2++) {\n\t\t\txx[6] = 1 + 0;\n\t\t\tdrawimage(grap[xx[6]][1],\n\t\t\t\t  (sra[t] - fx) / 100 +\n\t\t\t\t  t2 * 29, (srb[t] - fy) / 100);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tsetcolor(0, 0, 255);\n\tif (mactp >= 2000) {\n\t    mactp -= 2000;\n\t    if (mact == 0) {\n\t\tmact = 1;\n\t    } else {\n\t\tmact = 0;\n\t    }\n\t}\n\tif (mmuki == 0)\n\t    mirror = 1;\n\tif (mtype != 200 && mtype != 1) {\n\t    if (mzimen == 1) {\n\t\tif (mact == 0)\n\t\t    drawimage(grap[0][0], ma / 100, mb / 100);\n\t\tif (mact == 1)\n\t\t    drawimage(grap[1][0], ma / 100, mb / 100);\n\t    }\n\t    if (mzimen == 0) {\n\t\tdrawimage(grap[2][0], ma / 100, mb / 100);\n\t    }\n\t}\n\telse if (mtype == 1) {\n\t    drawimage(grap[41][0], ma / 100, mb / 100);\n\t}\n\telse if (mtype == 200) {\n\t    drawimage(grap[3][0], ma / 100, mb / 100);\n\t}\n\tmirror = 0;\n\tfor (t = 0; t < amax; t++) {\n\t    xx[0] = aa[t] - fx;\n\t    xx[1] = ab[t] - fy;\n\t    xx[2] = anobia[t] / 100;\n\t    xx[3] = anobib[t] / 100;\n\t    xx[14] = 3000;\n\t    xx[16] = 0;\n\t    if (xx[0] + xx[2] * 100 >= -10 - xx[14]\n\t\t&& xx[1] <= fxmax + xx[14]\n\t\t&& xx[1] + xx[3] * 100 >= -10 && xx[3] <= fymax) {\n\t\tif (amuki[t] == 1) {\n\t\t    mirror = 1;\n\t\t}\n\t\tif (atype[t] == 3 && axtype[t] == 1) {\n\t\t    DrawVertTurnGraph(xx[0] / 100 + 13,\n\t\t\t\t      xx[1] / 100 + 15, grap[atype[t]][3]);\n\t\t    xx[16] = 1;\n\t\t}\n\t\tif (atype[t] == 9 && ad[t] >= 1) {\n\t\t    DrawVertTurnGraph(xx[0] / 100 + 13,\n\t\t\t\t      xx[1] / 100 + 15, grap[atype[t]][3]);\n\t\t    xx[16] = 1;\n\t\t}\n\t\tif (atype[t] >= 100 && amuki[t] == 1)\n\t\t    mirror = 0;\n\t\tif (atype[t] < 200 && xx[16] == 0\n\t\t    && atype[t] != 6 && atype[t] != 79\n\t\t    && atype[t] != 86 && atype[t] != 30) {\n\t\t    if (!((atype[t] == 80 || atype[t] == 81)\n\t\t\t  && axtype[t] == 1)) {\n\t\t\tdrawimage(grap[atype[t]][3],\n\t\t\t\t  xx[0] / 100, xx[1] / 100);\n\t\t    }\n\t\t}\n\t\tif (atype[t] == 6) {\n\t\t    if (atm[t] >= 10 && atm[t] <= 19\n\t\t\t|| atm[t] >= 100 && atm[t] <= 119\n\t\t\t|| atm[t] >= 200) {\n\t\t\tdrawimage(grap[150][3], xx[0] / 100, xx[1] / 100);\n\t\t    } else {\n\t\t\tdrawimage(grap[6][3], xx[0] / 100, xx[1] / 100);\n\t\t    }\n\t\t}\n\t\tif (atype[t] == 30) {\n\t\t    if (axtype[t] == 0)\n\t\t\tdrawimage(grap[30][3], xx[0] / 100, xx[1] / 100);\n\t\t    if (axtype[t] == 1)\n\t\t\tdrawimage(grap[155][3], xx[0] / 100, xx[1] / 100);\n\t\t}\n\t\tif ((atype[t] == 81) && axtype[t] == 1) {\n\t\t    drawimage(grap[130][3], xx[0] / 100, xx[1] / 100);\n\t\t}\n\t\tif (atype[t] == 79) {\n\t\t    setcolor(250, 250, 0);\n\t\t    fillrect(xx[0] / 100, xx[1] / 100, xx[2], xx[3]);\n\t\t    setc0();\n\t\t    drawrect(xx[0] / 100, xx[1] / 100, xx[2], xx[3]);\n\t\t}\n\t\tif (atype[t] == 82) {\n\t\t    if (axtype[t] == 0) {\n\t\t\txx[9] = 0;\n\t\t\tif (stagecolor == 2) {\n\t\t\t    xx[9] = 30;\n\t\t\t}\n\t\t\tif (stagecolor == 4) {\n\t\t\t    xx[9] = 60;\n\t\t\t}\n\t\t\tif (stagecolor == 5) {\n\t\t\t    xx[9] = 90;\n\t\t\t}\n\t\t\txx[6] = 5 + xx[9];\n\t\t\tdrawimage(grap[xx[6]][1],\n\t\t\t\t  xx[0] / 100, xx[1] / 100);\n\t\t    }\n\t\t    if (axtype[t] == 1) {\n\t\t\txx[9] = 0;\n\t\t\tif (stagecolor == 2) {\n\t\t\t    xx[9] = 30;\n\t\t\t}\n\t\t\tif (stagecolor == 4) {\n\t\t\t    xx[9] = 60;\n\t\t\t}\n\t\t\tif (stagecolor == 5) {\n\t\t\t    xx[9] = 90;\n\t\t\t}\n\t\t\txx[6] = 4 + xx[9];\n\t\t\tdrawimage(grap[xx[6]][1],\n\t\t\t\t  xx[0] / 100, xx[1] / 100);\n\t\t    }\n\t\t    if (axtype[t] == 2) {\n\t\t\tdrawimage(grap[1][5], xx[0] / 100, xx[1] / 100);\n\t\t    }\n\t\t}\n\t\tif (atype[t] == 83) {\n\t\t    if (axtype[t] == 0) {\n\t\t\txx[9] = 0;\n\t\t\tif (stagecolor == 2) {\n\t\t\t    xx[9] = 30;\n\t\t\t}\n\t\t\tif (stagecolor == 4) {\n\t\t\t    xx[9] = 60;\n\t\t\t}\n\t\t\tif (stagecolor == 5) {\n\t\t\t    xx[9] = 90;\n\t\t\t}\n\t\t\txx[6] = 5 + xx[9];\n\t\t\tdrawimage(grap[xx[6]][1],\n\t\t\t\t  xx[0] / 100 + 10, xx[1] / 100 + 9);\n\t\t    }\n\t\t    if (axtype[t] == 1) {\n\t\t\txx[9] = 0;\n\t\t\tif (stagecolor == 2) {\n\t\t\t    xx[9] = 30;\n\t\t\t}\n\t\t\tif (stagecolor == 4) {\n\t\t\t    xx[9] = 60;\n\t\t\t}\n\t\t\tif (stagecolor == 5) {\n\t\t\t    xx[9] = 90;\n\t\t\t}\n\t\t\txx[6] = 4 + xx[9];\n\t\t\tdrawimage(grap[xx[6]][1],\n\t\t\t\t  xx[0] / 100 + 10, xx[1] / 100 + 9);\n\t\t    }\n\t\t}\n\t\tif (atype[t] == 85) {\n\t\t    setc1();\n\t\t    fillrect((xx[0]) / 100 + 10, (xx[1]) / 100, 10, xx[3]);\n\t\t    setc0();\n\t\t    drawrect((xx[0]) / 100 + 10, (xx[1]) / 100, 10, xx[3]);\n\t\t    setcolor(0, 250, 200);\n\t\t    fillarc((xx[0]) / 100 + 15 - 1, (xx[1]) / 100, 10, 10);\n\t\t    setc0();\n\t\t    drawarc((xx[0]) / 100 + 15 - 1, (xx[1]) / 100, 10, 10);\n\t\t}\n\t\tif (atype[t] == 86) {\n\t\t    if (ma >= aa[t] - fx - mnobia - 4000\n\t\t\t&& ma <= aa[t] - fx + anobia[t] + 4000) {\n\t\t\tdrawimage(grap[152][3], xx[0] / 100, xx[1] / 100);\n\t\t    } else {\n\t\t\tdrawimage(grap[86][3], xx[0] / 100, xx[1] / 100);\n\t\t    }\n\t\t}\n\t\tif (atype[t] == 200)\n\t\t    drawimage(grap[0][3], xx[0] / 100, xx[1] / 100);\n\t\tmirror = 0;\n\t    }\n\t}\n\tfor (t = 0; t < tmax; t++) {\n\t    xx[0] = ta[t] - fx;\n\t    xx[1] = tb[t] - fy;\n\t    xx[2] = 32;\n\t    xx[3] = xx[2];\n\t    if (xx[0] + xx[2] * 100 >= -10 && xx[1] <= fxmax) {\n\t\txx[9] = 0;\n\t\tif (stagecolor == 2) {\n\t\t    xx[9] = 30;\n\t\t}\n\t\tif (stagecolor == 4) {\n\t\t    xx[9] = 60;\n\t\t}\n\t\tif (stagecolor == 5) {\n\t\t    xx[9] = 90;\n\t\t}\n\t\tif (ttype[t] < 100) {\n\t\t    xx[6] = ttype[t] + xx[9];\n\t\t    drawimage(grap[xx[6]][1], xx[0] / 100, xx[1] / 100);\n\t\t}\n\t\tif (txtype[t] != 10) {\n\t\t    if (ttype[t] == 100 || ttype[t] == 101\n\t\t\t|| ttype[t] == 102\n\t\t\t|| ttype[t] == 103\n\t\t\t|| ttype[t] == 104 && txtype[t] == 1\n\t\t\t|| ttype[t] == 114 && txtype[t] == 1\n\t\t\t|| ttype[t] == 116) {\n\t\t\txx[6] = 2 + xx[9];\n\t\t\tdrawimage(grap[xx[6]][1],\n\t\t\t\t  xx[0] / 100, xx[1] / 100);\n\t\t    }\n\t\t    if (ttype[t] == 112 || ttype[t] == 104\n\t\t\t&& txtype[t] == 0 || ttype[t] == 115\n\t\t\t&& txtype[t] == 1) {\n\t\t\txx[6] = 1 + xx[9];\n\t\t\tdrawimage(grap[xx[6]][1],\n\t\t\t\t  xx[0] / 100, xx[1] / 100);\n\t\t    }\n\t\t    if (ttype[t] == 111 || ttype[t] == 113\n\t\t\t|| ttype[t] == 115 && txtype[t] == 0\n\t\t\t|| ttype[t] == 124) {\n\t\t\txx[6] = 3 + xx[9];\n\t\t\tdrawimage(grap[xx[6]][1],\n\t\t\t\t  xx[0] / 100, xx[1] / 100);\n\t\t    }\n\t\t}\n\t\tif (ttype[t] == 117 && txtype[t] == 1) {\n\t\t    drawimage(grap[4][5], xx[0] / 100, xx[1] / 100);\n\t\t}\n\t\tif (ttype[t] == 117 && txtype[t] >= 3) {\n\t\t    drawimage(grap[3][5], xx[0] / 100, xx[1] / 100);\n\t\t}\n\t\tif (ttype[t] == 115 && txtype[t] == 3) {\n\t\t    xx[6] = 1 + xx[9];\n\t\t    drawimage(grap[xx[6]][1], xx[0] / 100, xx[1] / 100);\n\t\t}\n\t\tif (ttype[t] == 120 && txtype[t] != 1) {\n\t\t    drawimage(grap[16][1], xx[0] / 100 + 3,\n\t\t\t      xx[1] / 100 + 2);\n\t\t}\n\t\tif (ttype[t] == 130)\n\t\t    drawimage(grap[10][5], xx[0] / 100, xx[1] / 100);\n\t\tif (ttype[t] == 131)\n\t\t    drawimage(grap[11][5], xx[0] / 100, xx[1] / 100);\n\t\tif (ttype[t] == 140)\n\t\t    drawimage(grap[12][5], xx[0] / 100, xx[1] / 100);\n\t\tif (ttype[t] == 141)\n\t\t    drawimage(grap[13][5], xx[0] / 100, xx[1] / 100);\n\t\tif (ttype[t] == 142)\n\t\t    drawimage(grap[14][5], xx[0] / 100, xx[1] / 100);\n\t\tif (ttype[t] == 300 || ttype[t] == 301)\n\t\t    drawimage(grap[1][5], xx[0] / 100, xx[1] / 100);\n\t\tif (ttype[t] == 400) {\n\t\t    drawimage(grap[2][5], xx[0] / 100, xx[1] / 100);\n\t\t}\n\t\tif (ttype[t] == 800) {\n\t\t    drawimage(grap[0][2], xx[0] / 100 + 2,\n\t\t\t      xx[1] / 100 + 1);\n\t\t}\n\t    }\n\t}\n\tfor (t = 0; t < smax; t++) {\n\t    if (sa[t] - fx + sc[t] >= -10 && sa[t] - fx <= fxmax + 1100) {\n\t\tif (stype[t] == 0) {\n\t\t    setcolor(40, 200, 40);\n\t\t    fillrect((sa[t] - fx) / 100 + fma,\n\t\t\t     (sb[t] - fy) / 100 + fmb,\n\t\t\t     sc[t] / 100, sd[t] / 100);\n\t\t    drawrect((sa[t] - fx) / 100 + fma,\n\t\t\t     (sb[t] - fy) / 100 + fmb,\n\t\t\t     sc[t] / 100, sd[t] / 100);\n\t\t}\n\t\tif (stype[t] == 1) {\n\t\t    setcolor(0, 230, 0);\n\t\t    fillrect((sa[t] - fx) / 100 + fma,\n\t\t\t     (sb[t] - fy) / 100 + fmb,\n\t\t\t     sc[t] / 100, sd[t] / 100);\n\t\t    setc0();\n\t\t    drawrect((sa[t] - fx) / 100 + fma,\n\t\t\t     (sb[t] - fy) / 100 + fmb,\n\t\t\t     sc[t] / 100, sd[t] / 100);\n\t\t}\n\t\tif (stype[t] == 2) {\n\t\t    setcolor(0, 230, 0);\n\t\t    fillrect((sa[t] - fx) / 100 + fma,\n\t\t\t     (sb[t] - fy) / 100 + fmb + 1,\n\t\t\t     sc[t] / 100, sd[t] / 100);\n\t\t    setc0();\n\t\t    drawline((sa[t] - fx) / 100 + fma,\n\t\t\t     (sb[t] - fy) / 100 + fmb,\n\t\t\t     (sa[t] - fx) / 100 + fma,\n\t\t\t     (sb[t] - fy) / 100 + fmb + sd[t] / 100);\n\t\t    drawline((sa[t] - fx) / 100 + fma +\n\t\t\t     sc[t] / 100,\n\t\t\t     (sb[t] - fy) / 100 + fmb,\n\t\t\t     (sa[t] - fx) / 100 + fma +\n\t\t\t     sc[t] / 100,\n\t\t\t     (sb[t] - fy) / 100 + fmb + sd[t] / 100);\n\t\t}\n\t\tif (stype[t] == 5) {\n\t\t    setcolor(0, 230, 0);\n\t\t    fillrect((sa[t] - fx) / 100 + fma,\n\t\t\t     (sb[t] - fy) / 100 + fmb + 1,\n\t\t\t     sc[t] / 100, sd[t] / 100);\n\t\t    setc0();\n\t\t    drawline((sa[t] - fx) / 100 + fma,\n\t\t\t     (sb[t] - fy) / 100 + fmb,\n\t\t\t     (sa[t] - fx) / 100 + fma +\n\t\t\t     sc[t] / 100, (sb[t] - fy) / 100 + fmb);\n\t\t    drawline((sa[t] - fx) / 100 + fma,\n\t\t\t     (sb[t] - fy) / 100 + fmb +\n\t\t\t     sd[t] / 100,\n\t\t\t     (sa[t] - fx) / 100 + fma +\n\t\t\t     sc[t] / 100,\n\t\t\t     (sb[t] - fy) / 100 + fmb + sd[t] / 100);\n\t\t}\n\t\tif (stype[t] == 51) {\n\t\t    if (sxtype[t] == 0) {\n\t\t\tfor (t3 = 0; t3 <= sc[t] / 3000; t3++) {\n\t\t\t    drawimage(grap[1][1],\n\t\t\t\t      (sa[t] -\n\t\t\t\t       fx) / 100 +\n\t\t\t\t      fma + 29 * t3,\n\t\t\t\t      (sb[t] - fy) / 100 + fmb);\n\t\t\t}\n\t\t    }\n\t\t    if (sxtype[t] == 1 || sxtype[t] == 2) {\n\t\t\tfor (t3 = 0; t3 <= sc[t] / 3000; t3++) {\n\t\t\t    drawimage(grap[31][1],\n\t\t\t\t      (sa[t] -\n\t\t\t\t       fx) / 100 +\n\t\t\t\t      fma + 29 * t3,\n\t\t\t\t      (sb[t] - fy) / 100 + fmb);\n\t\t\t}\n\t\t    }\n\t\t    if (sxtype[t] == 3 || sxtype[t] == 4) {\n\t\t\tfor (t3 = 0; t3 <= sc[t] / 3000; t3++) {\n\t\t\t    for (t2 = 0; t2 <= sd[t] / 3000; t2++) {\n\t\t\t\tdrawimage(grap[65]\n\t\t\t\t\t  [1], (sa[t]\n\t\t\t\t\t\t-\n\t\t\t\t\t\tfx) /\n\t\t\t\t\t  100 + fma + 29 * t3, (sb[t]\n\t\t\t\t\t\t\t\t-\n\t\t\t\t\t\t\t\tfy) /\n\t\t\t\t\t  100 + 29 * t2 + fmb);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (sxtype[t] == 10) {\n\t\t\tfor (t3 = 0; t3 <= sc[t] / 3000; t3++) {\n\t\t\t    drawimage(grap[65][1],\n\t\t\t\t      (sa[t] -\n\t\t\t\t       fx) / 100 +\n\t\t\t\t      fma + 29 * t3,\n\t\t\t\t      (sb[t] - fy) / 100 + fmb);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (stype[t] == 52) {\n\t\t    xx[29] = 0;\n\t\t    if (stagecolor == 2) {\n\t\t\txx[29] = 30;\n\t\t    }\n\t\t    if (stagecolor == 4) {\n\t\t\txx[29] = 60;\n\t\t    }\n\t\t    if (stagecolor == 5) {\n\t\t\txx[29] = 90;\n\t\t    }\n\t\t    for (t3 = 0; t3 <= sc[t] / 3000; t3++) {\n\t\t\tif (sxtype[t] == 0) {\n\t\t\t    drawimage(grap\n\t\t\t\t      [5 +\n\t\t\t\t       xx[29]][1],\n\t\t\t\t      (sa[t] -\n\t\t\t\t       fx) / 100 +\n\t\t\t\t      fma + 29 * t3,\n\t\t\t\t      (sb[t] - fy) / 100 + fmb);\n\t\t\t    if (stagecolor != 4) {\n\t\t\t\tdrawimage(grap[6 + xx[29]]\n\t\t\t\t\t  [1], (sa[t]\n\t\t\t\t\t\t-\n\t\t\t\t\t\tfx) /\n\t\t\t\t\t  100 + fma + 29 * t3, (sb[t]\n\t\t\t\t\t\t\t\t-\n\t\t\t\t\t\t\t\tfy) /\n\t\t\t\t\t  100 + fmb + 29);\n\t\t\t    } else {\n\t\t\t\tdrawimage(grap[5 + xx[29]]\n\t\t\t\t\t  [1], (sa[t]\n\t\t\t\t\t\t-\n\t\t\t\t\t\tfx) /\n\t\t\t\t\t  100 + fma + 29 * t3, (sb[t]\n\t\t\t\t\t\t\t\t-\n\t\t\t\t\t\t\t\tfy) /\n\t\t\t\t\t  100 + fmb + 29);\n\t\t\t    }\n\t\t\t}\n\t\t\tif (sxtype[t] == 1) {\n\t\t\t    for (t2 = 0; t2 <= sd[t] / 3000; t2++) {\n\t\t\t\tdrawimage(grap[1 + xx[29]]\n\t\t\t\t\t  [1], (sa[t]\n\t\t\t\t\t\t-\n\t\t\t\t\t\tfx) /\n\t\t\t\t\t  100 + fma + 29 * t3, (sb[t]\n\t\t\t\t\t\t\t\t-\n\t\t\t\t\t\t\t\tfy) /\n\t\t\t\t\t  100 + fmb + 29 * t2);\n\t\t\t    }\n\t\t\t}\n\t\t\tif (sxtype[t] == 2) {\n\t\t\t    for (t2 = 0; t2 <= sd[t] / 3000; t2++) {\n\t\t\t\tdrawimage(grap[5 + xx[29]]\n\t\t\t\t\t  [1], (sa[t]\n\t\t\t\t\t\t-\n\t\t\t\t\t\tfx) /\n\t\t\t\t\t  100 + fma + 29 * t3, (sb[t]\n\t\t\t\t\t\t\t\t-\n\t\t\t\t\t\t\t\tfy) /\n\t\t\t\t\t  100 + fmb + 29 * t2);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (trap == 1) {\n\t\t    if (stype[t] >= 100 && stype[t] <= 299) {\n\t\t\tif (stagecolor == 1\n\t\t\t    || stagecolor == 3 || stagecolor == 5)\n\t\t\t    setc0();\n\t\t\tif (stagecolor == 2 || stagecolor == 4)\n\t\t\t    setc1();\n\t\t\tdrawrect((sa[t] - fx) / 100 +\n\t\t\t\t fma,\n\t\t\t\t (sb[t] - fy) / 100 +\n\t\t\t\t fmb, sc[t] / 100, sd[t] / 100);\n\t\t    }\n\t\t}\n\t\tif (stype[t] == 300) {\n\t\t    setc1();\n\t\t    fillrect((sa[t] - fx) / 100 + 10,\n\t\t\t     (sb[t] - fy) / 100, 10, sd[t] / 100 - 8);\n\t\t    setc0();\n\t\t    drawrect((sa[t] - fx) / 100 + 10,\n\t\t\t     (sb[t] - fy) / 100, 10, sd[t] / 100 - 8);\n\t\t    setcolor(250, 250, 0);\n\t\t    fillarc((sa[t] - fx) / 100 + 15 - 1,\n\t\t\t    (sb[t] - fy) / 100, 10, 10);\n\t\t    setc0();\n\t\t    drawarc((sa[t] - fx) / 100 + 15 - 1,\n\t\t\t    (sb[t] - fy) / 100, 10, 10);\n\t\t}\n\t\tif (stype[t] == 500) {\n\t\t    drawimage(grap[20][4],\n\t\t\t      (sa[t] - fx) / 100, (sb[t] - fy) / 100);\n\t\t}\n\t    }\n\t}\n\tfor (t = 0; t < smax; t++) {\n\t    if (sa[t] - fx + sc[t] >= -10 && sa[t] - fx <= fxmax + 1100) {\n\t\tif (stype[t] == 40) {\n\t\t    setcolor(0, 230, 0);\n\t\t    fillrect((sa[t] - fx) / 100 + fma,\n\t\t\t     (sb[t] - fy) / 100 + fmb + 1,\n\t\t\t     sc[t] / 100, sd[t] / 100);\n\t\t    setc0();\n\t\t    drawrect((sa[t] - fx) / 100 + fma,\n\t\t\t     (sb[t] - fy) / 100 + fmb + 1,\n\t\t\t     sc[t] / 100, sd[t] / 100);\n\t\t}\n\t\tif (stype[t] == 50) {\n\t\t    setcolor(0, 230, 0);\n\t\t    fillrect((sa[t] - fx) / 100 + fma + 5,\n\t\t\t     (sb[t] - fy) / 100 + fmb + 30,\n\t\t\t     50, sd[t] / 100 - 30);\n\t\t    setc0();\n\t\t    drawline((sa[t] - fx) / 100 + 5 + fma,\n\t\t\t     (sb[t] - fy) / 100 + fmb + 30,\n\t\t\t     (sa[t] - fx) / 100 + fma + 5,\n\t\t\t     (sb[t] - fy) / 100 + fmb + sd[t] / 100);\n\t\t    drawline((sa[t] - fx) / 100 + 5 + fma +\n\t\t\t     50,\n\t\t\t     (sb[t] - fy) / 100 + fmb + 30,\n\t\t\t     (sa[t] - fx) / 100 + fma + 50 +\n\t\t\t     5, (sb[t] - fy) / 100 + fmb + sd[t] / 100);\n\t\t    setcolor(0, 230, 0);\n\t\t    fillrect((sa[t] - fx) / 100 + fma,\n\t\t\t     (sb[t] - fy) / 100 + fmb + 1, 60, 30);\n\t\t    setc0();\n\t\t    drawrect((sa[t] - fx) / 100 + fma,\n\t\t\t     (sb[t] - fy) / 100 + fmb + 1, 60, 30);\n\t\t}\n\t\tif (stype[t] == 200) {\n\t\t    for (t3 = 0; t3 <= sc[t] / 3000; t3++) {\n\t\t\tfor (t2 = 0; t2 <= sd[t] / 3000; t2++) {\n\t\t\t    drawimage(grap[65][1],\n\t\t\t\t      (sa[t] -\n\t\t\t\t       fx) / 100 +\n\t\t\t\t      fma + 29 * t3,\n\t\t\t\t      (sb[t] - fy) / 100 + 29 * t2 + fmb);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tfor (t = 0; t < amax; t++) {\n\t    xx[0] = aa[t] - fx;\n\t    xx[1] = ab[t] - fy;\n\t    xx[14] = 12000;\n\t    xx[16] = 0;\n\t    if (atype[t] == 87 || atype[t] == 88) {\n\t\tif (xx[0] + xx[2] * 100 >= -10 - xx[14]\n\t\t    && xx[1] <= fxmax + xx[14]\n\t\t    && xx[1] + xx[3] * 100 >= -10 && xx[3] <= fymax) {\n\t\t    for (tt = 0; tt <= axtype[t] % 100; tt++) {\n\t\t\txx[26] = 18;\n\t\t\txd[4] = tt * xx[26] * cos(atm[t] * pai / 180 / 2);\n\t\t\txd[5] = tt * xx[26] * sin(atm[t] * pai / 180 / 2);\n\t\t\txx[24] = (int) xd[4];\n\t\t\txx[25] = (int) xd[5];\n\t\t\tsetcolor(230, 120, 0);\n\t\t\txx[23] = 8;\n\t\t\tif (atype[t] == 87) {\n\t\t\t    fillarc(xx[0] / 100 +\n\t\t\t\t    xx[24],\n\t\t\t\t    xx[1] / 100 + xx[25], xx[23], xx[23]);\n\t\t\t    setcolor(0, 0, 0);\n\t\t\t    drawarc(xx[0] / 100 +\n\t\t\t\t    xx[24],\n\t\t\t\t    xx[1] / 100 + xx[25], xx[23], xx[23]);\n\t\t\t} else {\n\t\t\t    fillarc(xx[0] / 100 -\n\t\t\t\t    xx[24],\n\t\t\t\t    xx[1] / 100 + xx[25], xx[23], xx[23]);\n\t\t\t    setcolor(0, 0, 0);\n\t\t\t    drawarc(xx[0] / 100 -\n\t\t\t\t    xx[24],\n\t\t\t\t    xx[1] / 100 + xx[25], xx[23], xx[23]);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tsetc0();\n\tif (mmsgtm >= 1) {\n\t    mmsgtm--;\n\t    xs[0] = \"\";\n\t    if (mmsgtype == 1)\n\t\txs[0] = \"!!\";\n\t    if (mmsgtype == 2)\n\t\txs[0] = \"\";\n\t    if (mmsgtype == 3)\n\t\txs[0] = \"!!\";\n\t    if (mmsgtype == 10)\n\t\txs[0] = \"!!\";\n\t    if (mmsgtype == 11)\n\t\txs[0] = \"!!\";\n\t    if (mmsgtype == 50)\n\t\txs[0] = \"\";\n\t    if (mmsgtype == 51)\n\t\txs[0] = \"!!\";\n\t    if (mmsgtype == 52)\n\t\txs[0] = \"\";\n\t    if (mmsgtype == 53)\n\t\txs[0] = \"!!\";\n\t    if (mmsgtype == 54)\n\t\txs[0] = \"800!!\";\n\t    if (mmsgtype == 55)\n\t\txs[0] = \"\";\n\t    setc0();\n\t    str(xs[0], (ma + mnobia + 300) / 100 - 1, mb / 100 - 1);\n\t    str(xs[0], (ma + mnobia + 300) / 100 + 1, mb / 100 + 1);\n\t    setc1();\n\t    str(xs[0], (ma + mnobia + 300) / 100, mb / 100);\n\t}\n\tsetc0();\n\tfor (t = 0; t < amax; t++) {\n\t    if (amsgtm[t] >= 1) {\n\t\tamsgtm[t]--;\n\t\txs[0] = \"\";\n\t\tif (amsgtype[t] == 1001)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] == 1002)\n\t\t    xs[0] = \"??\";\n\t\tif (amsgtype[t] == 1003)\n\t\t    xs[0] = \"!\";\n\t\tif (amsgtype[t] == 1004)\n\t\t    xs[0] = \"\";\n\t\tif (amsgtype[t] == 1005)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] == 1006)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] == 1007)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] == 1008)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] == 1011)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] == 1012)\n\t\t    xs[0] = \"??\";\n\t\tif (amsgtype[t] == 1013)\n\t\t    xs[0] = \"!\";\n\t\tif (amsgtype[t] == 1014)\n\t\t    xs[0] = \"\";\n\t\tif (amsgtype[t] == 1015)\n\t\t    xs[0] = \"\";\n\t\tif (amsgtype[t] == 1016)\n\t\t    xs[0] = \"\";\n\t\tif (amsgtype[t] == 1017)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] == 1018)\n\t\t    xs[0] = \"\";\n\t\tif (amsgtype[t] == 1021)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] == 1022)\n\t\t    xs[0] = \"??\";\n\t\tif (amsgtype[t] == 1023)\n\t\t    xs[0] = \"\";\n\t\tif (amsgtype[t] == 1024)\n\t\t    xs[0] = \"\";\n\t\tif (amsgtype[t] == 1025)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] == 1026)\n\t\t    xs[0] = \"\";\n\t\tif (amsgtype[t] == 1027)\n\t\t    xs[0] =\n\t\t\t\"!!\";\n\t\tif (amsgtype[t] == 1028)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] == 1031)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] == 1032)\n\t\t    xs[0] = \"??\";\n\t\tif (amsgtype[t] == 1033)\n\t\t    xs[0] = \"!\";\n\t\tif (amsgtype[t] == 1034)\n\t\t    xs[0] = \"\";\n\t\tif (amsgtype[t] == 1035)\n\t\t    xs[0] = \"\";\n\t\tif (amsgtype[t] == 1036)\n\t\t    xs[0] = \"\";\n\t\tif (amsgtype[t] == 1037)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] == 1038)\n\t\t    xs[0] = \"\";\n\t\tif (amsgtype[t] == 15)\n\t\t    xs[0] = \"!!!!\";\n\t\tif (amsgtype[t] == 16)\n\t\t    xs[0] = \"?\";\n\t\tif (amsgtype[t] == 17)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] == 18)\n\t\t    xs[0] = \"\";\n\t\tif (amsgtype[t] == 20)\n\t\t    xs[0] = \"Zzz\";\n\t\tif (amsgtype[t] == 21)\n\t\t    xs[0] = \"\";\n\t\tif (amsgtype[t] == 24)\n\t\t    xs[0] = \"?\";\n\t\tif (amsgtype[t] == 25)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] == 30)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] == 31)\n\t\t    xs[0] = \"?\";\n\t\tif (amsgtype[t] == 32)\n\t\t    xs[0] = \"\";\n\t\tif (amsgtype[t] == 50)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] == 85)\n\t\t    xs[0] = \"?\";\n\t\tif (amsgtype[t] == 86)\n\t\t    xs[0] = \"!!\";\n\t\tif (amsgtype[t] != 31) {\n\t\t    xx[5] = (aa[t] + anobia[t] + 300 - fx) / 100;\n\t\t    xx[6] = (ab[t] - fy) / 100;\n\t\t} else {\n\t\t    xx[5] = (aa[t] + anobia[t] + 300 - fx) / 100;\n\t\t    xx[6] = (ab[t] - fy - 800) / 100;\n\t\t}\n\t\tChangeFontType(DX_FONTTYPE_EDGE);\n\t\tsetc1();\n\t\tstr(xs[0], xx[5], xx[6]);\n\t\tChangeFontType(DX_FONTTYPE_NORMAL);\n\t    }\n\t}\n\tif (tmsgtm > 0) {\n\t    ttmsg();\n\t    if (tmsgtype == 1) {\n\t\txx[0] = 1200;\n\t\ttmsgy += xx[0];\n\t\tif (tmsgtm == 1) {\n\t\t    tmsgtm = 80000000;\n\t\t    tmsgtype = 2;\n\t\t}\n\t    }\n\t    else if (tmsgtype == 2) {\n\t\ttmsgy = 0;\n\t\ttmsgtype = 3;\n\t\ttmsgtm = 15 + 1;\n\t    }\n\t    else if (tmsgtype == 3) {\n\t\txx[0] = 1200;\n\t\ttmsgy += xx[0];\n\t\tif (tmsgtm == 15)\n\t\t    WaitKey();\n\t\tif (tmsgtm == 1) {\n\t\t    tmsgtm = 0;\n\t\t    tmsgtype = 0;\n\t\t    tmsgy = 0;\n\t\t}\n\t    }\n\t    tmsgtm--;\n\t}\n\tif (mainmsgtype >= 1) {\n\t    setfont(20, 4);\n\t    if (mainmsgtype == 1) {\n\t\tDrawFormatString(126, 100,\n\t\t\t\t GetColor(255, 255, 255),\n\t\t\t\t \"WELCOME TO OWATA ZONE\");\n\t    }\n\t    if (mainmsgtype == 1) {\n\t\tfor (t2 = 0; t2 <= 2; t2++)\n\t\t    DrawFormatString(88 + t2 * 143, 210,\n\t\t\t\t     GetColor(255, 255, 255), \"1\");\n\t    }\n\t    setfont(20, 5);\n\t}\n\tif (blacktm > 0) {\n\t    blacktm--;\n\t    fillrect(0, 0, fxmax, fymax);\n\t    if (blacktm == 0) {\n\t\tif (blackx == 1) {\n\t\t    zxon = 0;\n\t\t}\n\t    }\n\t}\n    }\n    if (mainZ == 2) {\n\tsetcolor(255, 255, 255);\n\tstr(\"\",\n\t    240 - 13 * 20 / 2, xx[12] / 100);\n\tstr(\"\", 240 - 9 * 20 / 2, xx[13] / 100);\n\tstr(\"TODO: Fix this encoding error...\",240-6*20/2,xx[14]/100);\n\tstr(\"\", 240 - 9 * 20 / 2, xx[15] / 100);\n\tstr(\"willowlet \", 240 - 8 * 20 / 2, xx[16] / 100);\n\tstr(\"\", 240 - 9 * 20 / 2, xx[17] / 100);\n\tstr(\"willowlet \", 240 - 8 * 20 / 2, xx[18] / 100);\n\tstr(\"\", 240 - 9 * 20 / 2, xx[19] / 100);\n\tstr(\"ann \", 240 - 6 * 20 / 2, xx[20] / 100);\n\tstr(\"\", 240 - 3 * 20 / 2, xx[21] / 100);\n\tstr(\"\", 240 - 3 * 20 / 2, xx[22] / 100);\n\tstr(\"\", 240 - 3 * 20 / 2, xx[23] / 100);\n\tstr(\"\", 240 - 6 * 20 / 2, xx[24] / 100);\n\tstr(\"\", 240 - 3 * 20 / 2, xx[25] / 100);\n\tstr(\"\",\n\t    240 - 16 * 20 / 2, xx[26] / 100);\n\tstr(\"willowlet \", 240 - 5 * 20 / 2, xx[27] / 100);\n\tstr(\"\",\n\t    240 - 16 * 20 / 2, xx[28] / 100);\n\tstr(\"\", 240 - 2 * 20 / 2, xx[29] / 100);\n\tstr(\"\", 240 - 22 * 20 / 2, xx[30] / 100);\n    }\n    if (mainZ == 10) {\n\tsetc0();\n\tFillScreen();\n\tSetFontSize(16);\n\tSetFontThickness(4);\n\tdrawimage(grap[0][0], 190, 190);\n\tDrawFormatString(230, 200, GetColor(255, 255, 255), \"  %d\",\n\t\t\t nokori);\n    }\n    if (mainZ == 100) {\n\tsetcolor(160, 180, 250);\n\tfillrect(0, 0, fxmax, fymax);\n\tdrawimage(mgrap[30], 240 - 380 / 2, 60);\n\tdrawimage(grap[0][4], 12 * 30, 10 * 29 - 12);\n\tdrawimage(grap[1][4], 6 * 30, 12 * 29 - 12);\n\tdrawimage(grap[0][0], 2 * 30, 12 * 29 - 12 - 6);\n\tfor (t = 0; t <= 16; t++) {\n\t    drawimage(grap[5][1], 29 * t, 13 * 29 - 12);\n\t    drawimage(grap[6][1], 29 * t, 14 * 29 - 12);\n\t}\n\tsetcolor(0, 0, 0);\n\tstr(\"Enter!!\", 240 - 8 * 20 / 2, 250);\n    }\n    ScreenFlip();\n}\nvoid Mainprogram()\n{\n    stime = long (GetNowCount());\n    if (ending == 1)\n\tmainZ = 2;\n    if (mainZ == 1 && tmsgtype == 0) {\n\tif (zxon == 0) {\n\t    zxon = 1;\n\t    mainmsgtype = 0;\n\t    stagecolor = 1;\n\t    ma = 5600;\n\t    mb = 32000;\n\t    mmuki = 1;\n\t    mhp = 1;\n\t    mc = 0;\n\t    md = 0;\n\t    mnobia = 3000;\n\t    mnobib = 3600;\n\t    mtype = 0;\n\t    fx = 0;\n\t    fy = 0;\n\t    fzx = 0;\n\t    stageonoff = 0;\n\t    bgmchange(otom[1]);\n\t    stagecls();\n\t    stage();\n\t    if (over == 1) {\n\t\tfor (t = 0; t < tmax; t++) {\n\t\t    if (rand(3) <= 1) {\n\t\t\tta[t] = (rand(500) - 1) * 29 * 100;\n\t\t\ttb[t] = rand(14) * 100 * 29 - 1200;\n\t\t\tttype[t] = rand(142);\n\t\t\tif (ttype[t] >= 9 && ttype[t] <= 99) {\n\t\t\t    ttype[t] = rand(8);\n\t\t\t}\n\t\t\ttxtype[t] = rand(4);\n\t\t    }\n\t\t}\n\t\tfor (t = 0; t < bmax; t++) {\n\t\t    if (rand(2) <= 1) {\n\t\t\tba[t] = (rand(500) - 1) * 29 * 100;\n\t\t\tbb[t] = rand(15) * 100 * 29 - 1200 - 3000;\n\t\t\tif (rand(6) == 0) {\n\t\t\t    btype[t] = rand(9);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tsrco = 0;\n\t\tt = srco;\n\t\tsra[t] = ma + fx;\n\t\tsrb[t] = (13 * 29 - 12) * 100;\n\t\tsrc[t] = 30 * 100;\n\t\tsrtype[t] = 0;\n\t\tsracttype[t] = 0;\n\t\tsre[t] = 0;\n\t\tsrsp[t] = 0;\n\t\tsrco++;\n\t\tif (rand(4) == 0)\n\t\t    stagecolor = rand(5);\n\t    }\n\t}\n\txx[0] = 0;\n\tactaon[2] = 0;\n\tactaon[3] = 0;\n\tif (mkeytm <= 0) {\n\t    if (CheckHitKey(KEY_INPUT_LEFT)\n\t\t&& keytm <= 0) {\n\t\tactaon[0] = -1;\n\t\tmmuki = 0;\n\t\tactaon[4] = -1;\n\t    }\n\t    if (CheckHitKey(KEY_INPUT_RIGHT)\n\t\t&& keytm <= 0) {\n\t\tactaon[0] = 1;\n\t\tmmuki = 1;\n\t\tactaon[4] = 1;\n\t    }\n\t    if (CheckHitKey(KEY_INPUT_DOWN)\n\t\t) {\n\t\tactaon[3] = 1;\n\t    }\n\t}\n\tif (CheckHitKey(KEY_INPUT_F1) == 1) {\n\t    mainZ = 100;\n\t}\n\tif (CheckHitKey(KEY_INPUT_O) == 1) {\n\t    if (mhp >= 1)\n\t\tmhp = 0;\n\t    if (stc >= 5) {\n\t\tstc = 0;\n\t\tstagepoint = 0;\n\t    }\n\t}\n\tif (mkeytm <= 0) {\n\t    if (CheckHitKey(KEY_INPUT_Z) == 1 || CheckHitKey(KEY_INPUT_UP) == 1\n\t\t|| SDL_JoystickGetButton(joystick, JOYSTICK_JUMP)) {\n\t\tif (actaon[1] == 10) {\n\t\t    actaon[1] = 1;\n\t\t    xx[0] = 1;\n\t\t}\n\t\tactaon[2] = 1;\n\t    }\n\t}\n\tif (CheckHitKey(KEY_INPUT_Z) == 1\n\t    || CheckHitKey(KEY_INPUT_UP) == 1\n\t    || SDL_JoystickGetButton(joystick, JOYSTICK_JUMP)) {\n\t    if (mjumptm == 8 && md >= -900) {\n\t\tmd = -1300;\n\t\txx[22] = 200;\n\t\tif (mc >= xx[22] || mc <= -xx[22]) {\n\t\t    md = -1400;\n\t\t}\n\t\txx[22] = 600;\n\t\tif (mc >= xx[22] || mc <= -xx[22]) {\n\t\t    md = -1500;\n\t\t}\n\t    }\n\t    if (xx[0] == 0)\n\t\tactaon[1] = 10;\n\t}\n\txx[0] = 40;\n\txx[1] = 700;\n\txx[8] = 500;\n\txx[9] = 700;\n\txx[12] = 1;\n\txx[13] = 2;\n\tif (mrzimen == 1) {\n\t    xx[0] = 20;\n\t    xx[12] = 9;\n\t    xx[13] = 10;\n\t}\n\tif (actaon[0] == -1) {\n\t    if (!(mzimen == 0 && mc < -xx[8])) {\n\t\tif (mc >= -xx[9]) {\n\t\t    mc -= xx[0];\n\t\t    if (mc < -xx[9]) {\n\t\t\tmc = -xx[9] - 1;\n\t\t    }\n\t\t}\n\t\tif (mc < -xx[9] && atktm <= 0)\n\t\t    mc -= xx[0] / 10;\n\t    }\n\t    if (mrzimen != 1) {\n\t\tif (mc > 100 && mzimen == 0) {\n\t\t    mc -= xx[0] * 2 / 3;\n\t\t}\n\t\tif (mc > 100 && mzimen == 1) {\n\t\t    mc -= xx[0];\n\t\t    if (mzimen == 1) {\n\t\t\tmc -= xx[0] * 1 / 2;\n\t\t    }\n\t\t}\n\t\tactaon[0] = 3;\n\t\tmkasok += 1;\n\t    }\n\t}\n\tif (actaon[0] == 1) {\n\t    if (!(mzimen == 0 && mc > xx[8])) {\n\t\tif (mc <= xx[9]) {\n\t\t    mc += xx[0];\n\t\t    if (mc > xx[9]) {\n\t\t\tmc = xx[9] + 1;\n\t\t    }\n\t\t}\n\t\tif (mc > xx[9] && atktm <= 0)\n\t\t    mc += xx[0] / 10;\n\t    }\n\t    if (mrzimen != 1) {\n\t\tif (mc < -100 && mzimen == 0) {\n\t\t    mc += xx[0] * 2 / 3;\n\t\t}\n\t\tif (mc < -100 && mzimen == 1) {\n\t\t    mc += xx[0];\n\t\t    if (mzimen == 1) {\n\t\t\tmc += xx[0] * 1 / 2;\n\t\t    }\n\t\t}\n\t\tactaon[0] = 3;\n\t\tmkasok += 1;\n\t    }\n\t}\n\tif (actaon[0] == 0 && mkasok > 0) {\n\t    mkasok -= 2;\n\t}\n\tif (mkasok > 8) {\n\t    mkasok = 8;\n\t}\n\tif (mzimen != 1)\n\t    mrzimen = 0;\n\tif (mjumptm >= 0)\n\t    mjumptm--;\n\tif (actaon[1] == 1 && mzimen == 1) {\n\t    mb -= 400;\n\t    md = -1200;\n\t    mjumptm = 10;\n\t    ot(oto[1]);\n/*\nmd=-1040;\nxx[1]=600;if (mc>xx[1] || mc<=-xx[1]){md=-1400;}\nxx[1]=7;xx[2]=400;\nif (mkasok>xx[1] && (mc>xx[2] || mc<=-xx[2])){\nmd=-1600;\nif (mc>=800 || mc<=-800){md=-1800;}\n}\n*/\n\t    mzimen = 0;\n\t}\n\tif (actaon[1] <= 9)\n\t    actaon[1] = 0;\n\tif (mmutekitm >= -1)\n\t    mmutekitm--;\n\tif (mhp <= 0 && mhp >= -9) {\n\t    mkeytm = 12;\n\t    mhp = -20;\n\t    mtype = 200;\n\t    mtm = 0;\n\t    Mix_HaltChannel(-1);\n\t    Mix_HaltMusic();\n\t    ot(oto[12]);\n\t    StopSoundMem(oto[16]);\n\t}\n\tif (mtype == 200) {\n\t    if (mtm <= 11) {\n\t\tmc = 0;\n\t\tmd = 0;\n\t    }\n\t    if (mtm == 12) {\n\t\tmd = -1200;\n\t    }\n\t    if (mtm >= 12) {\n\t\tmc = 0;\n\t    }\n\t    if (mtm >= 100 || fast == 1) {\n\t\tzxon = 0;\n\t\tmainZ = 10;\n\t\tmtm = 0;\n\t\tmkeytm = 0;\n\t\tnokori--;\n\t\tif (fast == 1)\n\t\t    mtype = 0;\n\t    }\n\t}\n\tif (mtype == 2) {\n\t    mtm++;\n\t    mkeytm = 2;\n\t    md = -1500;\n\t    if (mb <= -6000) {\n\t\tblackx = 1;\n\t\tblacktm = 20;\n\t\tstc += 5;\n\t\tstagerr = 0;\n\t\tMix_HaltMusic();\n\t\tmtm = 0;\n\t\tmtype = 0;\n\t\tmkeytm = -1;\n\t    }\n\t}\n\tif (mtype == 3) {\n\t    md = -2400;\n\t    if (mb <= -6000) {\n\t\tmb = -80000000;\n\t\tmhp = 0;\n\t    }\n\t}\n\tif (mtype >= 100) {\n\t    mtm++;\n\t    if (mtype == 100) {\n\t\tif (mxtype == 0) {\n\t\t    mc = 0;\n\t\t    md = 0;\n\t\t    t = 28;\n\t\t    if (mtm <= 16) {\n\t\t\tmb += 240;\n\t\t\tmzz = 100;\n\t\t    }\n\t\t    if (mtm == 17) {\n\t\t\tmb = -80000000;\n\t\t    }\n\t\t    if (mtm == 23) {\n\t\t\tsa[t] -= 100;\n\t\t    }\n\t\t    if (mtm >= 44 && mtm <= 60) {\n\t\t\tif (mtm % 2 == 0)\n\t\t\t    sa[t] += 200;\n\t\t\tif (mtm % 2 == 1)\n\t\t\t    sa[t] -= 200;\n\t\t    }\n\t\t    if (mtm >= 61 && mtm <= 77) {\n\t\t\tif (mtm % 2 == 0)\n\t\t\t    sa[t] += 400;\n\t\t\tif (mtm % 2 == 1)\n\t\t\t    sa[t] -= 400;\n\t\t    }\n\t\t    if (mtm >= 78 && mtm <= 78 + 16) {\n\t\t\tif (mtm % 2 == 0)\n\t\t\t    sa[t] += 600;\n\t\t\tif (mtm % 2 == 1)\n\t\t\t    sa[t] -= 600;\n\t\t    }\n\t\t    if (mtm >= 110) {\n\t\t\tsb[t] -= mzz;\n\t\t\tmzz += 80;\n\t\t\tif (mzz > 1600)\n\t\t\t    mzz = 1600;\n\t\t    }\n\t\t    if (mtm == 160) {\n\t\t\tmtype = 0;\n\t\t\tmhp--;\n\t\t    }\n\t\t}\n\t\telse if (mxtype == 10) {\n\t\t    mc = 0;\n\t\t    md = 0;\n\t\t    if (mtm <= 16) {\n\t\t\tma += 240;\n\t\t    }\n\t\t    if (mtm == 16)\n\t\t\tmb -= 1100;\n\t\t    if (mtm == 20)\n\t\t\tot(oto[10]);\n\t\t    if (mtm >= 24) {\n\t\t\tma -= 2000;\n\t\t\tmmuki = 0;\n\t\t    }\n\t\t    if (mtm >= 48) {\n\t\t\tmtype = 0;\n\t\t\tmhp--;\n\t\t    }\n\t\t} else {\n\t\t    mc = 0;\n\t\t    md = 0;\n\t\t    if (mtm <= 16 && mxtype != 3) {\n\t\t\tmb += 240;\n\t\t    }\n\t\t    if (mtm <= 16 && mxtype == 3) {\n\t\t\tma += 240;\n\t\t    }\n\t\t    if (mtm == 19 && mxtype == 2) {\n\t\t\tmhp = 0;\n\t\t\tmtype = 2000;\n\t\t\tmtm = 0;\n\t\t\tmmsgtm = 30;\n\t\t\tmmsgtype = 51;\n\t\t    }\n\t\t    if (mtm == 19 && mxtype == 5) {\n\t\t\tmhp = 0;\n\t\t\tmtype = 2000;\n\t\t\tmtm = 0;\n\t\t\tmmsgtm = 30;\n\t\t\tmmsgtype = 52;\n\t\t    }\n\t\t    if (mtm == 20) {\n\t\t\tif (mxtype == 6) {\n\t\t\t    stc += 10;\n\t\t\t} else {\n\t\t\t    stc++;\n\t\t\t}\n\t\t\tmb = -80000000;\n\t\t\tmxtype = 0;\n\t\t\tblackx = 1;\n\t\t\tblacktm = 20;\n\t\t\tstagerr = 0;\n\t\t\tMix_HaltMusic();\n\t\t    }\n\t\t}\n\t    }\n\t    if (mtype == 300) {\n\t\tmkeytm = 3;\n\t\tif (mtm <= 1) {\n\t\t    mc = 0;\n\t\t    md = 0;\n\t\t}\n\t\tif (mtm >= 2 && mtm <= 42) {\n\t\t    md = 600;\n\t\t    mmuki = 1;\n\t\t}\n\t\tif (mtm > 43 && mtm <= 108) {\n\t\t    mc = 300;\n\t\t}\n\t\tif (mtm == 110) {\n\t\t    mb = -80000000;\n\t\t    mc = 0;\n\t\t}\n\t\tif (mtm == 250) {\n\t\t    stb++;\n\t\t    stc = 0;\n\t\t    zxon = 0;\n\t\t    tyuukan = 0;\n\t\t    mainZ = 10;\n\t\t    maintm = 0;\n\t\t}\n\t    }\n\t    if (mtype == 301 || mtype == 302) {\n\t\tmkeytm = 3;\n\t\tif (mtm <= 1) {\n\t\t    mc = 0;\n\t\t    md = 0;\n\t\t}\n\t\tif (mtm >= 2\n\t\t    && (mtype == 301 && mtm <= 102\n\t\t\t|| mtype == 302 && mtm <= 60)) {\n\t\t    xx[5] = 500;\n\t\t    ma -= xx[5];\n\t\t    fx += xx[5];\n\t\t    fzx += xx[5];\n\t\t}\n\t\tif ((mtype == 301 || mtype == 302) && mtm >= 2\n\t\t    && mtm <= 100) {\n\t\t    mc = 250;\n\t\t    mmuki = 1;\n\t\t}\n\t\tif (mtm == 200) {\n\t\t    ot(oto[17]);\n\t\t    if (mtype == 301) {\n\t\t\tna[nco] = 117 * 29 * 100 - 1100;\n\t\t\tnb[nco] = 4 * 29 * 100;\n\t\t\tntype[nco] = 101;\n\t\t\tnco++;\n\t\t\tif (nco >= nmax)\n\t\t\t    nco = 0;\n\t\t\tna[nco] = 115 * 29 * 100 - 1100;\n\t\t\tnb[nco] = 6 * 29 * 100;\n\t\t\tntype[nco] = 102;\n\t\t\tnco++;\n\t\t\tif (nco >= nmax)\n\t\t\t    nco = 0;\n\t\t    } else {\n\t\t\tna[nco] = 157 * 29 * 100 - 1100;\n\t\t\tnb[nco] = 4 * 29 * 100;\n\t\t\tntype[nco] = 101;\n\t\t\tnco++;\n\t\t\tif (nco >= nmax)\n\t\t\t    nco = 0;\n\t\t\tna[nco] = 155 * 29 * 100 - 1100;\n\t\t\tnb[nco] = 6 * 29 * 100;\n\t\t\tntype[nco] = 102;\n\t\t\tnco++;\n\t\t\tif (nco >= nmax)\n\t\t\t    nco = 0;\n\t\t    }\n\t\t}\n\t\tif (mtm == 440) {\n\t\t    if (mtype == 301) {\n\t\t\tending = 1;\n\t\t    } else {\n\t\t\tsta++;\n\t\t\tstb = 1;\n\t\t\tstc = 0;\n\t\t\tzxon = 0;\n\t\t\ttyuukan = 0;\n\t\t\tmainZ = 10;\n\t\t\tmaintm = 0;\n\t\t    }\n\t\t}\n/*\nif (mtm<=1){mc=0;md=0;}\nif (mtm>=2 && mtm<=42){md=600;mmuki=1;}\nif (mtm>43 && mtm<=108){mc=300;}\nif (mtm==110){mb=-80000000;mc=0;}\nif (mtm==250)end();\n*/\n\t    }\n\t}\n\tif (mkeytm >= 1) {\n\t    mkeytm--;\n\t}\n\tma += mc;\n\tmb += md;\n\tif (mc < 0)\n\t    mactp += (-mc);\n\tif (mc >= 0)\n\t    mactp += mc;\n\tif (mtype <= 9 || mtype == 200 || mtype == 300 || mtype == 301\n\t    || mtype == 302)\n\t    md += 100;\n\tif (mtype == 0) {\n\t    xx[0] = 800;\n\t    xx[1] = 1600;\n\t    if (mc > xx[0] && mc < xx[0] + 200) {\n\t\tmc = xx[0];\n\t    }\n\t    if (mc > xx[0] + 200) {\n\t\tmc -= 200;\n\t    }\n\t    if (mc < -xx[0] && mc > -xx[0] - 200) {\n\t\tmc = -xx[0];\n\t    }\n\t    if (mc < -xx[0] - 200) {\n\t\tmc += 200;\n\t    }\n\t    if (md > xx[1]) {\n\t\tmd = xx[1];\n\t    }\n\t}\n\tif (mzimen == 1 && actaon[0] != 3) {\n\t    if ((mtype <= 9) || mtype == 300 || mtype == 301\n\t\t|| mtype == 302) {\n\t\tif (mrzimen == 0) {\n\t\t    xx[2] = 30;\n\t\t    xx[1] = 60;\n\t\t    xx[3] = 30;\n\t\t    if (mc >= -xx[3] && mc <= xx[3]) {\n\t\t\tmc = 0;\n\t\t    }\n\t\t    if (mc >= xx[2]) {\n\t\t\tmc -= xx[1];\n\t\t    }\n\t\t    if (mc <= -xx[2]) {\n\t\t\tmc += xx[1];\n\t\t    }\n\t\t}\n\t\tif (mrzimen == 1) {\n\t\t    xx[2] = 5;\n\t\t    xx[1] = 10;\n\t\t    xx[3] = 5;\n\t\t    if (mc >= -xx[3] && mc <= xx[3]) {\n\t\t\tmc = 0;\n\t\t    }\n\t\t    if (mc >= xx[2]) {\n\t\t\tmc -= xx[1];\n\t\t    }\n\t\t    if (mc <= -xx[2]) {\n\t\t\tmc += xx[1];\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tmzimen = 0;\n\tif (mtype <= 9 && mhp >= 1) {\n\t    if (ma < 100) {\n\t\tma = 100;\n\t\tmc = 0;\n\t    }\n\t    if (ma + mnobia > fxmax) {\n\t\tma = fxmax - mnobia;\n\t\tmc = 0;\n\t    }\n\t}\n\tif (mb >= 38000 && mhp >= 0 && stagecolor == 4) {\n\t    mhp = -2;\n\t    mmsgtm = 30;\n\t    mmsgtype = 55;\n\t}\n\tif (mb >= 52000 && mhp >= 0) {\n\t    mhp = -2;\n\t}\n\txx[15] = 0;\n\tfor (t = 0; t < tmax; t++) {\n\t    xx[0] = 200;\n\t    xx[1] = 3000;\n\t    xx[2] = 1000;\n\t    xx[3] = 3000;\n\t    xx[8] = ta[t] - fx;\n\t    xx[9] = tb[t] - fy;\n\t    if (ta[t] - fx + xx[1] >= -10 - xx[3]\n\t\t&& ta[t] - fx <= fxmax + 12000 + xx[3]) {\n\t\tif (mtype != 200 && mtype != 1 && mtype != 2) {\n\t\t    if (ttype[t] < 1000 && ttype[t] != 800 && ttype[t] != 140 && ttype[t] != 141) {\n\t\t\tif (!(mztype == 1)) {\n\t\t\t    xx[16] = 0;\n\t\t\t    xx[17] = 0;\n\t\t\t    if (ttype[t] != 7\n\t\t\t\t&& ttype[t] != 110 && !(ttype[t] == 114)) {\n\t\t\t\tif (ma +\n\t\t\t\t    mnobia >\n\t\t\t\t    xx[8] +\n\t\t\t\t    xx[0] * 2 +\n\t\t\t\t    100\n\t\t\t\t    && ma <\n\t\t\t\t    xx[8] +\n\t\t\t\t    xx[1] -\n\t\t\t\t    xx[0] * 2 - 100 && mb + mnobib > xx[9]\n\t\t\t\t    && mb + mnobib < xx[9] + xx[1]\n\t\t\t\t    && md >= -100) {\n\t\t\t\t    if (ttype[t] != 115 && ttype[t] != 400\n\t\t\t\t\t&& ttype[t] != 117\n\t\t\t\t\t&& ttype[t] != 118\n\t\t\t\t\t&& ttype[t] != 120) {\n\t\t\t\t\tmb = xx[9] - mnobib + 100;\n\t\t\t\t\tmd = 0;\n\t\t\t\t\tmzimen = 1;\n\t\t\t\t\txx[16] = 1;\n\t\t\t\t    } else if (ttype[t]\n\t\t\t\t\t       == 115) {\n\t\t\t\t\tot(oto[3]);\n\t\t\t\t\teyobi(ta[t]\n\t\t\t\t\t      + 1200, tb[t]\n\t\t\t\t\t      +\n\t\t\t\t\t      1200,\n\t\t\t\t\t      300,\n\t\t\t\t\t      -1000,\n\t\t\t\t\t      0, 160, 1000, 1000, 1, 120);\n\t\t\t\t\teyobi(ta[t]\n\t\t\t\t\t      + 1200, tb[t]\n\t\t\t\t\t      +\n\t\t\t\t\t      1200,\n\t\t\t\t\t      -300,\n\t\t\t\t\t      -1000,\n\t\t\t\t\t      0, 160, 1000, 1000, 1, 120);\n\t\t\t\t\teyobi(ta[t]\n\t\t\t\t\t      + 1200, tb[t]\n\t\t\t\t\t      +\n\t\t\t\t\t      1200,\n\t\t\t\t\t      240,\n\t\t\t\t\t      -1400,\n\t\t\t\t\t      0, 160, 1000, 1000, 1, 120);\n\t\t\t\t\teyobi(ta[t]\n\t\t\t\t\t      + 1200, tb[t]\n\t\t\t\t\t      +\n\t\t\t\t\t      1200,\n\t\t\t\t\t      -240,\n\t\t\t\t\t      -1400,\n\t\t\t\t\t      0, 160, 1000, 1000, 1, 120);\n\t\t\t\t\tbrockbreak(t);\n\t\t\t\t    }\n\t\t\t\t    else if (ttype[t]\n\t\t\t\t\t     == 400) {\n\t\t\t\t\tmd = 0;\n\t\t\t\t\tta[t] = -8000000;\n\t\t\t\t\tot(oto[13]);\n\t\t\t\t\tfor (tt = 0; tt < tmax; tt++) {\n\t\t\t\t\t    if (ttype[tt] != 7) {\n\t\t\t\t\t\tttype[tt]\n\t\t\t\t\t\t    = 800;\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t\tMix_HaltMusic();\n\t\t\t\t    }\n\t\t\t\t    else if (ttype[t]\n\t\t\t\t\t     == 117) {\n\t\t\t\t\tot(oto[14]);\n\t\t\t\t\tmd = -1500;\n\t\t\t\t\tmtype = 2;\n\t\t\t\t\tmtm = 0;\n\t\t\t\t\tif (txtype[t] >= 2 && mtype == 2) {\n\t\t\t\t\t    mtype = 0;\n\t\t\t\t\t    md = -1600;\n\t\t\t\t\t    txtype[t]\n\t\t\t\t\t\t= 3;\n\t\t\t\t\t}\n\t\t\t\t\tif (txtype[t] == 0)\n\t\t\t\t\t    txtype[t]\n\t\t\t\t\t\t= 1;\n\t\t\t\t    }\n\t\t\t\t    else if (ttype[t]\n\t\t\t\t\t     == 120) {\n\t\t\t\t\tmd = -2400;\n\t\t\t\t\tmtype = 3;\n\t\t\t\t\tmtm = 0;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t\tif (!(mztm >= 1 && mztype == 1)) {\n\t\t\t    xx[21] = 0;\n\t\t\t    xx[22] = 1;\n\t\t\t    if (mzimen == 1 || mjumptm >= 10) {\n\t\t\t\txx[21] = 3;\n\t\t\t\txx[22] = 0;\n\t\t\t    }\n\t\t\t    for (t3 = 0; t3 <= 1; t3++) {\n\t\t\t\tif (t3 == xx[21] && mtype != 100 && ttype[t] != 117) {\n\t\t\t\t    if (ma + mnobia > xx[8]\n\t\t\t\t\t+ xx[0]\n\t\t\t\t\t* 2 + 800 && ma < xx[8]\n\t\t\t\t\t+ xx[1]\n\t\t\t\t\t- xx[0]\n\t\t\t\t\t* 2 - 800 && mb > xx[9]\n\t\t\t\t\t- xx[0]\n\t\t\t\t\t* 2 && mb < xx[9]\n\t\t\t\t\t+ xx[1]\n\t\t\t\t\t- xx[0]\n\t\t\t\t\t* 2 && md <= 0) {\n\t\t\t\t\txx[16] = 1;\n\t\t\t\t\txx[17] = 1;\n\t\t\t\t\tmb = xx[9] + xx[1] + xx[0];\n\t\t\t\t\tif (md < 0) {\n\t\t\t\t\t    md = -md * 2 / 3;\n\t\t\t\t\t}\n\t\t\t\t\tif (ttype[t] == 1 && mzimen == 0) {\n\t\t\t\t\t    ot(oto[3]);\n\t\t\t\t\t    eyobi(ta[t]\n\t\t\t\t\t\t  + 1200, tb[t]\n\t\t\t\t\t\t  +\n\t\t\t\t\t\t  1200,\n\t\t\t\t\t\t  300,\n\t\t\t\t\t\t  -1000,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  160, 1000, 1000, 1, 120);\n\t\t\t\t\t    eyobi(ta[t]\n\t\t\t\t\t\t  + 1200, tb[t]\n\t\t\t\t\t\t  +\n\t\t\t\t\t\t  1200,\n\t\t\t\t\t\t  -300,\n\t\t\t\t\t\t  -1000,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  160, 1000, 1000, 1, 120);\n\t\t\t\t\t    eyobi(ta[t]\n\t\t\t\t\t\t  + 1200, tb[t]\n\t\t\t\t\t\t  +\n\t\t\t\t\t\t  1200,\n\t\t\t\t\t\t  240,\n\t\t\t\t\t\t  -1400,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  160, 1000, 1000, 1, 120);\n\t\t\t\t\t    eyobi(ta[t]\n\t\t\t\t\t\t  + 1200, tb[t]\n\t\t\t\t\t\t  +\n\t\t\t\t\t\t  1200,\n\t\t\t\t\t\t  -240,\n\t\t\t\t\t\t  -1400,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  160, 1000, 1000, 1, 120);\n\t\t\t\t\t    brockbreak(t);\n\t\t\t\t\t}\n\t\t\t\t\tif (ttype[t] == 2 && mzimen == 0) {\n\t\t\t\t\t    ot(oto[4]);\n\t\t\t\t\t    eyobi(ta[t]\n\t\t\t\t\t\t  +\n\t\t\t\t\t\t  10,\n\t\t\t\t\t\t  tb\n\t\t\t\t\t\t  [t],\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  -800,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  40, 3000, 3000, 0, 16);\n\t\t\t\t\t    ttype[t]\n\t\t\t\t\t\t= 3;\n\t\t\t\t\t}\n\t\t\t\t\tif (ttype[t] == 7) {\n\t\t\t\t\t    ot(oto[4]);\n\t\t\t\t\t    eyobi(ta[t]\n\t\t\t\t\t\t  +\n\t\t\t\t\t\t  10,\n\t\t\t\t\t\t  tb\n\t\t\t\t\t\t  [t],\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  -800,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  40, 3000, 3000, 0, 16);\n\t\t\t\t\t    mb = xx[9] + xx[1] + xx[0];\n\t\t\t\t\t    ttype[t]\n\t\t\t\t\t\t= 3;\n\t\t\t\t\t    if (md < 0) {\n\t\t\t\t\t\tmd = -md * 2 / 3;\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t\tif (ttype[t] == 10) {\n\t\t\t\t\t    mmsgtm = 30;\n\t\t\t\t\t    mmsgtype = 3;\n\t\t\t\t\t    mhp--;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (t3 == xx[22]\n\t\t\t\t    && xx[15] == 0) {\n\t\t\t\t    if (ttype[t] != 7 && ttype[t] != 110\n\t\t\t\t\t&& ttype[t] != 117) {\n\t\t\t\t\tif (!(ttype[t] == 114)) {\n\t\t\t\t\t    if (ta[t] >= -20000) {\n\t\t\t\t\t\tif (ma + mnobia > xx[8]\n\t\t\t\t\t\t    && ma < xx[8]\n\t\t\t\t\t\t    + xx[2]\n\t\t\t\t\t\t    && mb + mnobib > xx[9]\n\t\t\t\t\t\t    + xx[1]\n\t\t\t\t\t\t    / 2 - xx[0]\n\t\t\t\t\t\t    && mb < xx[9]\n\t\t\t\t\t\t    + xx[2]\n\t\t\t\t\t\t    && mc >= 0) {\n\t\t\t\t\t\t    ma = xx[8] - mnobia;\n\t\t\t\t\t\t    mc = 0;\n\t\t\t\t\t\t    xx[16] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ma + mnobia >\n\t\t\t\t\t\t    xx[8] + xx[2]\n\t\t\t\t\t\t    && ma < xx[8]\n\t\t\t\t\t\t    + xx[1]\n\t\t\t\t\t\t    && mb + mnobib > xx[9]\n\t\t\t\t\t\t    + xx[1]\n\t\t\t\t\t\t    / 2 - xx[0]\n\t\t\t\t\t\t    && mb < xx[9]\n\t\t\t\t\t\t    + xx[2]\n\t\t\t\t\t\t    && mc <= 0) {\n\t\t\t\t\t\t    ma = xx[8] + xx[1];\n\t\t\t\t\t\t    mc = 0;\n\t\t\t\t\t\t    xx[16] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 800) {\n\t\t\tif (mb >\n\t\t\t    xx[9] - xx[0] * 2 - 2000\n\t\t\t    && mb <\n\t\t\t    xx[9] + xx[1] - xx[0] * 2 +\n\t\t\t    2000\n\t\t\t    && ma + mnobia > xx[8] - 400\n\t\t\t    && ma < xx[8] + xx[1]) {\n\t\t\t    ta[t] = -800000;\n\t\t\t    ot(oto[4]);\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 140) {\n\t\t\tif (mb >\n\t\t\t    xx[9] - xx[0] * 2 - 2000\n\t\t\t    && mb <\n\t\t\t    xx[9] + xx[1] - xx[0] * 2 +\n\t\t\t    2000\n\t\t\t    && ma + mnobia > xx[8] - 400\n\t\t\t    && ma < xx[8] + xx[1]) {\n\t\t\t    ta[t] = -800000;\n\t\t\t    sracttype[20] = 1;\n\t\t\t    sron[20] = 1;\n\t\t\t    Mix_HaltMusic();\n\t\t\t    mtype = 301;\n\t\t\t    mtm = 0;\n\t\t\t    ot(oto[16]);\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 100) {\n\t\t\tif (mb >\n\t\t\t    xx[9] - xx[0] * 2 - 2000\n\t\t\t    && mb <\n\t\t\t    xx[9] + xx[1] - xx[0] * 2 +\n\t\t\t    2000\n\t\t\t    && ma + mnobia > xx[8] - 400\n\t\t\t    && ma < xx[8] + xx[1]\n\t\t\t    && md <= 0) {\n\t\t\t    if (txtype[t] == 0)\n\t\t\t\ttb[t] = mb + fy - 1200 - xx[1];\n\t\t\t}\n\t\t\tif (txtype[t] == 1) {\n\t\t\t    if (xx[17] == 1) {\n\t\t\t\tif (ma +\n\t\t\t\t    mnobia >\n\t\t\t\t    xx[8] - 400\n\t\t\t\t    && ma < xx[8] + xx[1] / 2 - 1500) {\n\t\t\t\t    ta[t] += 3000;\n\t\t\t\t} else if (ma + mnobia >= xx[8]\n\t\t\t\t\t   + xx[1]\n\t\t\t\t\t   / 2 - 1500 && ma < xx[8]\n\t\t\t\t\t   + xx[1]) {\n\t\t\t\t    ta[t] -= 3000;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t\tif (xx[17] == 1 && txtype[t] == 0) {\n\t\t\t    ot(oto[4]);\n\t\t\t    eyobi(ta[t] + 10, tb[t],\n\t\t\t\t  0, -800, 0, 40, 3000, 3000, 0, 16);\n\t\t\t    ttype[t] = 3;\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 101) {\n\t\t\tif (xx[17] == 1) {\n\t\t\t    ot(oto[8]);\n\t\t\t    ttype[t] = 3;\n\t\t\t    abrocktm[aco] = 16;\n\t\t\t    if (txtype[t] == 0)\n\t\t\t\tayobi(ta[t], tb[t], 0, 0, 0, 0, 0);\n\t\t\t    if (txtype[t] == 1)\n\t\t\t\tayobi(ta[t], tb[t], 0, 0, 0, 4, 0);\n\t\t\t    if (txtype[t] == 3)\n\t\t\t\tayobi(ta[t], tb[t], 0, 0, 0, 101, 0);\n\t\t\t    if (txtype[t] == 4) {\n\t\t\t\tabrocktm[aco] = 20;\n\t\t\t\tayobi(ta[t] -\n\t\t\t\t      400, tb[t] - 1600, 0, 0, 0, 6, 0);\n\t\t\t    }\n\t\t\t    if (txtype[t] == 10)\n\t\t\t\tayobi(ta[t], tb[t], 0, 0, 0, 101, 0);\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 102) {\n\t\t\tif (xx[17] == 1) {\n\t\t\t    ot(oto[8]);\n\t\t\t    ttype[t] = 3;\n\t\t\t    abrocktm[aco] = 16;\n\t\t\t    if (txtype[t] == 0)\n\t\t\t\tayobi(ta[t], tb[t], 0, 0, 0, 100, 0);\n\t\t\t    if (txtype[t] == 2)\n\t\t\t\tayobi(ta[t], tb[t], 0, 0, 0, 100, 2);\n\t\t\t    if (txtype[t] == 3)\n\t\t\t\tayobi(ta[t], tb[t], 0, 0, 0, 102, 1);\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 103) {\n\t\t\tif (xx[17] == 1) {\n\t\t\t    ot(oto[8]);\n\t\t\t    ttype[t] = 3;\n\t\t\t    abrocktm[aco] = 16;\n\t\t\t    ayobi(ta[t], tb[t], 0, 0, 0, 100, 1);\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 104) {\n\t\t\tif (xx[17] == 1) {\n\t\t\t    ot(oto[8]);\n\t\t\t    ttype[t] = 3;\n\t\t\t    abrocktm[aco] = 16;\n\t\t\t    ayobi(ta[t], tb[t], 0, 0, 0, 110, 0);\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 110) {\n\t\t\tif (xx[17] == 1) {\n\t\t\t    ttype[t] = 111;\n\t\t\t    thp[t] = 999;\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 111 && ta[t] - fx >= 0) {\n\t\t\tthp[t]++;\n\t\t\tif (thp[t] >= 16) {\n\t\t\t    thp[t] = 0;\n\t\t\t    ot(oto[8]);\n\t\t\t    abrocktm[aco] = 16;\n\t\t\t    ayobi(ta[t], tb[t], 0, 0, 0, 102, 1);\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 112) {\n\t\t\tif (xx[17] == 1) {\n\t\t\t    ttype[t] = 113;\n\t\t\t    thp[t] = 999;\n\t\t\t    titem[t] = 0;\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 113 && ta[t] - fx >= 0) {\n\t\t\tif (titem[t] <= 19)\n\t\t\t    thp[t]++;\n\t\t\tif (thp[t] >= 3) {\n\t\t\t    thp[t] = 0;\n\t\t\t    titem[t]++;\n\t\t\t    ot(oto[4]);\n\t\t\t    eyobi(ta[t] + 10, tb[t],\n\t\t\t\t  0, -800, 0, 40, 3000, 3000, 0, 16);\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 114) {\n\t\t\tif (xx[17] == 1) {\n\t\t\t    if (txtype[t] == 0) {\n\t\t\t\tot(oto[8]);\n\t\t\t\tttype[t] = 3;\n\t\t\t\tabrocktm[aco] = 16;\n\t\t\t\tayobi(ta[t], tb[t], 0, 0, 0, 102, 1);\n\t\t\t    }\n\t\t\t    if (txtype[t] == 2) {\n\t\t\t\tot(oto[4]);\n\t\t\t\teyobi(ta[t] +\n\t\t\t\t      10, tb[t],\n\t\t\t\t      0, -800, 0, 40, 3000, 3000, 0, 16);\n\t\t\t\tttype[t] = 115;\n\t\t\t\ttxtype[t] = 0;\n\t\t\t    }\n\t\t\t    if (txtype[t] == 10) {\n\t\t\t\tif (stageonoff == 1) {\n\t\t\t\t    ttype[t]\n\t\t\t\t\t= 130;\n\t\t\t\t    stageonoff = 0;\n\t\t\t\t    ot(oto[13]);\n\t\t\t\t    txtype[t]\n\t\t\t\t\t= 2;\n\t\t\t\t    for (t = 0; t < amax; t++) {\n\t\t\t\t\tif (atype[t] == 87\n\t\t\t\t\t    || atype[t] == 88) {\n\t\t\t\t\t    if (axtype[t] == 105) {\n\t\t\t\t\t\taxtype[t]\n\t\t\t\t\t\t    = 110;\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t} else {\n\t\t\t\t    ot(oto[4]);\n\t\t\t\t    eyobi(ta[t]\n\t\t\t\t\t  +\n\t\t\t\t\t  10,\n\t\t\t\t\t  tb\n\t\t\t\t\t  [t],\n\t\t\t\t\t  0,\n\t\t\t\t\t  -800, 0, 40, 3000, 3000, 0, 16);\n\t\t\t\t    ttype[t]\n\t\t\t\t\t= 3;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 115) {\n\t\t    }\n\t\t    if (ttype[t] == 116) {\n\t\t\tif (xx[17] == 1) {\n\t\t\t    ot(oto[8]);\n\t\t\t    ttype[t] = 3;\n\t\t\t    tyobi(ta[t] / 100, (tb[t] / 100) - 29, 400);\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 124) {\n\t\t\tif (xx[17] == 1) {\n\t\t\t    ot(oto[13]);\n\t\t\t    for (t = 0; t < amax; t++) {\n\t\t\t\tif (atype[t] == 87 || atype[t]\n\t\t\t\t    == 88) {\n\t\t\t\t    if (axtype[t] == 101) {\n\t\t\t\t\taxtype[t]\n\t\t\t\t\t    = 120;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    ttype[t] = 3;\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 130) {\n\t\t\tif (xx[17] == 1) {\n\t\t\t    if (txtype[t] != 1) {\n\t\t\t\tstageonoff = 0;\n\t\t\t\tot(oto[13]);\n\t\t\t    }\n\t\t\t}\n\t\t    } else if (ttype[t] == 131) {\n\t\t\tif (xx[17] == 1 && txtype[t] != 2) {\n\t\t\t    stageonoff = 1;\n\t\t\t    ot(oto[13]);\n\t\t\t    if (txtype[t] == 1) {\n\t\t\t\tfor (t = 0; t < amax; t++) {\n\t\t\t\t    if (atype[t] == 87 || atype[t] == 88) {\n\t\t\t\t\tif (axtype[t] == 105) {\n\t\t\t\t\t    axtype[t]\n\t\t\t\t\t\t= 110;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tbxtype[3] = 105;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 300) {\n\t\t\tif (xx[17] == 1) {\n\t\t\t    ot(oto[15]);\n\t\t\t    if (txtype[t] <= 100) {\n\t\t\t\ttmsgtype = 1;\n\t\t\t\ttmsgtm = 15;\n\t\t\t\ttmsgy = 300 + (txtype[t] - 1);\n\t\t\t\ttmsg = (txtype[t]);\n\t\t\t    }\n\t\t\t    if (txtype[t] == 540) {\n\t\t\t\ttmsgtype = 1;\n\t\t\t\ttmsgtm = 15;\n\t\t\t\ttmsgy = 400;\n\t\t\t\ttmsg = 100;\n\t\t\t\ttxtype[t] = 541;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (ttype[t] == 301) {\n\t\t\tif (xx[17] == 1) {\n\t\t\t    ot(oto[3]);\n\t\t\t    eyobi(ta[t] + 1200,\n\t\t\t\t  tb[t] + 1200, 300,\n\t\t\t\t  -1000, 0, 160, 1000, 1000, 1, 120);\n\t\t\t    eyobi(ta[t] + 1200,\n\t\t\t\t  tb[t] + 1200,\n\t\t\t\t  -300, -1000, 0, 160, 1000, 1000, 1, 120);\n\t\t\t    eyobi(ta[t] + 1200,\n\t\t\t\t  tb[t] + 1200, 240,\n\t\t\t\t  -1400, 0, 160, 1000, 1000, 1, 120);\n\t\t\t    eyobi(ta[t] + 1200,\n\t\t\t\t  tb[t] + 1200,\n\t\t\t\t  -240, -1400, 0, 160, 1000, 1000, 1, 120);\n\t\t\t    brockbreak(t);\n\t\t\t}\n\t\t    }\n\t\t} else if (mtype == 1) {\n\t\t    if (ma + mnobia > xx[8]\n\t\t\t&& ma < xx[8] + xx[1]\n\t\t\t&& mb + mnobib > xx[9]\n\t\t\t&& mb < xx[9] + xx[1]) {\n\t\t\tot(oto[3]);\n\t\t\teyobi(ta[t] + 1200,\n\t\t\t      tb[t] + 1200, 300, -1000,\n\t\t\t      0, 160, 1000, 1000, 1, 120);\n\t\t\teyobi(ta[t] + 1200,\n\t\t\t      tb[t] + 1200, -300, -1000,\n\t\t\t      0, 160, 1000, 1000, 1, 120);\n\t\t\teyobi(ta[t] + 1200,\n\t\t\t      tb[t] + 1200, 240, -1400,\n\t\t\t      0, 160, 1000, 1000, 1, 120);\n\t\t\teyobi(ta[t] + 1200,\n\t\t\t      tb[t] + 1200, -240, -1400,\n\t\t\t      0, 160, 1000, 1000, 1, 120);\n\t\t\tbrockbreak(t);\n\t\t    }\n\t\t}\n\t\tif (ttype[t] == 130 && stageonoff == 0) {\n\t\t    ttype[t] = 131;\n\t\t}\n\t\tif (ttype[t] == 131 && stageonoff == 1) {\n\t\t    ttype[t] = 130;\n\t\t}\n\t\tif (ttype[t] == 300) {\n\t\t    if (txtype[t] >= 500 && ta[t] >= -6000) {\n\t\t\tif (txtype[t] <= 539)\n\t\t\t    txtype[t]++;\n\t\t\tif (txtype[t] >= 540) {\n\t\t\t    ta[t] -= 500;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tfor (t = 0; t < smax; t++) {\n\t    if (sa[t] - fx + sc[t] >= -12000 && sa[t] - fx <= fxmax) {\n\t\txx[0] = 200;\n\t\txx[1] = 2400;\n\t\txx[2] = 1000;\n\t\txx[7] = 0;\n\t\txx[8] = sa[t] - fx;\n\t\txx[9] = sb[t] - fy;\n\t\tif ((stype[t] <= 99 || stype[t] == 200)\n\t\t    && mtype < 10) {\n\t\t    if (stype[t] == 51) {\n\t\t\tif (ma + mnobia >\n\t\t\t    xx[8] + xx[0] + 3000\n\t\t\t    && ma < xx[8] + sc[t] - xx[0]\n\t\t\t    && mb + mnobib >\n\t\t\t    xx[9] + 3000 && sgtype[t] == 0) {\n\t\t\t    if (sxtype[t] == 0) {\n\t\t\t\tsgtype[t] = 1;\n\t\t\t\tsr[t] = 0;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (ma + mnobia >\n\t\t\t    xx[8] + xx[0] + 1000\n\t\t\t    && ma < xx[8] + sc[t] - xx[0]\n\t\t\t    && mb + mnobib >\n\t\t\t    xx[9] + 3000 && sgtype[t] == 0) {\n\t\t\t    if ((sxtype[t] == 10)\n\t\t\t\t&& sgtype[t] == 0) {\n\t\t\t\tsgtype[t] = 1;\n\t\t\t\tsr[t] = 0;\n\t\t\t    }\n\t\t\t}\n\t\t\tif ((sxtype[t] == 1)\n\t\t\t    && sb[27] >= 25000\n\t\t\t    && sa[27] > ma + mnobia\n\t\t\t    && t != 27 && sgtype[t] == 0) {\n\t\t\t    sgtype[t] = 1;\n\t\t\t    sr[t] = 0;\n\t\t\t}\n\t\t\tif (sxtype[t] == 2\n\t\t\t    && sb[28] >= 48000\n\t\t\t    && t != 28 && sgtype[t] == 0 && mhp >= 1) {\n\t\t\t    sgtype[t] = 1;\n\t\t\t    sr[t] = 0;\n\t\t\t}\n\t\t\tif ((sxtype[t] == 3\n\t\t\t     && mb >= 30000\n\t\t\t     || sxtype[t] == 4 && mb >= 25000)\n\t\t\t    && sgtype[t] == 0\n\t\t\t    && mhp >= 1\n\t\t\t    && ma + mnobia >\n\t\t\t    xx[8] + xx[0] + 3000 - 300\n\t\t\t    && ma < xx[8] + sc[t] - xx[0]) {\n\t\t\t    sgtype[t] = 1;\n\t\t\t    sr[t] = 0;\n\t\t\t    if (sxtype[t] == 4)\n\t\t\t\tsr[t] = 100;\n\t\t\t}\n\t\t\tif (sgtype[t] == 1 && sb[t] <= fymax + 18000) {\n\t\t\t    sr[t] += 120;\n\t\t\t    if (sr[t] >= 1600) {\n\t\t\t\tsr[t] = 1600;\n\t\t\t    }\n\t\t\t    sb[t] += sr[t];\n\t\t\t    if (ma + mnobia > xx[8] + xx[0]\n\t\t\t\t&& ma < xx[8] + sc[t] - xx[0]\n\t\t\t\t&& mb + mnobib > xx[9]\n\t\t\t\t&& mb < xx[9] + sd[t] + xx[0]) {\n\t\t\t\tmhp--;\n\t\t\t\txx[7] = 1;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (stype[t] == 52) {\n\t\t\tif (sgtype[t] == 0\n\t\t\t    && ma + mnobia >\n\t\t\t    xx[8] + xx[0] + 2000\n\t\t\t    && ma <\n\t\t\t    xx[8] + sc[t] - xx[0] - 2500\n\t\t\t    && mb + mnobib > xx[9] - 3000) {\n\t\t\t    sgtype[t] = 1;\n\t\t\t    sr[t] = 0;\n\t\t\t}\n\t\t\tif (sgtype[t] == 1) {\n\t\t\t    sr[t] += 120;\n\t\t\t    if (sr[t] >= 1600) {\n\t\t\t\tsr[t] = 1600;\n\t\t\t    }\n\t\t\t    sb[t] += sr[t];\n\t\t\t}\n\t\t    }\n\t\t    if (xx[7] == 0) {\n\t\t\tif (ma + mnobia > xx[8] + xx[0]\n\t\t\t    && ma < xx[8] + sc[t] - xx[0]\n\t\t\t    && mb + mnobib > xx[9]\n\t\t\t    && mb + mnobib < xx[9] + xx[1]\n\t\t\t    && md >= -100) {\n\t\t\t    mb = sb[t] - fy - mnobib + 100;\n\t\t\t    md = 0;\n\t\t\t    mzimen = 1;\n\t\t\t}\n\t\t\tif (ma + mnobia > xx[8] - xx[0]\n\t\t\t    && ma < xx[8] + xx[2]\n\t\t\t    && mb + mnobib >\n\t\t\t    xx[9] + xx[1] * 3 / 4\n\t\t\t    && mb < xx[9] + sd[t] - xx[2]) {\n\t\t\t    ma = xx[8] - xx[0] - mnobia;\n\t\t\t    mc = 0;\n\t\t\t}\n\t\t\tif (ma + mnobia > xx[8] + sc[t] - xx[0]\n\t\t\t    && ma < xx[8] + sc[t] + xx[0]\n\t\t\t    && mb + mnobib >\n\t\t\t    xx[9] + xx[1] * 3 / 4\n\t\t\t    && mb < xx[9] + sd[t] - xx[2]) {\n\t\t\t    ma = xx[8] + sc[t] + xx[0];\n\t\t\t    mc = 0;\n\t\t\t}\n\t\t\tif (ma + mnobia >\n\t\t\t    xx[8] + xx[0] * 2\n\t\t\t    && ma <\n\t\t\t    xx[8] + sc[t] - xx[0] * 2\n\t\t\t    && mb > xx[9] + sd[t] - xx[1]\n\t\t\t    && mb < xx[9] + sd[t] + xx[0]) {\n\t\t\t    mb = xx[9] + sd[t] + xx[0];\n\t\t\t    if (md < 0) {\n\t\t\t\tmd = -md * 2 / 3;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (stype[t] == 50) {\n\t\t\tif (ma + mnobia > xx[8] + 2800\n\t\t\t    && ma < xx[8] + sc[t] - 3000\n\t\t\t    && mb + mnobib >\n\t\t\t    xx[9] - 1000\n\t\t\t    && mb + mnobib <\n\t\t\t    xx[9] + xx[1] + 3000\n\t\t\t    && mzimen == 1\n\t\t\t    && actaon[3] == 1 && mtype == 0) {\n\t\t\t    if (sxtype[t] == 0) {\n\t\t\t\tmtype = 100;\n\t\t\t\tmtm = 0;\n\t\t\t\tot(oto[7]);\n\t\t\t\tmxtype = 0;\n\t\t\t    }\n\t\t\t    if (sxtype[t] == 1) {\n\t\t\t\tmtype = 100;\n\t\t\t\tmtm = 0;\n\t\t\t\tot(oto[7]);\n\t\t\t\tmxtype = 1;\n\t\t\t    }\n\t\t\t    if (sxtype[t] == 2) {\n\t\t\t\tmtype = 100;\n\t\t\t\tmtm = 0;\n\t\t\t\tot(oto[7]);\n\t\t\t\tmxtype = 2;\n\t\t\t    }\n\t\t\t    if (sxtype[t] == 5) {\n\t\t\t\tmtype = 100;\n\t\t\t\tmtm = 0;\n\t\t\t\tot(oto[7]);\n\t\t\t\tmxtype = 5;\n\t\t\t    }\n\t\t\t    if (sxtype[t] == 6) {\n\t\t\t\tmtype = 100;\n\t\t\t\tmtm = 0;\n\t\t\t\tot(oto[7]);\n\t\t\t\tmxtype = 6;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (stype[t] == 40) {\n\t\t\tif (ma + mnobia > xx[8] - 300 && ma < xx[8] + sc[t] - 1000 && mb > xx[9] + 1000 && mb + mnobib < xx[9] + xx[1] + 4000 && mzimen == 1 && actaon[4] == 1 && mtype == 0) {\n\t\t\t    if (sxtype[t] == 0) {\n\t\t\t\tmtype = 500;\n\t\t\t\tmtm = 0;\n\t\t\t\tot(oto[7]);\n\t\t\t\tmtype = 100;\n\t\t\t\tmxtype = 10;\n\t\t\t    }\n\t\t\t    if (sxtype[t] == 2) {\n\t\t\t\tmxtype = 3;\n\t\t\t\tmtm = 0;\n\t\t\t\tot(oto[7]);\n\t\t\t\tmtype = 100;\n\t\t\t    }\n\t\t\t    if (sxtype[t] == 6) {\n\t\t\t\tmtype = 3;\n\t\t\t\tmtm = 0;\n\t\t\t\tot(oto[7]);\n\t\t\t\tmxtype = 6;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    if (ma + mnobia > xx[8] + xx[0]\n\t\t\t&& ma < xx[8] + sc[t] - xx[0]\n\t\t\t&& mb + mnobib > xx[9]\n\t\t\t&& mb < xx[9] + sd[t] + xx[0]) {\n\t\t\tif (stype[t] == 100) {\n\t\t\t    if (sxtype[t] == 0\n\t\t\t\t|| sxtype[t] == 1 && ttype[1] != 3) {\n\t\t\t\tayobi(sa[t] + 1000, 32000, 0, 0, 0, 3, 0);\n\t\t\t\tsa[t] = -800000000;\n\t\t\t\tot(oto[10]);\n\t\t\t    }\n\t\t\t}\n\t\t\tif (stype[t] == 101) {\n\t\t\t    ayobi(sa[t] + 6000, -4000, 0, 0, 0, 3, 1);\n\t\t\t    sa[t] = -800000000;\n\t\t\t    ot(oto[10]);\n\t\t\t}\n\t\t\tif (stype[t] == 102) {\n\t\t\t    if (sxtype[t] == 0) {\n\t\t\t\tfor (t3 = 0; t3 <= 3; t3++) {\n\t\t\t\t    ayobi(sa[t]\n\t\t\t\t\t  +\n\t\t\t\t\t  t3 * 3000, -3000, 0, 0, 0, 0, 0);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    if (sxtype[t] == 1 && mb >= 16000) {\n\t\t\t\tayobi(sa[t] +\n\t\t\t\t      1500, 44000, 0, -2000, 0, 4, 0);\n\t\t\t    } else if (sxtype[t] == 2) {\n\t\t\t\tayobi(sa[t] +\n\t\t\t\t      4500, 30000, 0, -1600, 0, 5, 0);\n\t\t\t\tot(oto[10]);\n\t\t\t\tsxtype[t] = 3;\n\t\t\t\tsa[t] -= 12000;\n\t\t\t    } else if (sxtype[t] == 3) {\n\t\t\t\tsa[t] += 12000;\n\t\t\t\tsxtype[t] = 4;\n\t\t\t    } else if (sxtype[t] == 4) {\n\t\t\t\tayobi(sa[t] +\n\t\t\t\t      4500, 30000, 0, -1600, 0, 5, 0);\n\t\t\t\tot(oto[10]);\n\t\t\t\tsxtype[t] = 5;\n\t\t\t\tsxtype[t] = 0;\n\t\t\t    }\n\t\t\t    else if (sxtype[t] == 7) {\n\t\t\t\tmainmsgtype = 1;\n\t\t\t    } else if (sxtype[t] == 8) {\n\t\t\t\tayobi(sa[t] -\n\t\t\t\t      5000 -\n\t\t\t\t      3000 * 1, 26000, 0, -1600, 0, 5, 0);\n\t\t\t\tot(oto[10]);\n\t\t\t    } else if (sxtype[t] == 9) {\n\t\t\t\tfor (t3 = 0; t3 <= 2; t3++) {\n\t\t\t\t    ayobi(sa[t]\n\t\t\t\t\t  +\n\t\t\t\t\t  t3\n\t\t\t\t\t  *\n\t\t\t\t\t  3000\n\t\t\t\t\t  +\n\t\t\t\t\t  3000, 48000, 0, -6000, 0, 3, 0);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    if (sxtype[t] == 10) {\n\t\t\t\tsa[t] -= 5 * 30 * 100;\n\t\t\t\tstype[t] = 101;\n\t\t\t    }\n\t\t\t    if (sxtype[t] == 12) {\n\t\t\t\tfor (t3 = 1; t3 <= 3; t3++) {\n\t\t\t\t    ayobi(sa[t]\n\t\t\t\t\t  +\n\t\t\t\t\t  t3\n\t\t\t\t\t  *\n\t\t\t\t\t  3000\n\t\t\t\t\t  -\n\t\t\t\t\t  1000, 40000, 0, -2600, 0, 9, 0);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    if (sxtype[t] == 20) {\n\t\t\t\tscrollx = 0;\n\t\t\t    }\n\t\t\t    if (sxtype[t] == 30) {\n\t\t\t\tsa[t] = -80000000;\n\t\t\t\tmd = 0;\n\t\t\t\tMix_HaltMusic();\n\t\t\t\tmtype = 302;\n\t\t\t\tmtm = 0;\n\t\t\t\tot(oto[16]);\n\t\t\t    }\n\t\t\t    if (sxtype[t] != 3\n\t\t\t\t&& sxtype[t] != 4 && sxtype[t] != 10) {\n\t\t\t\tsa[t] = -800000000;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (stype[t] == 103) {\n\t\t\t    if (sxtype[t] == 0) {\n\t\t\t\tamsgtm[aco] = 10;\n\t\t\t\tamsgtype[aco] = 50;\n\t\t\t\tayobi(sa[t] +\n\t\t\t\t      9000, sb[t] + 2000, 0, 0, 0, 79, 0);\n\t\t\t\tsa[t] = -800000000;\n\t\t\t    }\n\t\t\t    if (sxtype[t] == 1 && ttype[6] <= 6) {\n\t\t\t\tamsgtm[aco] = 10;\n\t\t\t\tamsgtype[aco] = 50;\n\t\t\t\tayobi(sa[t] -\n\t\t\t\t      12000, sb[t] + 2000, 0, 0, 0, 79, 0);\n\t\t\t\tsa[t] = -800000000;\n\t\t\t\ttxtype[9] = 500;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (stype[t] == 104) {\n\t\t\t    if (sxtype[t] == 0) {\n\t\t\t\tayobi(sa[t] +\n\t\t\t\t      12000,\n\t\t\t\t      sb[t] + 2000 + 3000, 0, 0, 0, 79, 0);\n\t\t\t\tayobi(sa[t] +\n\t\t\t\t      12000,\n\t\t\t\t      sb[t] + 2000 + 3000, 0, 0, 0, 79, 1);\n\t\t\t\tayobi(sa[t] +\n\t\t\t\t      12000,\n\t\t\t\t      sb[t] + 2000 + 3000, 0, 0, 0, 79, 2);\n\t\t\t\tayobi(sa[t] +\n\t\t\t\t      12000,\n\t\t\t\t      sb[t] + 2000 + 3000, 0, 0, 0, 79, 3);\n\t\t\t\tayobi(sa[t] +\n\t\t\t\t      12000,\n\t\t\t\t      sb[t] + 2000 + 3000, 0, 0, 0, 79, 4);\n\t\t\t\tsa[t] = -800000000;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (stype[t] == 105 && mzimen == 0 && md >= 0) {\n\t\t\t    ta[1] -= 1000;\n\t\t\t    ta[2] += 1000;\n\t\t\t    sxtype[t]++;\n\t\t\t    if (sxtype[t] >= 3)\n\t\t\t\tsa[t] = -8000000;\n\t\t\t}\n\t\t\tif (stype[t] == 300\n\t\t\t    && mtype == 0\n\t\t\t    && mb <\n\t\t\t    xx[9] + sd[t] + xx[0] - 3000 && mhp >= 1) {\n\t\t\t    Mix_HaltMusic();\n\t\t\t    mtype = 300;\n\t\t\t    mtm = 0;\n\t\t\t    ma = sa[t] - fx - 2000;\n\t\t\t    ot(oto[11]);\n\t\t\t}\n\t\t\tif (stype[t] == 500 && mtype == 0 && mhp >= 1) {\n\t\t\t    tyuukan += 1;\n\t\t\t    sa[t] = -80000000;\n\t\t\t}\n\t\t    }\n\t\t    if (stype[t] == 180) {\n\t\t\tsr[t]++;\n\t\t\tif (sr[t] >= sgtype[t]) {\n\t\t\t    sr[t] = 0;\n\t\t\t    ayobi(sa[t], 30000,\n\t\t\t\t  rand(600) - 300,\n\t\t\t\t  -1600 - rand(900), 0, 84, 0);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tactaon[0] = 0;\n\tactaon[4] = 0;\n\tfor (t = 0; t < srmax; t++) {\n\t    xx[10] = sra[t];\n\t    xx[11] = srb[t];\n\t    xx[12] = src[t];\n\t    xx[13] = srd[t];\n\t    xx[8] = xx[10] - fx;\n\t    xx[9] = xx[11] - fy;\n\t    if (xx[8] + xx[12] >= -10 - 12000 && xx[8] <= fxmax + 12100) {\n\t\txx[0] = 500;\n\t\txx[1] = 1200;\n\t\txx[2] = 1000;\n\t\txx[7] = 2000;\n\t\tif (md >= 100) {\n\t\t    xx[1] = 900 + md;\n\t\t}\n\t\tif (md > xx[1])\n\t\t    xx[1] = md + 100;\n\t\tsrb[t] += sre[t];\n\t\tsre[t] += srf[t];\n\t\tswitch (sracttype[t]) {\n\t\tcase 1:\n\t\t    if (sron[t] == 1)\n\t\t\tsrf[t] = 60;\n\t\t    break;\n\t\tcase 2:\n/*\nif (sra[t]<=srmovep[t]-srmove[t])srmuki[t]=1;\nif (sra[t]>=srmovep[t]+srmove[t])srmuki[t]=0;\n*/\n\t\t    break;\n\t\tcase 3:\n/*\nif (srb[t]<=srmovep[t]-srmove[t])srmuki[t]=1;\nif (srb[t]>=srmovep[t]+srmove[t])srmuki[t]=0;\n*/\n\t\t    break;\n/*\ncase 4:\nif (srmove[t]==0){srmuki[t]=0;}else{srmuki[t]=1;}\nif (sra[t]-fx<-1100-src[t]){sra[t]=fymax+fx+scrollx;}\nif (sra[t]-fx>24000+scrollx){sra[t]=-1100-src[t]+fx;}\nbreak;\n*/\n\t\tcase 5:\n\t\t    if (srmove[t] == 0) {\n\t\t\tsrmuki[t] = 0;\n\t\t    } else {\n\t\t\tsrmuki[t] = 1;\n\t\t    }\n\t\t    if (srb[t] - fy < -2100) {\n\t\t\tsrb[t] = fymax + fy + scrolly + 2000;\n\t\t    }\n\t\t    if (srb[t] - fy > fymax + scrolly + 2000) {\n\t\t\tsrb[t] = -2100 + fy;\n\t\t    }\n\t\t    break;\n\t\tcase 6:\n\t\t    if (sron[t] == 1)\n\t\t\tsrf[t] = 40;\n\t\t    break;\n\t\tcase 7:\n\t\t    break;\n\t\t}\n\t\tif (!(mztm >= 1 && mztype == 1 && actaon[3] == 1)\n\t\t    && mhp >= 1) {\n\t\t    if (ma + mnobia > xx[8] + xx[0]\n\t\t\t&& ma < xx[8] + xx[12] - xx[0]\n\t\t\t&& mb + mnobib > xx[9]\n\t\t\t&& mb + mnobib < xx[9] + xx[1]\n\t\t\t&& md >= -100) {\n\t\t\tmb = xx[9] - mnobib + 100;\n\t\t\tif (srtype[t] == 1) {\n\t\t\t    sre[10] = 900;\n\t\t\t    sre[11] = 900;\n\t\t\t}\n\t\t\tif (srsp[t] != 12) {\n\t\t\t    mzimen = 1;\n\t\t\t    md = 0;\n\t\t\t} else {\n\t\t\t    md = -800;\n\t\t\t}\n/*\nmd=0;\nif ((sracttype[t]==1 || sracttype[t]==6) && sron[t]==1)mb+=sre[t];\nif (sracttype[t]==2 || sracttype[t]==4){\nif (srmuki[t]==0)ma-=srsok[t];\nif (srmuki[t]==1)ma+=srsok[t];\n}\n*/\n\t\t\tif ((sracttype[t] == 1)\n\t\t\t    && sron[t] == 0)\n\t\t\t    sron[t] = 1;\n\t\t\tif (sracttype[t] == 1\n\t\t\t    && sron[t] == 1\n\t\t\t    || sracttype[t] == 3 || sracttype[t] == 5) {\n\t\t\t    mb += sre[t];\n\t\t\t}\n\t\t\tif (sracttype[t] == 7) {\n\t\t\t    if (actaon[2] != 1) {\n\t\t\t\tmd = -600;\n\t\t\t\tmb -= 810;\n\t\t\t    }\n\t\t\t    if (actaon[2] == 1) {\n\t\t\t\tmb -= 400;\n\t\t\t\tmd = -1400;\n\t\t\t\tmjumptm = 10;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (srsp[t] == 1) {\n\t\t\t    ot(oto[3]);\n\t\t\t    eyobi(sra[t] + 200,\n\t\t\t\t  srb[t] - 1000,\n\t\t\t\t  -240, -1400, 0, 160, 4500, 4500, 2, 120);\n\t\t\t    eyobi(sra[t] + 4500 -\n\t\t\t\t  200,\n\t\t\t\t  srb[t] - 1000,\n\t\t\t\t  240, -1400, 0, 160, 4500, 4500, 3, 120);\n\t\t\t    sra[t] = -70000000;\n\t\t\t}\n\t\t\tif (srsp[t] == 2) {\n\t\t\t    mc = -2400;\n\t\t\t    srmove[t] += 1;\n\t\t\t    if (srmove[t] >= 100) {\n\t\t\t\tmhp = 0;\n\t\t\t\tmmsgtype = 53;\n\t\t\t\tmmsgtm = 30;\n\t\t\t\tsrmove[t] = -5000;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (srsp[t] == 3) {\n\t\t\t    mc = 2400;\n\t\t\t    srmove[t] += 1;\n\t\t\t    if (srmove[t] >= 100) {\n\t\t\t\tmhp = 0;\n\t\t\t\tmmsgtype = 53;\n\t\t\t\tmmsgtm = 30;\n\t\t\t\tsrmove[t] = -5000;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if ((srsp[t] == 2 || srsp[t] == 3)\n\t\t\t&& mc != -2400 && srmove[t] > 0) {\n\t\t\tsrmove[t]--;\n\t\t    }\n\t\t    if (srsp[t] == 11) {\n\t\t\tif (ma + mnobia >\n\t\t\t    xx[8] + xx[0] - 2000\n\t\t\t    && ma < xx[8] + xx[12] - xx[0]) {\n\t\t\t    sron[t] = 1;\n\t\t\t}\n\t\t\tif (sron[t] == 1) {\n\t\t\t    srf[t] = 60;\n\t\t\t    srb[t] += sre[t];\n\t\t\t}\n\t\t    }\n\t\t    if (ma + mnobia > xx[8] + xx[0]\n\t\t\t&& ma < xx[8] + xx[12] - xx[0]\n\t\t\t&& mb > xx[9] - xx[1] / 2\n\t\t\t&& mb < xx[9] + xx[1] / 2) {\n\t\t\tif (srtype[t] == 2) {\n\t\t\t    if (md < 0) {\n\t\t\t\tmd = -md;\n\t\t\t    }\n\t\t\t    mb += 110;\n\t\t\t    if (mmutekitm <= 0)\n\t\t\t\tmhp -= 1;\n\t\t\t    if (mmutekion != 1)\n\t\t\t\tmmutekitm = 40;\n\t\t\t}\n\t\t    }\n\t\t    if (sracttype[t] == 6) {\n\t\t\tif (ma + mnobia > xx[8] + xx[0]\n\t\t\t    && ma < xx[8] + xx[12] - xx[0]) {\n\t\t\t    sron[t] = 1;\n\t\t\t}\n\t\t    }\n\t\t}\n/*\nif (sracttype[t]==7){\nif (ma+mnobia>xx[8]+xx[0] && ma<xx[8]+xx[12]-xx[0] && mb+mnobib>xx[9]+xx[1]/2 && mb+mnobib<xx[9]+xx[1]*3/2 && md>=-100){\nif (actaon[2]!=1){md=-600;mb-=810;}\nif (actaon[2]==1){mb-=400;md=-1400;mjumptm=10;}\n}}\n*/\n\t\tif (sracttype[t] == 2 || sracttype[t] == 4) {\n\t\t    if (srmuki[t] == 0)\n\t\t\tsra[t] -= srsok[t];\n\t\t    if (srmuki[t] == 1)\n\t\t\tsra[t] += srsok[t];\n\t\t}\n\t\tif (sracttype[t] == 3 || sracttype[t] == 5) {\n\t\t    if (srmuki[t] == 0)\n\t\t\tsrb[t] -= srsok[t];\n\t\t    if (srmuki[t] == 1)\n\t\t\tsrb[t] += srsok[t];\n\t\t}\n\t\tfor (tt = 0; tt < amax; tt++) {\n\t\t    if (azimentype[tt] == 1) {\n\t\t\tif (aa[tt] + anobia[tt] - fx > xx[8] + xx[0]\n\t\t\t    && aa[tt] - fx < xx[8] + xx[12] - xx[0]\n\t\t\t    && ab[tt] + anobib[tt] >\n\t\t\t    xx[11] - 100\n\t\t\t    && ab[tt] + anobib[tt] <\n\t\t\t    xx[11] + xx[1] + 500 && ad[tt] >= -100) {\n\t\t\t    ab[tt] = xx[9] - anobib[tt] + 100;\n\t\t\t    ad[tt] = 0;\n\t\t\t    axzimen[tt] = 1;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tfor (t = 0; t < emax; t++) {\n\t    xx[0] = ea[t] - fx;\n\t    xx[1] = eb[t] - fy;\n\t    xx[2] = enobia[t] / 100;\n\t    xx[3] = enobib[t] / 100;\n\t    if (etm[t] >= 0)\n\t\tetm[t]--;\n\t    if (xx[0] + xx[2] * 100 >= -10 && xx[1] <= fxmax\n\t\t&& xx[1] + xx[3] * 100 >= -10 - 8000\n\t\t&& xx[3] <= fymax && etm[t] >= 0) {\n\t\tea[t] += ec[t];\n\t\teb[t] += ed[t];\n\t\tec[t] += ee[t];\n\t\ted[t] += ef[t];\n\t    } else {\n\t\tea[t] = -9000000;\n\t    }\n\t}\n\tfor (t = 0; t < bmax; t++) {\n\t    if (ba[t] >= -80000) {\n\t\tif (btm[t] >= 0) {\n\t\t    btm[t] = btm[t] - 1;\n\t\t}\n\t\tfor (tt = 0; tt <= 1; tt++) {\n\t\t    xx[0] = 0;\n\t\t    xx[1] = 0;\n\t\t    if (bz[t] == 0 && btm[t] < 0\n\t\t\t&& ba[t] - fx >= fxmax + 2000\n\t\t\t&& ba[t] - fx < fxmax + 2000 + mc && tt == 0) {\n\t\t\txx[0] = 1;\n\t\t\tamuki[aco] = 0;\n\t\t    }\n\t\t    if (bz[t] == 0 && btm[t] < 0\n\t\t\t&& ba[t] - fx >=\n\t\t\t-400 - anx[btype[t]] + mc\n\t\t\t&& ba[t] - fx < -400 - anx[btype[t]]\n\t\t\t&& tt == 1) {\n\t\t\txx[0] = 1;\n\t\t\txx[1] = 1;\n\t\t\tamuki[aco] = 1;\n\t\t    }\n\t\t    if (bz[t] == 1 && ba[t] - fx >= 0 - anx[btype[t]]\n\t\t\t&& ba[t] - fx <= fxmax + 4000\n\t\t\t&& bb[t] - fy >= -9000\n\t\t\t&& bb[t] - fy <= fymax + 4000 && btm[t] < 0) {\n\t\t\txx[0] = 1;\n\t\t\tbz[t] = 0;\n\t\t    }\n\t\t    if (xx[0] == 1) {\n\t\t\tbtm[t] = 401;\n\t\t\txx[0] = 0;\n\t\t\tif (btype[t] >= 10) {\n\t\t\t    btm[t] = 9999999;\n\t\t\t}\n\t\t\tayobi(ba[t], bb[t], 0, 0, 0, btype[t], bxtype[t]);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tfor (t = 0; t < amax; t++) {\n\t    xx[0] = aa[t] - fx;\n\t    xx[1] = ab[t] - fy;\n\t    xx[2] = anobia[t];\n\t    xx[3] = anobib[t];\n\t    xx[14] = 12000 * 1;\n\t    if (anotm[t] >= 0)\n\t\tanotm[t]--;\n\t    if (xx[0] + xx[2] >= -xx[14] && xx[0] <= fxmax + xx[14]\n\t\t&& xx[1] + xx[3] >= -10 - 9000 && xx[1] <= fymax + 20000) {\n\t\taacta[t] = 0;\n\t\taactb[t] = 0;\n\t\txx[10] = 0;\n\t\tswitch (atype[t]) {\n\t\tcase 0:\n\t\t    xx[10] = 100;\n\t\t    break;\n\t\tcase 1:\n\t\t    xx[10] = 100;\n\t\t    break;\n\t\tcase 2:\n\t\t    xx[10] = 0;\n\t\t    xx[17] = 800;\n\t\t    if (axtype[t] >= 1)\n\t\t\txx[10] = xx[17];\n\t\t    if (axtype[t] >= 1) {\n\t\t\tfor (tt = 0; tt < amax; tt++) {\n\t\t\t    xx[0] = 250;\n\t\t\t    xx[5] = -800;\n\t\t\t    xx[12] = 0;\n\t\t\t    xx[1] = 1600;\n\t\t\t    xx[8] = aa[tt] - fx;\n\t\t\t    xx[9] = ab[tt] - fy;\n\t\t\t    if (t != tt) {\n\t\t\t\tif (aa[t] +\n\t\t\t\t    anobia[t] -\n\t\t\t\t    fx >\n\t\t\t\t    xx[8] +\n\t\t\t\t    xx[0] * 2\n\t\t\t\t    && aa[t] -\n\t\t\t\t    fx <\n\t\t\t\t    xx[8] +\n\t\t\t\t    anobia[tt] -\n\t\t\t\t    xx[0] * 2\n\t\t\t\t    && ab[t] +\n\t\t\t\t    anobib[t] - fy > xx[9] + xx[5]\n\t\t\t\t    && ab[t] +\n\t\t\t\t    anobib[t] -\n\t\t\t\t    fy <\n\t\t\t\t    xx[9] + xx[1] * 3 + xx[12] + 1500) {\n\t\t\t\t    aa[tt] = -800000;\n\t\t\t\t    ot(oto[6]);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\tcase 3:\n\t\t    azimentype[t] = 0;\n\t\t    if (axtype[t] == 0) {\n\t\t\tab[t] -= 800;\n\t\t    }\n\t\t    if (axtype[t] == 1)\n\t\t\tab[t] += 1200;\n\t\t    break;\n\t\tcase 4:\n\t\t    xx[10] = 120;\n\t\t    xx[0] = 250;\n\t\t    xx[8] = aa[t] - fx;\n\t\t    xx[9] = ab[t] - fy;\n\t\t    if (atm[t] >= 0)\n\t\t\tatm[t]--;\n\t\t    if (abs(ma + mnobia - xx[8] - xx[0] * 2)\n\t\t\t< 9000\n\t\t\t&& abs(ma <\n\t\t\t       xx[8] - anobia[t] +\n\t\t\t       xx[0] * 2) < 3000\n\t\t\t&& md <= -600 && atm[t] <= 0) {\n\t\t\tif (axtype[t] == 1\n\t\t\t    && mzimen == 0 && axzimen[t] == 1) {\n\t\t\t    ad[t] = -1600;\n\t\t\t    atm[t] = 40;\n\t\t\t    ab[t] -= 1000;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\tcase 5:\n\t\t    xx[10] = 160;\n\t\t    break;\n\t\tcase 6:\n\t\t    if (azimentype[t] == 30) {\n\t\t\tad[t] = -1600;\n\t\t\tab[t] += ad[t];\n\t\t    }\n\t\t    xx[10] = 120;\n\t\t    if (atm[t] >= 10) {\n\t\t\tatm[t]++;\n\t\t\tif (mhp >= 1) {\n\t\t\t    if (atm[t] <= 19) {\n\t\t\t\tma = xx[0];\n\t\t\t\tmb = xx[1] - 3000;\n\t\t\t\tmtype = 0;\n\t\t\t    }\n\t\t\t    xx[10] = 0;\n\t\t\t    if (atm[t] == 20) {\n\t\t\t\tmc = 700;\n\t\t\t\tmkeytm = 24;\n\t\t\t\tmd = -1200;\n\t\t\t\tmb = xx[1] - 1000 - 3000;\n\t\t\t\tamuki[t] = 1;\n\t\t\t\tif (axtype[t] == 1) {\n\t\t\t\t    mc = 840;\n\t\t\t\t    axtype[t]\n\t\t\t\t\t= 0;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    if (atm[t] == 40) {\n\t\t\t\tamuki[t] = 0;\n\t\t\t\tatm[t] = 0;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (axtype[t] == 1) {\n\t\t\tfor (tt = 0; tt < smax; tt++) {\n\t\t\t    if (stype[tt] == 300) {\n\t\t\t\tif (aa[t] -\n\t\t\t\t    fx >= -8000\n\t\t\t\t    && aa[t] >=\n\t\t\t\t    sa[tt] +\n\t\t\t\t    2000\n\t\t\t\t    && aa[t] <= sa[tt] + 3600 && axzimen[t]\n\t\t\t\t    == 1) {\n\t\t\t\t    sa[tt] = -800000;\n\t\t\t\t    atm[t] = 100;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t\tif (atm[t] == 100) {\n\t\t\t    eyobi(aa[t] + 1200 -\n\t\t\t\t  1200,\n\t\t\t\t  ab[t] + 3000 -\n\t\t\t\t  10 * 3000 - 1500,\n\t\t\t\t  0, 0, 0, 0, 1000,\n\t\t\t\t  10 * 3000 - 1200, 4, 20);\n\t\t\t    if (mtype == 300) {\n\t\t\t\tmtype = 0;\n\t\t\t\tStopSoundMem(oto[11]);\n\t\t\t\tbgmchange(otom[1]);\n\t\t\t    }\n\t\t\t    for (t1 = 0; t1 < smax; t1++) {\n\t\t\t\tif (stype[t1] == 104)\n\t\t\t\t    sa[t1] = -80000000;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (atm[t] == 120) {\n\t\t\t    eyobi(aa[t] + 1200 -\n\t\t\t\t  1200,\n\t\t\t\t  ab[t] + 3000 -\n\t\t\t\t  10 * 3000 - 1500,\n\t\t\t\t  600, -1200, 0,\n\t\t\t\t  160, 1000, 10 * 3000 - 1200, 4, 240);\n\t\t\t    amuki[t] = 1;\n\t\t\t}\n\t\t\tif (atm[t] == 140) {\n\t\t\t    amuki[t] = 0;\n\t\t\t    atm[t] = 0;\n\t\t\t}\n\t\t    }\n\t\t    if (atm[t] >= 220) {\n\t\t\tatm[t] = 0;\n\t\t\tamuki[t] = 0;\n\t\t    }\n\t\t    for (tt = 0; tt < amax; tt++) {\n\t\t\txx[0] = 250;\n\t\t\txx[5] = -800;\n\t\t\txx[12] = 0;\n\t\t\txx[1] = 1600;\n\t\t\txx[8] = aa[tt] - fx;\n\t\t\txx[9] = ab[tt] - fy;\n\t\t\tif (t != tt && atype[tt] >= 100) {\n\t\t\t    if (aa[t] + anobia[t] -\n\t\t\t\tfx >\n\t\t\t\txx[8] + xx[0] * 2\n\t\t\t\t&& aa[t] - fx <\n\t\t\t\txx[8] + anobia[tt] -\n\t\t\t\txx[0] * 2\n\t\t\t\t&& ab[t] + anobib[t] - fy > xx[9] + xx[5]\n\t\t\t\t&& ab[t] +\n\t\t\t\tanobib[t] - fy <\n\t\t\t\txx[9] + xx[1] * 3 + xx[12] + 1500) {\n\t\t\t\tamuki[tt] = 1;\n\t\t\t\taa[tt] = aa[t] + 300;\n\t\t\t\tab[tt] = ab[t] - 3000;\n\t\t\t\tabrocktm[tt] = 120;\n\t\t\t\tatm[t] = 200;\n\t\t\t\tamuki[t] = 1;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\tcase 7:\n\t\t    azimentype[t] = 0;\n\t\t    xx[10] = 0;\n\t\t    xx[11] = 400;\n\t\t    if (axtype[t] == 0)\n\t\t\txx[10] = xx[11];\n\t\t    if (axtype[t] == 1)\n\t\t\txx[10] = -xx[11];\n\t\t    if (axtype[t] == 2)\n\t\t\tab[t] -= xx[11];\n\t\t    if (axtype[t] == 3)\n\t\t\tab[t] += xx[11];\n\t\t    break;\n\t\tcase 8:\n\t\t    azimentype[t] = 0;\n\t\t    xx[22] = 20;\n\t\t    if (atm[t] == 0) {\n\t\t\taf[t] += xx[22];\n\t\t\tad[t] += xx[22];\n\t\t    }\n\t\t    if (atm[t] == 1) {\n\t\t\taf[t] -= xx[22];\n\t\t\tad[t] -= xx[22];\n\t\t    }\n\t\t    if (ad[t] > 300)\n\t\t\tad[t] = 300;\n\t\t    if (ad[t] < -300)\n\t\t\tad[t] = -300;\n\t\t    if (af[t] >= 1200)\n\t\t\tatm[t] = 1;\n\t\t    if (af[t] < -0)\n\t\t\tatm[t] = 0;\n\t\t    ab[t] += ad[t];\n\t\t    break;\n\t\tcase 151:\n\t\t    azimentype[t] = 2;\n\t\t    break;\n\t\tcase 9:\n\t\t    azimentype[t] = 5;\n\t\t    ab[t] += ad[t];\n\t\t    ad[t] += 100;\n\t\t    if (ab[t] >= fymax + 1000) {\n\t\t\tad[t] = 900;\n\t\t    }\n\t\t    if (ab[t] >= fymax + 12000) {\n\t\t\tab[t] = fymax;\n\t\t\tad[t] = -2600;\n\t\t    }\n\t\t    break;\n\t\tcase 10:\n\t\t    azimentype[t] = 0;\n\t\t    xx[10] = 0;\n\t\t    xx[11] = 400;\n\t\t    if (axtype[t] == 0)\n\t\t\txx[10] = xx[11];\n\t\t    if (axtype[t] == 1)\n\t\t\txx[10] = -xx[11];\n\t\t    break;\n\t\tcase 30:\n\t\t    atm[t] += 1;\n\t\t    if (axtype[t] == 0) {\n\t\t\tif (atm[t] == 50 && mb >= 6000) {\n\t\t\t    ac[t] = 300;\n\t\t\t    ad[t] -= 1600;\n\t\t\t    ab[t] -= 1000;\n\t\t\t}\n\t\t\tfor (tt = 0; tt < amax; tt++) {\n\t\t\t    xx[0] = 250;\n\t\t\t    xx[5] = -800;\n\t\t\t    xx[12] = 0;\n\t\t\t    xx[1] = 1600;\n\t\t\t    xx[8] = aa[tt] - fx;\n\t\t\t    xx[9] = ab[tt] - fy;\n\t\t\t    if (t != tt && atype[tt] == 102) {\n\t\t\t\tif (aa[t] +\n\t\t\t\t    anobia[t] -\n\t\t\t\t    fx >\n\t\t\t\t    xx[8] +\n\t\t\t\t    xx[0] * 2\n\t\t\t\t    && aa[t] -\n\t\t\t\t    fx <\n\t\t\t\t    xx[8] +\n\t\t\t\t    anobia[tt] -\n\t\t\t\t    xx[0] * 2\n\t\t\t\t    && ab[t] +\n\t\t\t\t    anobib[t] - fy > xx[9] + xx[5]\n\t\t\t\t    && ab[t] +\n\t\t\t\t    anobib[t] -\n\t\t\t\t    fy <\n\t\t\t\t    xx[9] + xx[1] * 3 + xx[12] + 1500) {\n\t\t\t\t    aa[tt] = -800000;\n\t\t\t\t    axtype[t]\n\t\t\t\t\t= 1;\n\t\t\t\t    ad[t] = -1600;\n\t\t\t\t    amsgtm[t]\n\t\t\t\t\t= 30;\n\t\t\t\t    amsgtype[t]\n\t\t\t\t\t= 25;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (axtype[t] == 1) {\n\t\t\tazimentype[t] = 0;\n\t\t\tab[t] += ad[t];\n\t\t\tad[t] += 120;\n\t\t    }\n\t\t    break;\n\t\tcase 79:\n\t\t    azimentype[t] = 0;\n\t\t    xx[10] = 1600;\n\t\t    if (axtype[t] == 1) {\n\t\t\txx[10] = 1200;\n\t\t\tab[t] -= 200;\n\t\t    }\n\t\t    if (axtype[t] == 2) {\n\t\t\txx[10] = 1200;\n\t\t\tab[t] += 200;\n\t\t    }\n\t\t    if (axtype[t] == 3) {\n\t\t\txx[10] = 900;\n\t\t\tab[t] -= 600;\n\t\t    }\n\t\t    if (axtype[t] == 4) {\n\t\t\txx[10] = 900;\n\t\t\tab[t] += 600;\n\t\t    }\n\t\t    break;\n\t\tcase 80:\n\t\t    azimentype[t] = 0;\n\t\t    break;\n\t\tcase 81:\n\t\t    azimentype[t] = 0;\n\t\t    break;\n\t\tcase 82:\n\t\t    azimentype[t] = 0;\n\t\t    break;\n\t\tcase 83:\n\t\t    azimentype[t] = 0;\n\t\t    break;\n\t\tcase 84:\n\t\t    azimentype[t] = 2;\n\t\t    break;\n\t\tcase 85:\n\t\t    xx[23] = 400;\n\t\t    if (axtype[t] == 0) {\n\t\t\taxtype[t] = 1;\n\t\t\tamuki[t] = 1;\n\t\t    }\n\t\t    if (mb >= 30000\n\t\t\t&& ma >= aa[t] - 3000 * 5 - fx\n\t\t\t&& ma <= aa[t] - fx && axtype[t] == 1) {\n\t\t\taxtype[t] = 5;\n\t\t\tamuki[t] = 0;\n\t\t    }\n\t\t    if (mb >= 24000\n\t\t\t&& ma <= aa[t] + 3000 * 8 - fx\n\t\t\t&& ma >= aa[t] - fx && axtype[t] == 1) {\n\t\t\taxtype[t] = 5;\n\t\t\tamuki[t] = 1;\n\t\t    }\n\t\t    if (axtype[t] == 5)\n\t\t\txx[10] = xx[23];\n\t\t    break;\n\t\tcase 86:\n\t\t    azimentype[t] = 4;\n\t\t    xx[23] = 1000;\n\t\t    if (ma >= aa[t] - fx - mnobia - xx[26]\n\t\t\t&& ma <= aa[t] - fx + anobia[t] + xx[26]) {\n\t\t\tatm[t] = 1;\n\t\t    }\n\t\t    if (atm[t] == 1) {\n\t\t\tab[t] += 1200;\n\t\t    }\n\t\t    break;\n\t\tcase 87:\n\t\t    azimentype[t] = 0;\n\t\t    if (aa[t] % 10 != 1)\n\t\t\tatm[t] += 6;\n\t\t    else {\n\t\t\tatm[t] -= 6;\n\t\t    }\n\t\t    xx[25] = 2;\n\t\t    if (atm[t] > 360 * xx[25])\n\t\t\tatm[t] -= 360 * xx[25];\n\t\t    if (atm[t] < 0)\n\t\t\tatm[t] += 360 * xx[25];\n\t\t    for (tt = 0; tt <= axtype[t] % 100; tt++) {\n\t\t\txx[26] = 18;\n\t\t\txd[4] = tt * xx[26] * cos(atm[t] * pai / 180 / 2);\n\t\t\txd[5] = tt * xx[26] * sin(atm[t] * pai / 180 / 2);\n\t\t\txx[4] = 1800;\n\t\t\txx[5] = 800;\n\t\t\txx[8] = aa[t] - fx + int (xd[4]) * 100 - xx[4] / 2;\n\t\t\txx[9] = ab[t] - fy + int (xd[5]) * 100 - xx[4] / 2;\n\t\t\tif (ma + mnobia > xx[8] + xx[5]\n\t\t\t    && ma < xx[8] + xx[4] - xx[5]\n\t\t\t    && mb + mnobib > xx[9] + xx[5]\n\t\t\t    && mb < xx[9] + xx[4] - xx[5]) {\n\t\t\t    mhp -= 1;\n\t\t\t    mmsgtype = 51;\n\t\t\t    mmsgtm = 30;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\tcase 88:\n\t\t    azimentype[t] = 0;\n\t\t    if (aa[t] % 10 != 1)\n\t\t\tatm[t] += 6;\n\t\t    else {\n\t\t\tatm[t] -= 6;\n\t\t    }\n\t\t    xx[25] = 2;\n\t\t    if (atm[t] > 360 * xx[25])\n\t\t\tatm[t] -= 360 * xx[25];\n\t\t    if (atm[t] < 0)\n\t\t\tatm[t] += 360 * xx[25];\n\t\t    for (tt = 0; tt <= axtype[t] % 100; tt++) {\n\t\t\txx[26] = 18;\n\t\t\txd[4] = -tt * xx[26] * cos(atm[t] * pai / 180 / 2);\n\t\t\txd[5] = tt * xx[26] * sin(atm[t] * pai / 180 / 2);\n\t\t\txx[4] = 1800;\n\t\t\txx[5] = 800;\n\t\t\txx[8] = aa[t] - fx + int (xd[4]) * 100 - xx[4] / 2;\n\t\t\txx[9] = ab[t] - fy + int (xd[5]) * 100 - xx[4] / 2;\n\t\t\tif (ma + mnobia > xx[8] + xx[5]\n\t\t\t    && ma < xx[8] + xx[4] - xx[5]\n\t\t\t    && mb + mnobib > xx[9] + xx[5]\n\t\t\t    && mb < xx[9] + xx[4] - xx[5]) {\n\t\t\t    mhp -= 1;\n\t\t\t    mmsgtype = 51;\n\t\t\t    mmsgtm = 30;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\tcase 90:\n\t\t    xx[10] = 160;\n\t\t    break;\n\t\tcase 100:\n\t\t    azimentype[t] = 1;\n\t\t    xx[10] = 100;\n\t\t    if (axtype[t] == 2) {\n\t\t\tfor (tt = 0; tt < amax; tt++) {\n\t\t\t    xx[0] = 250;\n\t\t\t    xx[5] = -800;\n\t\t\t    xx[12] = 0;\n\t\t\t    xx[1] = 1600;\n\t\t\t    xx[8] = aa[tt] - fx;\n\t\t\t    xx[9] = ab[tt] - fy;\n\t\t\t    if (t != tt) {\n\t\t\t\tif (aa[t] +\n\t\t\t\t    anobia[t] -\n\t\t\t\t    fx >\n\t\t\t\t    xx[8] +\n\t\t\t\t    xx[0] * 2\n\t\t\t\t    && aa[t] -\n\t\t\t\t    fx <\n\t\t\t\t    xx[8] +\n\t\t\t\t    anobia[tt] -\n\t\t\t\t    xx[0] * 2\n\t\t\t\t    && ab[t] +\n\t\t\t\t    anobib[t] - fy > xx[9] + xx[5]\n\t\t\t\t    && ab[t] +\n\t\t\t\t    anobib[t] -\n\t\t\t\t    fy < xx[9] + xx[1] * 3 + xx[12]) {\n\t\t\t\t    if (atype[tt] == 0 || atype[tt] == 4) {\n\t\t\t\t\tatype[tt] = 90;\n\t\t\t\t\tanobia[tt]\n\t\t\t\t\t    = 6400;\n\t\t\t\t\tanobib[tt]\n\t\t\t\t\t    = 6300;\n\t\t\t\t\taxtype[tt]\n\t\t\t\t\t    = 0;\n\t\t\t\t\taa[tt] -= 1050;\n\t\t\t\t\tab[tt] -= 1050;\n\t\t\t\t\tot(oto[9]);\n\t\t\t\t\taa[t] = -80000000;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\tcase 102:\n\t\t    azimentype[t] = 1;\n\t\t    xx[10] = 100;\n\t\t    if (axtype[t] == 1)\n\t\t\txx[10] = 200;\n\t\t    break;\n\t\tcase 110:\n\t\t    azimentype[t] = 1;\n\t\t    xx[10] = 200;\n\t\t    if (axzimen[t] == 1) {\n\t\t\tab[t] -= 1200;\n\t\t\tad[t] = -1400;\n\t\t    }\n\t\t    break;\n\t\tcase 200:\n\t\t    azimentype[t] = 1;\n\t\t    xx[10] = 100;\n\t\t    break;\n/*\ncase 1:\nxx[10]=180;\nif (axtype[t]==2)xx[10]=0;\nif (axzimen[t]==1){\nab[t]-=1000;ad[t]=-1200;\nif (axtype[t]==1)ad[t]=-1600;\nif (axtype[t]==2){\natm[t]+=1;\nif (atm[t]>=2){atm[t]=0;ad[t]=-1600;}else{ad[t]=-1000;}\n}\n}\nbreak;\ncase 2:\nxx[10]=160;\nif (axtype[t]==1)azimentype[t]=2;xx[10]=100;\nif (axtype[t]==2)xx[10]=0;\nbreak;\ncase 3:\nxx[10]=180;\nif (ae[t]==0)ad[t]+=10;\nif (ae[t]==1)ad[t]-=10;\nif (ad[t]>=100)ae[t]=1;\nif (ad[t]<=-100)ae[t]=0;\nab[t]+=ad[t];\nif (axtype[t]==1){\nif (ab[t]<mb){ab[t]+=100;}\n}\nif (axtype[t]==2)xx[10]=0;\nbreak;\ncase 4:\nif (ae[t]==0)ad[t]+=8;\nif (ae[t]==1)ad[t]-=8;\nif (ad[t]>=80)ae[t]=1;\nif (ad[t]<=-80)ae[t]=0;\nab[t]+=ad[t];\nif (axtype[t]>=1){\nxx[22]=200;xx[21]=3600;\nif (atm[t]==0){atm[t]=ab[t]%2+1;a2tm[t]=aa[t];if (axtype[t]%2==0)a2tm[t]=ab[t];}\nif (axtype[t]%2==1){\nif (aa[t]<a2tm[t]-xx[21]){atm[t]=2;}\nif (aa[t]>a2tm[t]+xx[21]){atm[t]=1;}\nif (atm[t]==1){aa[t]-=xx[22];amuki[t]=0;}\nif (atm[t]==2){aa[t]+=xx[22];amuki[t]=1;}\n}\nif (axtype[t]%2==0){\nif (ab[t]<a2tm[t]-xx[21]){atm[t]=2;}\nif (ab[t]>a2tm[t]+xx[21]){atm[t]=1;}\nif (atm[t]==1){ab[t]-=xx[22];}\nif (atm[t]==2){ab[t]+=xx[22];}\n}\n}\nbreak;\ncase 5:\nxx[10]=120;atm[t]++;\nif (axtype[t]==2){xx[10]=200;azimentype[t]=2;}\nif (ma+mnobia>=aa[t]-fx && ma<=aa[t]+anobia[t]-fx && mb+mnobib+1000<ab[t]-fy){\nxx[10]=300;\nif (axtype[t]>=1){\nif (atm[t]>=16){amuki[t]+=1;if (amuki[t]>=2)amuki[t]=0;atm[t]=0;\n}}\n}\nbreak;\ncase 6:\natm[t]+=1;xx[10]=0;\nif (axtype[t]==1)atm[t]+=(rand(9)-4);\nif (axtype[t]==2)xx[10]=100;\nif (atm[t]>=40){\nxx[22]=360;if (amuki[t]==0)xx[22]=-xx[22];\ncyobi(aa[t]+amuki[t]*anobia[t],ab[t]+1600,xx[22],0,0,0,0,60);\natm[t]=0;\n}\nif (axtype[t]!=2){\nif (ma+mnobia/2<=aa[t]+anobia[t]/2-fx){amuki[t]=0;}else{amuki[t]=1;}\n}\nbreak;\ncase 7:\nxx[10]=160;\nif (axtype[t]==1)xx[10]=240;\nif (axtype[t]==2)xx[10]=60;\nbreak;\ncase 8:\natm[t]+=1;xx[10]=0;\nxx[15]=12;xx[17]=0;\nif (axtype[t]==1)xx[15]=8;\nif (axtype[t]==2){xx[15]=40;xx[17]=3;}\nif (atm[t]>=xx[15]){\nfor (t3=0;t3<=xx[17];t3++){\nxx[16]=300;xx[22]=rand(xx[16])*5/4-xx[16]/4;\na2tm[t]+=1;if (a2tm[t]>=1){xx[22]=-xx[22];a2tm[t]=-1;}\ncyobi(aa[t]+amuki[t]*anobia[t]/2,ab[t]+600,xx[22],-400-rand(600),0,80,1,60);\n}\natm[t]=0;\n}\nbreak;\n*/\n\t\t}\n\t\tif (abrocktm[t] >= 1)\n\t\t    xx[10] = 0;\n\t\tif (amuki[t] == 0)\n\t\t    aacta[t] -= xx[10];\n\t\tif (amuki[t] == 1)\n\t\t    aacta[t] += xx[10];\n\t\txx[0] = 850;\n\t\txx[1] = 1200;\n\t\tif (ad[t] > xx[1] && azimentype[t] != 5) {\n\t\t    ad[t] = xx[1];\n\t\t}\n\t\taa[t] += aacta[t];\n\t\tif ((azimentype[t] >= 1 || azimentype[t] == -1)\n\t\t    && abrocktm[t] <= 0) {\n\t\t    aa[t] += ac[t];\n\t\t    if (azimentype[t] >= 1 && azimentype[t] <= 3) {\n\t\t\tab[t] += ad[t];\n\t\t\tad[t] += 120;\n\t\t    }\n\t\t    if (axzimen[t] == 1) {\n\t\t\txx[0] = 100;\n\t\t\tif (ac[t] >= 200) {\n\t\t\t    ac[t] -= xx[0];\n\t\t\t} else if (ac[t] <= -200) {\n\t\t\t    ac[t] += xx[0];\n\t\t\t} else {\n\t\t\t    ac[t] = 0;\n\t\t\t}\n\t\t    }\n\t\t    axzimen[t] = 0;\n\t\t    if (azimentype[t] != 2) {\n\t\t\ttekizimen();\n\t\t    }\n\t\t}\n\t\tif (abrocktm[t] > 0) {\n\t\t    abrocktm[t]--;\n\t\t    if (abrocktm[t] < 100) {\n\t\t\tab[t] -= 180;\n\t\t    }\n\t\t    if (abrocktm[t] > 100) {\n\t\t    }\n\t\t    if (abrocktm[t] == 100) {\n\t\t\tab[t] -= 800;\n\t\t\tad[t] = -1200;\n\t\t\tac[t] = 700;\n\t\t\tabrocktm[t] = 0;\n\t\t    }\n\t\t}\n\t\txx[0] = 250;\n\t\txx[1] = 1600;\n\t\txx[2] = 1000;\n\t\txx[4] = 500;\n\t\txx[5] = -800;\n\t\txx[8] = aa[t] - fx;\n\t\txx[9] = ab[t] - fy;\n\t\txx[12] = 0;\n\t\tif (md >= 100)\n\t\t    xx[12] = md;\n\t\txx[25] = 0;\n\t\tif (ma + mnobia > xx[8] + xx[0] * 2\n\t\t    && ma < xx[8] + anobia[t] - xx[0] * 2\n\t\t    && mb + mnobib > xx[9] - xx[5]\n\t\t    && mb + mnobib < xx[9] + xx[1] + xx[12]\n\t\t    && (mmutekitm <= 0 || md >= 100)\n\t\t    && abrocktm[t] <= 0) {\n\t\t    if (atype[t] != 4 && atype[t] != 9 && atype[t] != 10 && (atype[t] <= 78 || atype[t] == 85) && mzimen != 1 && mtype != 200) {\n\t\t\tif (atype[t] == 0) {\n\t\t\t    if (axtype[t] == 0)\n\t\t\t\taa[t] = -900000;\n\t\t\t    if (axtype[t] == 1) {\n\t\t\t\tot(oto[5]);\n\t\t\t\tmb = xx[9] - 900 - anobib[t];\n\t\t\t\tmd = -2100;\n\t\t\t\txx[25] = 1;\n\t\t\t\tactaon[2] = 0;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (atype[t] == 1) {\n\t\t\t    atype[t] = 2;\n\t\t\t    anobib[t] = 3000;\n\t\t\t    axtype[t] = 0;\n\t\t\t}\n\t\t\telse if (atype[t] == 2 && md >= 0) {\n\t\t\t    if (axtype[t] == 1 || axtype[t] == 2) {\n\t\t\t\taxtype[t] = 0;\n\t\t\t    } else if (axtype[t] == 0) {\n\t\t\t\tif (ma +\n\t\t\t\t    mnobia >\n\t\t\t\t    xx[8] +\n\t\t\t\t    xx[0] * 2\n\t\t\t\t    && ma <\n\t\t\t\t    xx[8] + anobia[t] / 2 - xx[0] * 4) {\n\t\t\t\t    axtype[t]\n\t\t\t\t\t= 1;\n\t\t\t\t    amuki[t]\n\t\t\t\t\t= 1;\n\t\t\t\t} else {\n\t\t\t\t    axtype[t]\n\t\t\t\t\t= 1;\n\t\t\t\t    amuki[t]\n\t\t\t\t\t= 0;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t\tif (atype[t] == 3) {\n\t\t\t    xx[25] = 1;\n\t\t\t}\n\t\t\tif (atype[t] == 6) {\n\t\t\t    atm[t] = 10;\n\t\t\t    md = 0;\n\t\t\t    actaon[2] = 0;\n\t\t\t}\n\t\t\tif (atype[t] == 7) {\n\t\t\t    aa[t] = -900000;\n\t\t\t}\n\t\t\tif (atype[t] == 8) {\n\t\t\t    atype[t] = 151;\n\t\t\t    ad[t] = 0;\n\t\t\t}\n\t\t\tif (atype[t] != 85) {\n\t\t\t    if (xx[25] == 0) {\n\t\t\t\tot(oto[5]);\n\t\t\t\tmb = xx[9] - 1000 - anobib[t];\n\t\t\t\tmd = -1000;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (atype[t] == 85) {\n\t\t\t    if (xx[25] == 0) {\n\t\t\t\tot(oto[5]);\n\t\t\t\tmb = xx[9] - 4000;\n\t\t\t\tmd = -1000;\n\t\t\t\taxtype[t] = 5;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (actaon[2] == 1) {\n\t\t\t    md = -1600;\n\t\t\t    actaon[2] = 0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\txx[15] = -500;\n\t\txx[16] = 0;\n\t\tif (atype[t] == 4 || atype[t] == 9 || atype[t] == 10)\n\t\t    xx[16] = -3000;\n\t\tif (atype[t] == 82 || atype[t] == 83 || atype[t] == 84)\n\t\t    xx[16] = -3200;\n\t\tif (atype[t] == 85)\n\t\t    xx[16] = -anobib[t] + 6000;\n\t\tif (ma + mnobia > xx[8] + xx[4]\n\t\t    && ma < xx[8] + anobia[t] - xx[4]\n\t\t    && mb < xx[9] + anobib[t] + xx[15]\n\t\t    && mb + mnobib > xx[9] + anobib[t] - xx[0] + xx[16]\n\t\t    && anotm[t] <= 0 && abrocktm[t] <= 0) {\n\t\t    if (mmutekion == 1) {\n\t\t\taa[t] = -9000000;\n\t\t    }\n\t\t    if (mmutekitm <= 0\n\t\t\t&& (atype[t] <= 99 || atype[t] >= 200)) {\n\t\t\tif (mmutekion != 1 && mtype != 200) {\n\t\t\t    if ((atype[t] != 2 || axtype[t] != 0)\n\t\t\t\t&& mhp >= 1) {\n\t\t\t\tif (atype[t] != 6) {\n\t\t\t\t    mhp -= 1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    if (atype[t] == 6) {\n\t\t\t\tatm[t] = 10;\n\t\t\t    }\n\t\t\t    if (mhp == 0) {\n\t\t\t\tif (atype[t] == 0 || atype[t]\n\t\t\t\t    == 7) {\n\t\t\t\t    amsgtm[t]\n\t\t\t\t\t= 60;\n\t\t\t\t    amsgtype[t]\n\t\t\t\t\t= rand(7)\n\t\t\t\t\t+ 1 + 1000 + (stb - 1)\n\t\t\t\t\t* 10;\n\t\t\t\t}\n\t\t\t\tif (atype[t] == 1) {\n\t\t\t\t    amsgtm[t]\n\t\t\t\t\t= 60;\n\t\t\t\t    amsgtype[t]\n\t\t\t\t\t= rand(2)\n\t\t\t\t\t+ 15;\n\t\t\t\t}\n\t\t\t\tif (atype[t] == 2 && axtype[t]\n\t\t\t\t    >= 1 && mmutekitm <= 0) {\n\t\t\t\t    amsgtm[t]\n\t\t\t\t\t= 60;\n\t\t\t\t    amsgtype[t]\n\t\t\t\t\t= 18;\n\t\t\t\t}\n\t\t\t\tif (atype[t] == 3) {\n\t\t\t\t    amsgtm[t]\n\t\t\t\t\t= 60;\n\t\t\t\t    amsgtype[t]\n\t\t\t\t\t= 20;\n\t\t\t\t}\n\t\t\t\tif (atype[t] == 4) {\n\t\t\t\t    amsgtm[t]\n\t\t\t\t\t= 60;\n\t\t\t\t    amsgtype[t]\n\t\t\t\t\t= rand(7)\n\t\t\t\t\t+ 1 + 1000 + (stb - 1)\n\t\t\t\t\t* 10;\n\t\t\t\t}\n\t\t\t\tif (atype[t] == 5) {\n\t\t\t\t    amsgtm[t]\n\t\t\t\t\t= 60;\n\t\t\t\t    amsgtype[t]\n\t\t\t\t\t= 21;\n\t\t\t\t}\n\t\t\t\tif (atype[t] == 9 || atype[t]\n\t\t\t\t    == 10) {\n\t\t\t\t    mmsgtm = 30;\n\t\t\t\t    mmsgtype = 54;\n\t\t\t\t}\n\t\t\t\tif (atype[t] == 31) {\n\t\t\t\t    amsgtm[t]\n\t\t\t\t\t= 30;\n\t\t\t\t    amsgtype[t]\n\t\t\t\t\t= 24;\n\t\t\t\t}\n\t\t\t\tif (atype[t] == 80 || atype[t]\n\t\t\t\t    == 81) {\n\t\t\t\t    amsgtm[t]\n\t\t\t\t\t= 60;\n\t\t\t\t    amsgtype[t]\n\t\t\t\t\t= 30;\n\t\t\t\t}\n\t\t\t\tif (atype[t] == 82) {\n\t\t\t\t    amsgtm[t]\n\t\t\t\t\t= 20;\n\t\t\t\t    amsgtype[t]\n\t\t\t\t\t= rand(1)\n\t\t\t\t\t+ 31;\n\t\t\t\t    xx[24] = 900;\n\t\t\t\t    atype[t]\n\t\t\t\t\t= 83;\n\t\t\t\t    aa[t] -= xx[24]\n\t\t\t\t\t+ 100;\n\t\t\t\t    ab[t] -= xx[24]\n\t\t\t\t\t- 100 * 0;\n\t\t\t\t}\n\t\t\t\tif (atype[t] == 84) {\n\t\t\t\t    mmsgtm = 30;\n\t\t\t\t    mmsgtype = 50;\n\t\t\t\t}\n\t\t\t\tif (atype[t] == 85) {\n\t\t\t\t    amsgtm[t]\n\t\t\t\t\t= 60;\n\t\t\t\t    amsgtype[t]\n\t\t\t\t\t= rand(1)\n\t\t\t\t\t+ 85;\n\t\t\t\t}\n\t\t\t\tif (atype[t] == 80) {\n\t\t\t\t    atype[t]\n\t\t\t\t\t= 81;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    if (atype[t] == 2) {\n\t\t\t\tif (axtype[t] == 0) {\n\t\t\t\t    if (ma + mnobia > xx[8]\n\t\t\t\t\t+ xx[0]\n\t\t\t\t\t* 2 && ma < xx[8]\n\t\t\t\t\t+ anobia[t]\n\t\t\t\t\t/ 2 - xx[0]\n\t\t\t\t\t* 4) {\n\t\t\t\t\taxtype[t]\n\t\t\t\t\t    = 1;\n\t\t\t\t\tamuki[t]\n\t\t\t\t\t    = 1;\n\t\t\t\t\taa[t] = ma + mnobia + fx + mc;\n\t\t\t\t\tmmutekitm = 5;\n\t\t\t\t    } else {\n\t\t\t\t\taxtype[t]\n\t\t\t\t\t    = 1;\n\t\t\t\t\tamuki[t]\n\t\t\t\t\t    = 0;\n\t\t\t\t\taa[t] = ma - anobia[t] + fx - mc;\n\t\t\t\t\tmmutekitm = 5;\n\t\t\t\t    }\n\t\t\t\t} else {\n\t\t\t\t    mhp -= 1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (atype[t] >= 100 && atype[t] <= 199) {\n\t\t\tif (atype[t] == 100 && axtype[t] == 0) {\n\t\t\t    mmsgtm = 30;\n\t\t\t    mmsgtype = 1;\n\t\t\t    ot(oto[9]);\n\t\t\t}\n\t\t\tif (atype[t] == 100 && axtype[t] == 1) {\n\t\t\t    mmsgtm = 30;\n\t\t\t    mmsgtype = 2;\n\t\t\t    ot(oto[9]);\n\t\t\t}\n\t\t\tif (atype[t] == 100 && axtype[t] == 2) {\n\t\t\t    mnobia = 5200;\n\t\t\t    mnobib = 7300;\n\t\t\t    ot(oto[9]);\n\t\t\t    ma -= 1100;\n\t\t\t    mb -= 4000;\n\t\t\t    mtype = 1;\n\t\t\t    mhp = 50000000;\n\t\t\t}\n\t\t\tif (atype[t] == 101) {\n\t\t\t    mhp -= 1;\n\t\t\t    mmsgtm = 30;\n\t\t\t    mmsgtype = 11;\n\t\t\t}\n\t\t\tif (atype[t] == 102) {\n\t\t\t    mhp -= 1;\n\t\t\t    mmsgtm = 30;\n\t\t\t    mmsgtype = 10;\n\t\t\t}\n\t\t\tif (atype[t] == 105) {\n\t\t\t    if (axtype[t] == 0) {\n\t\t\t\tot(oto[4]);\n\t\t\t\tsgtype[26] = 6;\n\t\t\t    }\n\t\t\t    if (axtype[t] == 1) {\n\t\t\t\ttxtype[7] = 80;\n\t\t\t\tot(oto[4]);\n\t\t\t\tayobi(aa[t] -\n\t\t\t\t      8 * 3000 -\n\t\t\t\t      1000, -4 * 3000, 0, 0, 0, 110, 0);\n\t\t\t\tayobi(aa[t] -\n\t\t\t\t      10 *\n\t\t\t\t      3000 +\n\t\t\t\t      1000, -1 * 3000, 0, 0, 0, 110, 0);\n\t\t\t\tayobi(aa[t] +\n\t\t\t\t      4 * 3000 +\n\t\t\t\t      1000, -2 * 3000, 0, 0, 0, 110, 0);\n\t\t\t\tayobi(aa[t] +\n\t\t\t\t      5 * 3000 -\n\t\t\t\t      1000, -3 * 3000, 0, 0, 0, 110, 0);\n\t\t\t\tayobi(aa[t] +\n\t\t\t\t      6 * 3000 +\n\t\t\t\t      1000, -4 * 3000, 0, 0, 0, 110, 0);\n\t\t\t\tayobi(aa[t] +\n\t\t\t\t      7 * 3000 -\n\t\t\t\t      1000, -2 * 3000, 0, 0, 0, 110, 0);\n\t\t\t\tayobi(aa[t] +\n\t\t\t\t      8 * 3000 +\n\t\t\t\t      1000,\n\t\t\t\t      -2 * 3000 - 1000, 0, 0, 0, 110, 0);\n\t\t\t\ttb[0] += 3000 * 3;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (atype[t] == 110) {\n\t\t\t    mhp -= 1;\n\t\t\t    mmsgtm = 30;\n\t\t\t    mmsgtype = 3;\n\t\t\t}\n/*\nif (atype[t]==101){mmutekitm=120;mmutekion=1;}\nif (atype[t]==102){mhp-=1;mmutekitm=20;}\nif (atype[t]==103){\neyobi(aa[t]-500,ab[t],0,-600,0,80,2500,1600,2,32);\n}\nif (atype[t]==104){mztm=120;mztype=1;}\nif (atype[t]==105){mztm=160;mztype=2;}\nif (atype[t]==120){mtype=3;mnobia=3800;mnobib=2300;}\nif (atype[t]==130){msoubi=1;}\nif (atype[t]==131){msoubi=2;}\nif (atype[t]==132){msoubi=3;}\nif (atype[t]==133){msoubi=4;}\n*/\n\t\t\taa[t] = -90000000;\n\t\t    }\n\t\t}\n\t    } else {\n\t\taa[t] = -9000000;\n\t    }\n\t}\n\tif (kscroll != 1 && kscroll != 2) {\n\t    xx[2] = mascrollmax;\n\t    xx[3] = 0;\n\t    xx[1] = xx[2];\n\t    if (ma > xx[1] && fzx < scrollx) {\n\t\txx[5] = ma - xx[1];\n\t\tma = xx[1];\n\t\tfx += xx[5];\n\t\tfzx += xx[5];\n\t\tif (xx[1] <= 5000)\n\t\t    xx[3] = 1;\n\t    }\n\t}\n    }\n    if (mainZ == 2) {\n\tmaintm++;\n\txx[7] = 46;\n\tif (CheckHitKey(KEY_INPUT_1) == 1) {\n\t    end();\n\t}\n\tif (CheckHitKey(KEY_INPUT_SPACE) == 1) {\n\t    for (t = 0; t <= xx[7]; t += 1) {\n\t\txx[12 + t] -= 300;\n\t    }\n\t}\n\tif (maintm <= 1) {\n\t    maintm = 2;\n\t    bgmchange(otom[5]);\n\t    xx[10] = 0;\n\t    for (t = 0; t <= xx[7]; t += 1) {\n\t\txx[12 + t] = 980000;\n\t    }\n\t    xx[12] = 460;\n\t    xx[13] = 540;\n\t    xx[14] = 590;\n\t    xx[15] = 650;\n\t    xx[16] = 700;\n\t    xx[17] = 760;\n\t    xx[18] = 810;\n\t    xx[19] = 870;\n\t    xx[20] = 920;\n\t    xx[21] = 1000;\n\t    xx[22] = 1050;\n\t    xx[23] = 1100;\n\t    xx[24] = 1180;\n\t    xx[25] = 1230;\n\t    xx[26] = 1360;\n\t    xx[27] = 1410;\n\t    xx[28] = 1540;\n\t    xx[29] = 1590;\n\t    xx[30] = 1800;\n\t    for (t = 0; t <= xx[7]; t += 1) {\n\t\txx[12 + t] *= 100;\n\t    }\n\t}\n\txx[10] += 1;\n\tfor (t = 0; t <= xx[7]; t += 1) {\n\t    xx[12 + t] -= 100;\n\t}\n\tif (xx[30] == -200) {\n\t    bgmchange(otom[5]);\n\t}\n\tif (xx[30] <= -400) {\n\t    mainZ = 100;\n\t    nokori = 2;\n\t    maintm = 0;\n\t    ending = 0;\n\t}\n    }\n    if (mainZ == 10) {\n\tmaintm++;\n\tif (fast == 1)\n\t    maintm += 2;\n\tif (maintm >= 30) {\n\t    maintm = 0;\n\t    mainZ = 1;\n\t    zxon = 0;\n\t}\n    }\n    if (mainZ == 100) {\n\tmaintm++;\n\txx[0] = 0;\n\tif (maintm <= 10) {\n\t    maintm = 11;\n\t    sta = 1;\n\t    stb = 1;\n\t    stc = 0;\n\t    over = 0;\n\t}\n\tif (CheckHitKey(KEY_INPUT_1) == 1) {\n\t    sta = 1;\n\t    stb = 1;\n\t    stc = 0;\n\t}\n\tif (CheckHitKey(KEY_INPUT_2) == 1) {\n\t    sta = 1;\n\t    stb = 2;\n\t    stc = 0;\n\t}\n\tif (CheckHitKey(KEY_INPUT_3) == 1) {\n\t    sta = 1;\n\t    stb = 3;\n\t    stc = 0;\n\t}\n\tif (CheckHitKey(KEY_INPUT_4) == 1) {\n\t    sta = 1;\n\t    stb = 4;\n\t    stc = 0;\n\t}\n\tif (CheckHitKey(KEY_INPUT_5) == 1) {\n\t    sta = 2;\n\t    stb = 1;\n\t    stc = 0;\n\t}\n\tif (CheckHitKey(KEY_INPUT_6) == 1) {\n\t    sta = 2;\n\t    stb = 2;\n\t    stc = 0;\n\t}\n\tif (CheckHitKey(KEY_INPUT_7) == 1) {\n\t    sta = 2;\n\t    stb = 3;\n\t    stc = 0;\n\t}\n\tif (CheckHitKey(KEY_INPUT_8) == 1) {\n\t    sta = 2;\n\t    stb = 4;\n\t    stc = 0;\n\t}\n\tif (CheckHitKey(KEY_INPUT_9) == 1) {\n\t    sta = 3;\n\t    stb = 1;\n\t    stc = 0;\n\t}\n\tif (CheckHitKey(KEY_INPUT_0) == 1) {\n\t    xx[0] = 1;\n\t    over = 1;\n\t}\n\tif (CheckHitKey(KEY_INPUT_RETURN) == 1) {\n\t    xx[0] = 1;\n\t}\n\tif (CheckHitKey(KEY_INPUT_Z) == 1) {\n\t    xx[0] = 1;\n\t}\n\tif (xx[0] == 1) {\n\t    mainZ = 10;\n\t    zxon = 0;\n\t    maintm = 0;\n\t    nokori = 2;\n\t    fast = 0;\n\t    trap = 0;\n\t    tyuukan = 0;\n\t}\n    }\n    rpaint();\n    xx[0] = 30;\n    if (CheckHitKey(KEY_INPUT_SPACE) == 1) {\n\txx[0] = 60;\n    }\n#ifndef EMSCRIPTEN\n    wait2(stime, long (GetNowCount()), 1000 / xx[0]);\n#endif\n}\nvoid tekizimen()\n{\n    for (tt = 0; tt < smax; tt++) {\n\tif (sa[tt] - fx + sc[tt] >= -12010\n\t    && sa[tt] - fx <= fxmax + 12100 && stype[tt] <= 99) {\n\t    xx[0] = 200;\n\t    xx[2] = 1000;\n\t    xx[1] = 2000;\n\t    xx[8] = sa[tt] - fx;\n\t    xx[9] = sb[tt] - fy;\n\t    if (aa[t] + anobia[t] - fx > xx[8] - xx[0]\n\t\t&& aa[t] - fx < xx[8] + xx[2]\n\t\t&& ab[t] + anobib[t] - fy > xx[9] + xx[1] * 3 / 4\n\t\t&& ab[t] - fy < xx[9] + sd[tt] - xx[2]) {\n\t\taa[t] = xx[8] - xx[0] - anobia[t] + fx;\n\t\tamuki[t] = 0;\n\t    }\n\t    if (aa[t] + anobia[t] - fx > xx[8] + sc[tt] - xx[0]\n\t\t&& aa[t] - fx < xx[8] + sc[tt] + xx[0]\n\t\t&& ab[t] + anobib[t] - fy > xx[9] + xx[1] * 3 / 4\n\t\t&& ab[t] - fy < xx[9] + sd[tt] - xx[2]) {\n\t\taa[t] = xx[8] + sc[tt] + xx[0] + fx;\n\t\tamuki[t] = 1;\n\t    }\n\t    if (aa[t] + anobia[t] - fx > xx[8] + xx[0]\n\t\t&& aa[t] - fx < xx[8] + sc[tt] - xx[0]\n\t\t&& ab[t] + anobib[t] - fy > xx[9]\n\t\t&& ab[t] + anobib[t] - fy < xx[9] + sd[tt] - xx[1]\n\t\t&& ad[t] >= -100) {\n\t\tab[t] = sb[tt] - fy - anobib[t] + 100 + fy;\n\t\tad[t] = 0;\n\t\taxzimen[t] = 1;\n\t    }\n\t    if (aa[t] + anobia[t] - fx > xx[8] + xx[0]\n\t\t&& aa[t] - fx < xx[8] + sc[tt] - xx[0]\n\t\t&& ab[t] - fy > xx[9] + sd[tt] - xx[1]\n\t\t&& ab[t] - fy < xx[9] + sd[tt] + xx[0]) {\n\t\tab[t] = xx[9] + sd[tt] + xx[0] + fy;\n\t\tif (ad[t] < 0) {\n\t\t    ad[t] = -ad[t] * 2 / 3;\n\t\t}\n\t    }\n\t}\n    }\n    for (tt = 0; tt < tmax; tt++) {\n\txx[0] = 200;\n\txx[1] = 3000;\n\txx[2] = 1000;\n\txx[8] = ta[tt] - fx;\n\txx[9] = tb[tt] - fy;\n\tif (ta[tt] - fx + xx[1] >= -12010 && ta[tt] - fx <= fxmax + 12000) {\n\t    if (atype[t] != 86 && atype[t] != 90 && ttype[tt] != 140) {\n\t\tif (ttype[tt] != 7) {\n\t\t    if (!(ttype[tt] == 117)) {\n\t\t\tif (aa[t] + anobia[t] - fx > xx[8] + xx[0]\n\t\t\t    && aa[t] - fx <\n\t\t\t    xx[8] + xx[1] - xx[0] * 1\n\t\t\t    && ab[t] + anobib[t] - fy > xx[9]\n\t\t\t    && ab[t] + anobib[t] - fy < xx[9] + xx[1]\n\t\t\t    && ad[t] >= -100) {\n\t\t\t    ab[t] = xx[9] - anobib[t] + 100 + fy;\n\t\t\t    ad[t] = 0;\n\t\t\t    axzimen[t] = 1;\n\t\t\t    if (ttype[tt] == 120) {\n\t\t\t\tad[t] = -1600;\n\t\t\t\tazimentype[t] = 30;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ttype[tt] != 117) {\n\t\t    if (aa[t] + anobia[t] - fx > xx[8] + xx[0]\n\t\t\t&& aa[t] - fx <\n\t\t\txx[8] + xx[1] - xx[0] * 1\n\t\t\t&& ab[t] - fy > xx[9] + xx[1] - xx[1]\n\t\t\t&& ab[t] - fy < xx[9] + xx[1] + xx[0]) {\n\t\t\tab[t] = xx[9] + xx[1] + xx[0] + fy;\n\t\t\tif (ad[t] < 0) {\n\t\t\t    ad[t] = 0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\txx[27] = 0;\n\t\tif ((atype[t] >= 100\n\t\t     || (ttype[tt] != 7 || ttype[tt] == 7\n\t\t\t && atype[t] == 2))\n\t\t    && ttype[tt] != 117) {\n\t\t    if (aa[t] + anobia[t] - fx > xx[8]\n\t\t\t&& aa[t] - fx < xx[8] + xx[2]\n\t\t\t&& ab[t] + anobib[t] - fy >\n\t\t\txx[9] + xx[1] / 2 - xx[0]\n\t\t\t&& ab[t] - fy < xx[9] + xx[2]) {\n\t\t\taa[t] = xx[8] - anobia[t] + fx;\n\t\t\tac[t] = 0;\n\t\t\tamuki[t] = 0;\n\t\t\txx[27] = 1;\n\t\t    }\n\t\t    if (aa[t] + anobia[t] - fx >\n\t\t\txx[8] + xx[1] - xx[0] * 2\n\t\t\t&& aa[t] - fx < xx[8] + xx[1]\n\t\t\t&& ab[t] + anobib[t] - fy >\n\t\t\txx[9] + xx[1] / 2 - xx[0]\n\t\t\t&& ab[t] - fy < xx[9] + xx[2]) {\n\t\t\taa[t] = xx[8] + xx[1] + fx;\n\t\t\tac[t] = 0;\n\t\t\tamuki[t] = 1;\n\t\t\txx[27] = 1;\n\t\t    }\n\t\t    if (xx[27] == 1 && (ttype[tt] == 7 || ttype[tt] == 1)\n\t\t\t&& atype[t] == 2) {\n\t\t\tif (ttype[tt] == 7) {\n\t\t\t    ot(oto[4]);\n\t\t\t    ttype[tt] = 3;\n\t\t\t    eyobi(ta[tt] + 10,\n\t\t\t\t  tb[tt], 0, -800,\n\t\t\t\t  0, 40, 3000, 3000, 0, 16);\n\t\t\t} else if (ttype[tt] == 1) {\n\t\t\t    ot(oto[3]);\n\t\t\t    eyobi(ta[tt] + 1200,\n\t\t\t\t  tb[tt] + 1200,\n\t\t\t\t  300, -1000, 0, 160, 1000, 1000, 1, 120);\n\t\t\t    eyobi(ta[tt] + 1200,\n\t\t\t\t  tb[tt] + 1200,\n\t\t\t\t  -300, -1000, 0, 160, 1000, 1000, 1, 120);\n\t\t\t    eyobi(ta[tt] + 1200,\n\t\t\t\t  tb[tt] + 1200,\n\t\t\t\t  240, -1400, 0, 160, 1000, 1000, 1, 120);\n\t\t\t    eyobi(ta[tt] + 1200,\n\t\t\t\t  tb[tt] + 1200,\n\t\t\t\t  -240, -1400, 0, 160, 1000, 1000, 1, 120);\n\t\t\t    brockbreak(tt);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    if (atype[t] == 86 || atype[t] == 90) {\n\t\tif (aa[t] + anobia[t] - fx > xx[8]\n\t\t    && aa[t] - fx < xx[8] + xx[1]\n\t\t    && ab[t] + anobib[t] - fy > xx[9]\n\t\t    && ab[t] - fy < xx[9] + xx[1]) {\n\t\t    ot(oto[3]);\n\t\t    eyobi(ta[tt] + 1200, tb[tt] + 1200, 300,\n\t\t\t  -1000, 0, 160, 1000, 1000, 1, 120);\n\t\t    eyobi(ta[tt] + 1200, tb[tt] + 1200,\n\t\t\t  -300, -1000, 0, 160, 1000, 1000, 1, 120);\n\t\t    eyobi(ta[tt] + 1200, tb[tt] + 1200, 240,\n\t\t\t  -1400, 0, 160, 1000, 1000, 1, 120);\n\t\t    eyobi(ta[tt] + 1200, tb[tt] + 1200,\n\t\t\t  -240, -1400, 0, 160, 1000, 1000, 1, 120);\n\t\t    brockbreak(tt);\n\t\t}\n\t    }\n\t}\n\tif (ttype[tt] == 140) {\n\t    if (ab[t] - fy > xx[9] - xx[0] * 2 - 2000\n\t\t&& ab[t] - fy < xx[9] + xx[1] - xx[0] * 2 + 2000\n\t\t&& aa[t] + anobia[t] - fx > xx[8] - 400\n\t\t&& aa[t] - fx < xx[8] + xx[1]) {\n\t\tta[tt] = -800000;\n\t\tsracttype[20] = 1;\n\t\tsron[20] = 1;\n\t    }\n\t}\n    }\n}\nvoid wait2(long stime, long etime, int FLAME_TIME)\n{\n    if (etime - stime < FLAME_TIME)\n\twait(FLAME_TIME - (etime - stime));\n}\nint rand(int Rand)\n{\n    return rand() % Rand;\n}\nvoid deinit()\n{\n    setc0();\n    FillScreen();\n    DrawString(200, 200, \"EXITING...\", GetColor(255, 255, 255));\n    SDL_Flip(screen);\n    for (t = 0; t < 51; t++)\n\tSDL_FreeSurface(mgrap[t]);\n    for (int i = 0; i < 161; i++)\n\tfor (int j = 0; j < 8; j++)\n\t    SDL_FreeSurface(grap[i][j]);\n    for (int i = 1; i < 6; i++)\n\tMix_FreeMusic(otom[i]);\n    for (int i = 1; i < 19; i++)\n\tMix_FreeChunk(oto[i]);\n    for (int i = 0; i < FONT_MAX; i++)\n\tTTF_CloseFont(font[i]);\n    SDL_JoystickClose(joystick);\n    IMG_Quit();\n    TTF_Quit();\n    Mix_Quit();\n    SDL_Quit();\n}\nvoid setcolor(int red, int green, int blue)\n{\n    color = GetColor(red, green, blue);\n    gfxcolor = red << 8 * 3 | green << 8 * 2 | blue << 8 | 0xFF;\n}\nvoid setc0()\n{\n    setcolor(0, 0, 0);\n}\nvoid setc1()\n{\n    setcolor(255, 255, 255);\n}\nvoid drawpixel(int a, int b)\n{\n    pixelColor(screen, a, b, gfxcolor);\n}\nvoid drawline(int a, int b, int c, int d)\n{\n    lineColor(screen, a, b, c, d, gfxcolor);\n}\nvoid drawrect(int a, int b, int c, int d)\n{\n    rectangleColor(screen, a, b, a + c - 1, b + d - 1, gfxcolor);\n}\nvoid fillrect(int a, int b, int c, int d)\n{\n    boxColor(screen, a, b, a + c - 1, b + d - 1, gfxcolor);\n}\nvoid drawarc(int a, int b, int c, int d)\n{\n    ellipseColor(screen, a, b, c, d, gfxcolor);\n}\nvoid fillarc(int a, int b, int c, int d)\n{\n    filledEllipseColor(screen, a, b, c, d, gfxcolor);\n}\nvoid FillScreen()\n{\n    SDL_FillRect(screen, 0, color);\n}\nSDL_Surface *loadimage(string x)\n{\n    return LoadGraph(x.c_str());\n}\nSDL_Surface *loadimage(SDL_Surface * a, int x, int y, int r, int z)\n{\n    return DerivationGraph(x, y, r, z, a);\n}\nvoid drawimage(SDL_Surface * mx, int a, int b)\n{\n    if (mirror == 0)\n\tDrawGraph(a, b, mx, TRUE);\n    if (mirror == 1)\n\tDrawTurnGraph(a, b, mx, TRUE);\n}\nvoid drawimage(SDL_Surface * mx, int a, int b, int c, int d, int e, int f)\n{\n    SDL_Surface *m;\n    m = DerivationGraph(c, d, e, f, mx);\n    if (mirror == 0)\n\tDrawGraph(a, b, m, TRUE);\n    if (mirror == 1)\n\tDrawTurnGraph(a, b, m, TRUE);\n    SDL_FreeSurface(m);\n}\n/*\nvoid str(char d[],int a,int b){\nDrawString(a,b,d,color);\n}\n*/\nvoid str(string x, int a, int b)\n{\n    DrawString(a, b, x.c_str(), color);\n    xx[2] = 4;\n}\n/*\nvoid strchange(string x,int a){\n}\n*/\n/*\nvoid str1(String c,int r,int b){\nint a=0,x=0;\nint d=6;\nx=r*d;\na=120-x/2;\ng.drawString(c,a,b);\n}\n*/\n/*\nchar str[] = \"12345\";\nint num;\nnum = atoi(str);\n*/\nvoid setfont(int a)\n{\n/*\nif (a==0)g.setFont(Font.getFont(Font.SIZE_TINY));\nif (a==1)g.setFont(Font.getFont(Font.SIZE_SMALL));\nif (a==2)g.setFont(Font.getFont(Font.SIZE_MEDIUM));\nif (a==3)g.setFont(Font.getFont(Font.SIZE_LARGE));\n*/\n}\nvoid ot(Mix_Chunk * x)\n{\n    PlaySoundMem(x, DX_PLAYTYPE_BACK);\n}\nvoid stagecls()\n{\n    for (t = 0; t < smax; t++) {\n\tsa[t] = -9000000;\n\tsb[t] = 1;\n\tsc[t] = 1;\n\tsd[t] = 1;\n\tsgtype[t] = 0;\n\tstype[t] = 0;\n\tsxtype[t] = 0;\n    }\n    for (t = 0; t < tmax; t++) {\n\tta[t] = -9000000;\n\ttb[t] = 1;\n\ttc[t] = 1;\n\ttd[t] = 1;\n\ttitem[t] = 0;\n\ttxtype[t] = 0;\n    }\n    for (t = 0; t < srmax; t++) {\n\tsra[t] = -9000000;\n\tsrb[t] = 1;\n\tsrc[t] = 1;\n\tsrd[t] = 1;\n\tsre[t] = 0;\n\tsrf[t] = 0;\n\tsrmuki[t] = 0;\n\tsron[t] = 0;\n\tsree[t] = 0;\n\tsrsok[t] = 0;\n\tsrmove[t] = 0;\n\tsrmovep[t] = 0;\n\tsrsp[t] = 0;\n    }\n    for (t = 0; t < amax; t++) {\n\taa[t] = -9000000;\n\tab[t] = 1;\n\tac[t] = 0;\n\tad[t] = 1;\n\tazimentype[t] = 0;\n\tatype[t] = 0;\n\taxtype[t] = 0;\n\tae[t] = 0;\n\taf[t] = 0;\n\tatm[t] = 0;\n\ta2tm[t] = 0;\n\tabrocktm[t] = 0;\n\tamsgtm[t] = 0;\n    }\n    for (t = 0; t < bmax; t++) {\n\tba[t] = -9000000;\n\tbb[t] = 1;\n\tbz[t] = 1;\n\tbtm[t] = 0;\n\tbxtype[t] = 0;\n    }\n    for (t = 0; t < emax; t++) {\n\tea[t] = -9000000;\n\teb[t] = 1;\n\tec[t] = 1;\n\ted[t] = 1;\n\tegtype[t] = 0;\n    }\n    for (t = 0; t < nmax; t++) {\n\tna[t] = -9000000;\n\tnb[t] = 1;\n\tnc[t] = 1;\n\tnd[t] = 1;\n\tne[t] = 1;\n\tnf[t] = 1;\n\tng[t] = 0;\n\tntype[t] = 0;\n    }\n    sco = 0;\n    tco = 0;\n    aco = 0;\n    bco = 0;\n    eco = 0;\n    nco = 0;\n}\nvoid stage()\n{\n    scrollx = 3600 * 100;\n    stagep();\n    for (tt = 0; tt <= 1000; tt++) {\n\tfor (t = 0; t <= 16; t++) {\n\t    xx[10] = 0;\n\t    if (stagedate[t][tt] >= 1 && stagedate[t][tt] <= 255)\n\t\txx[10] = (int) stagedate[t][tt];\n\t    xx[21] = tt * 29;\n\t    xx[22] = t * 29 - 12;\n\t    xx[23] = xx[10];\n\t    if (xx[10] >= 1 && xx[10] <= 19 && xx[10] != 9) {\n\t\ttyobi(tt * 29, t * 29 - 12, xx[10]);\n\t    }\n\t    if (xx[10] >= 20 && xx[10] <= 29) {\n\t\tsra[srco] = xx[21] * 100;\n\t\tsrb[srco] = xx[22] * 100;\n\t\tsrc[srco] = 3000;\n\t\tsrtype[srco] = 0;\n\t\tsrco++;\n\t\tif (srco >= srmax)\n\t\t    srco = 0;\n\t    }\n\t    if (xx[10] == 30) {\n\t\tsa[sco] = xx[21] * 100;\n\t\tsb[sco] = xx[22] * 100;\n\t\tsc[sco] = 3000;\n\t\tsd[sco] = 6000;\n\t\tstype[sco] = 500;\n\t\tsco++;\n\t\tif (sco >= smax)\n\t\t    sco = 0;\n\t    }\n\t    if (xx[10] == 40) {\n\t\tsa[sco] = xx[21] * 100;\n\t\tsb[sco] = xx[22] * 100;\n\t\tsc[sco] = 6000;\n\t\tsd[sco] = 3000;\n\t\tstype[sco] = 1;\n\t\tsco++;\n\t\tif (sco >= smax)\n\t\t    sco = 0;\n\t    }\n\t    if (xx[10] == 41) {\n\t\tsa[sco] = xx[21] * 100 + 500;\n\t\tsb[sco] = xx[22] * 100;\n\t\tsc[sco] = 5000;\n\t\tsd[sco] = 3000;\n\t\tstype[sco] = 2;\n\t\tsco++;\n\t\tif (sco >= smax)\n\t\t    sco = 0;\n\t    }\n\t    if (xx[10] == 43) {\n\t\tsa[sco] = xx[21] * 100;\n\t\tsb[sco] = xx[22] * 100 + 500;\n\t\tsc[sco] = 2900;\n\t\tsd[sco] = 5300;\n\t\tstype[sco] = 1;\n\t\tsco++;\n\t\tif (sco >= smax)\n\t\t    sco = 0;\n\t    }\n\t    if (xx[10] == 44) {\n\t\tsa[sco] = xx[21] * 100;\n\t\tsb[sco] = xx[22] * 100 + 700;\n\t\tsc[sco] = 3900;\n\t\tsd[sco] = 5000;\n\t\tstype[sco] = 5;\n\t\tsco++;\n\t\tif (sco >= smax)\n\t\t    sco = 0;\n\t    }\n\t    if (xx[10] >= 50 && xx[10] <= 79) {\n\t\tba[bco] = xx[21] * 100;\n\t\tbb[bco] = xx[22] * 100;\n\t\tbtype[bco] = xx[23] - 50;\n\t\tbco++;\n\t\tif (bco >= bmax)\n\t\t    bco = 0;\n\t    }\n\t    if (xx[10] >= 80 && xx[10] <= 89) {\n\t\tna[nco] = xx[21] * 100;\n\t\tnb[nco] = xx[22] * 100;\n\t\tntype[nco] = xx[23] - 80;\n\t\tnco++;\n\t\tif (nco >= nmax)\n\t\t    nco = 0;\n\t    }\n\t    if (xx[10] == 9) {\n\t\ttyobi(tt * 29, t * 29 - 12, 800);\n\t    }\n\t    if (xx[10] == 99) {\n\t\tsa[sco] = xx[21] * 100;\n\t\tsb[sco] = xx[22] * 100;\n\t\tsc[sco] = 3000;\n\t\tsd[sco] = (12 - t) * 3000;\n\t\tstype[sco] = 300;\n\t\tsco++;\n\t\tif (sco >= smax)\n\t\t    sco = 0;\n\t    }\n\t}\n    }\n    if (tyuukan >= 1) {\n\txx[17] = 0;\n\tfor (t = 0; t < smax; t++) {\n\t    if (stype[t] == 500 && tyuukan >= 1) {\n\t\tfx = sa[t] - fxmax / 2;\n\t\tfzx = fx;\n\t\tma = sa[t] - fx;\n\t\tmb = sb[t] - fy;\n\t\ttyuukan--;\n\t\txx[17]++;\n\t\tsa[t] = -80000000;\n\t    }\n\t}\n\ttyuukan += xx[17];\n    }\n}\nvoid stagep()\n{\n    scrollx = 3600 * 100;\n    if (sta == 1 && stb == 1 && stc == 0) {\n\tbyte stagedatex[17][1001] = {\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     82, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 82,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     98, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 98, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 98, 98, 98, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 98, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 7,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 4,\n\t     4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     30, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 4,\n\t     4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 98, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 4,\n\t     4, 4,\n\t     4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 98, 0, 0, 0, 1, 98, 1, 2, 1, 0,\n\t     0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     7, 0, 0,\n\t     0, 0,\n\t     0, 1, 98, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 98, 0, 0, 0,\n\t     0, 0,\n\t     0, 1,\n\t     98, 0, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 1, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     4, 4,\n\t     4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0}\n\t    ,\n\t    {0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0,\n\t     0, 0,\n\t     40, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,\n\t     0, 0, 4,\n\t     0, 7,\n\t     7, 7, 7, 7, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 4,\n\t     4, 4, 4,\n\t     4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0,\n\t     0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     41, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0,\n\t     0, 4, 4,\n\t     0, 0,\n\t     0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 4,\n\t     4, 4,\n\t     4, 4,\n\t     4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 0, 0, 0, 0, 50, 0,\n\t     0, 81,\n\t     41, 0,\n\t     0, 0, 0, 0, 81, 98, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0,\n\t     0, 0, 81, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50,\n\t     0, 50,\n\t     0, 0,\n\t     51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81, 0, 0, 0, 4, 4,\n\t     4, 0,\n\t     0, 0,\n\t     4, 4, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 50, 0, 50, 0,\n\t     0, 41,\n\t     0, 4, 4,\n\t     4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 4, 81, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0}\n\t    ,\n\t    {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0,\n\t     0, 0, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0,\n\t     0, 5, 5,\n\t     5, 5,\n\t     5, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 0,\n\t     5, 5, 5, 5, 5, 5, 5}\n\t    ,\n\t    {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0,\n\t     0, 0, 6,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0,\n\t     0, 6, 6,\n\t     6, 6,\n\t     6, 6, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 0,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t};\n\ttyobi(8 * 29, 9 * 29 - 12, 100);\n\ttxtype[tco] = 2;\n\ttyobi(13 * 29, 9 * 29 - 12, 102);\n\ttxtype[tco] = 0;\n\ttyobi(14 * 29, 5 * 29 - 12, 101);\n\ttyobi(35 * 29, 8 * 29 - 12, 110);\n\ttyobi(47 * 29, 9 * 29 - 12, 103);\n\ttyobi(59 * 29, 9 * 29 - 12, 112);\n\ttyobi(67 * 29, 9 * 29 - 12, 104);\n\tsco = 0;\n\tt = sco;\n\tsa[t] = 20 * 29 * 100 + 500;\n\tsb[t] = -6000;\n\tsc[t] = 5000;\n\tsd[t] = 70000;\n\tstype[t] = 100;\n\tsco++;\n\tt = sco;\n\tsa[t] = 54 * 29 * 100 - 500;\n\tsb[t] = -6000;\n\tsc[t] = 7000;\n\tsd[t] = 70000;\n\tstype[t] = 101;\n\tsco++;\n\tt = sco;\n\tsa[t] = 112 * 29 * 100 + 1000;\n\tsb[t] = -6000;\n\tsc[t] = 3000;\n\tsd[t] = 70000;\n\tstype[t] = 102;\n\tsco++;\n\tt = sco;\n\tsa[t] = 117 * 29 * 100;\n\tsb[t] = (2 * 29 - 12) * 100 - 1500;\n\tsc[t] = 15000;\n\tsd[t] = 3000;\n\tstype[t] = 103;\n\tsco++;\n\tt = sco;\n\tsa[t] = 125 * 29 * 100;\n\tsb[t] = -6000;\n\tsc[t] = 9000;\n\tsd[t] = 70000;\n\tstype[t] = 101;\n\tsco++;\n\tt = 28;\n\tsa[t] = 29 * 29 * 100 + 500;\n\tsb[t] = (9 * 29 - 12) * 100;\n\tsc[t] = 6000;\n\tsd[t] = 12000 - 200;\n\tstype[t] = 50;\n\tsco++;\n\tt = sco;\n\tsa[t] = 49 * 29 * 100;\n\tsb[t] = (5 * 29 - 12) * 100;\n\tsc[t] = 9000 - 1;\n\tsd[t] = 3000;\n\tstype[t] = 51;\n\tsgtype[t] = 0;\n\tsco++;\n\tt = sco;\n\tsa[t] = 72 * 29 * 100;\n\tsb[t] = (13 * 29 - 12) * 100;\n\tsc[t] = 3000 * 5 - 1;\n\tsd[t] = 3000;\n\tstype[t] = 52;\n\tsco++;\n\tbco = 0;\n\tt = bco;\n\tba[t] = 27 * 29 * 100;\n\tbb[t] = (9 * 29 - 12) * 100;\n\tbtype[t] = 0;\n\tbxtype[t] = 0;\n\tbco++;\n\tt = bco;\n\tba[t] = 103 * 29 * 100;\n\tbb[t] = (5 * 29 - 12 + 10) * 100;\n\tbtype[t] = 80;\n\tbxtype[t] = 0;\n\tbco++;\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n    if (sta == 1 && stb == 2 && stc == 0) {\n\tbgmchange(otom[1]);\n\tscrollx = 0 * 100;\n\tbyte stagedatex[17][1001] = {\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 7}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0,\n\t     0, 0, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0,\n\t     0, 5, 5,\n\t     5, 5,\n\t     5, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 0,\n\t     5, 5, 5, 5, 5, 5, 5}\n\t    ,\n\t    {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0,\n\t     0, 0, 6,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0,\n\t     0, 6, 6,\n\t     6, 6,\n\t     6, 6, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 0,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t};\n\ttco = 0;\n\ttxtype[tco] = 1;\n\ttyobi(4 * 29, 9 * 29 - 12, 300);\n\ttyobi(13 * 29, 8 * 29 - 12, 114);\n\tsco = 0;\n\tt = sco;\n\tsa[t] = 14 * 29 * 100 + 500;\n\tsb[t] = (9 * 29 - 12) * 100;\n\tsc[t] = 6000;\n\tsd[t] = 12000 - 200;\n\tstype[t] = 50;\n\tsxtype[t] = 1;\n\tsco++;\n\tt = sco;\n\tsa[t] = 12 * 29 * 100;\n\tsb[t] = (11 * 29 - 12) * 100;\n\tsc[t] = 3000;\n\tsd[t] = 6000 - 200;\n\tstype[t] = 40;\n\tsxtype[t] = 0;\n\tsco++;\n\tt = sco;\n\tsa[t] = 14 * 29 * 100 + 1000;\n\tsb[t] = -6000;\n\tsc[t] = 5000;\n\tsd[t] = 70000;\n\tstype[t] = 100;\n\tsxtype[t] = 1;\n\tsco++;\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n    if (sta == 1 && stb == 2 && stc == 1) {\n\tbgmchange(otom[2]);\n\tscrollx = 4080 * 100;\n\tma = 6000;\n\tmb = 3000;\n\tstagecolor = 2;\n\tbyte stagedatex[17][1001] = {\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 1, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 98, 0,\n\t     1, 1,\n\t     1, 1, 1,\n\t     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,\n\t     0, 1, 0}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 1, 0}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 1, 0}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 1, 0}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 4, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 1, 0}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 1, 0}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 44, 0, 0,\n\t     1, 1,\n\t     1, 1,\n\t     1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 1,\n\t     0}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 7, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 54, 0, 1,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 1, 0}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 98, 2, 2, 98, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     4, 7,\n\t     7, 7, 7, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 98, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 4, 4, 4,\n\t     1, 1, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 1,\n\t     0}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 4,\n\t     0, 0,\n\t     0, 0, 4, 0, 4, 0, 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 1, 4, 4, 4, 4, 1,\n\t     1, 1, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 1, 0}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,\n\t     4, 0, 4,\n\t     0, 0,\n\t     0, 0, 4, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 30, 0, 0,\n\t     0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 4, 4, 4, 4,\n\t     1, 1, 1,\n\t     1, 0,\n\t     0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 1,\n\t     0}\n\t    ,\n\t    {1, 0, 7, 0, 0, 0, 0, 0, 0, 0, 50, 0, 50, 0, 4, 0, 4, 0,\n\t     4, 0,\n\t     4, 0,\n\t     50, 0, 0, 4, 0, 4, 0, 4, 0, 4, 0, 0, 0, 0, 50, 50, 50,\n\t     7, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 4, 4, 4,\n\t     4, 1, 1,\n\t     1, 1,\n\t     1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,\n\t     1, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     1, 0}\n\t    ,\n\t    {5, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 0,\n\t     0, 0,\n\t     5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 5, 5, 0, 0,\n\t     0, 0, 5,\n\t     5, 5,\n\t     5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 0}\n\t    ,\n\t    {6, 6, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 0,\n\t     0, 0,\n\t     6, 6, 6, 0, 0, 0, 6, 6, 6, 6, 6, 6, 0, 0, 6, 6, 0, 0,\n\t     0, 0, 6,\n\t     6, 6,\n\t     6, 6, 6, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 0,\n\t     0, 0,\n\t     0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0}\n\t    ,\n\t};\n\ttco = 0;\n\ttxtype[tco] = 2;\n\ttyobi(7 * 29, 9 * 29 - 12, 102);\n\ttyobi(10 * 29, 9 * 29 - 12, 101);\n\ttxtype[tco] = 2;\n\ttyobi(49 * 29, 9 * 29 - 12, 114);\n\tfor (t = 0; t >= -7; t--) {\n\t    tyobi(53 * 29, t * 29 - 12, 1);\n\t}\n\ttxtype[tco] = 1;\n\ttyobi(80 * 29, 5 * 29 - 12, 104);\n\ttxtype[tco] = 2;\n\ttyobi(78 * 29, 5 * 29 - 12, 102);\n\tsco = 0;\n\tt = sco;\n\tsa[t] = 2 * 29 * 100;\n\tsb[t] = (13 * 29 - 12) * 100;\n\tsc[t] = 3000 * 1 - 1;\n\tsd[t] = 3000;\n\tstype[t] = 52;\n\tsco++;\n\tt = sco;\n\tsa[t] = 24 * 29 * 100;\n\tsb[t] = (13 * 29 - 12) * 100;\n\tsc[t] = 3000 * 1 - 1;\n\tsd[t] = 3000;\n\tstype[t] = 52;\n\tsco++;\n\tt = sco;\n\tsa[t] = 43 * 29 * 100 + 500;\n\tsb[t] = -6000;\n\tsc[t] = 3000;\n\tsd[t] = 70000;\n\tstype[t] = 102;\n\tsxtype[t] = 1;\n\tsco++;\n\tt = sco;\n\tsa[t] = 53 * 29 * 100 + 500;\n\tsb[t] = -6000;\n\tsc[t] = 3000;\n\tsd[t] = 70000;\n\tstype[t] = 102;\n\tsxtype[t] = 2;\n\tsco++;\n\tt = sco;\n\tsa[t] = 129 * 29 * 100;\n\tsb[t] = (7 * 29 - 12) * 100;\n\tsc[t] = 3000;\n\tsd[t] = 6000 - 200;\n\tstype[t] = 40;\n\tsxtype[t] = 2;\n\tsco++;\n\tt = sco;\n\tsa[t] = 154 * 29 * 100;\n\tsb[t] = 3000;\n\tsc[t] = 9000;\n\tsd[t] = 3000;\n\tstype[t] = 102;\n\tsxtype[t] = 7;\n\tsco++;\n\tt = 27;\n\tsa[t] = 69 * 29 * 100;\n\tsb[t] = (1 * 29 - 12) * 100;\n\tsc[t] = 9000 * 2 - 1;\n\tsd[t] = 3000;\n\tstype[t] = 51;\n\tsxtype[t] = 0;\n\tsgtype[t] = 0;\n\tsco++;\n\tt = 28;\n\tsa[t] = 66 * 29 * 100;\n\tsb[t] = (1 * 29 - 12) * 100;\n\tsc[t] = 9000 - 1;\n\tsd[t] = 3000;\n\tstype[t] = 51;\n\tsxtype[t] = 1;\n\tsgtype[t] = 0;\n\tsco++;\n\tt = 29;\n\tsa[t] = 66 * 29 * 100;\n\tsb[t] = (-2 * 29 - 12) * 100;\n\tsc[t] = 9000 * 3 - 1;\n\tsd[t] = 3000;\n\tstype[t] = 51;\n\tsxtype[t] = 2;\n\tsgtype[t] = 0;\n\tsco++;\n\tt = 26;\n\tsa[t] = 103 * 29 * 100 - 1500;\n\tsb[t] = (9 * 29 - 12) * 100 - 2000;\n\tsc[t] = 3000;\n\tsd[t] = 3000;\n\tstype[t] = 180;\n\tsxtype[t] = 0;\n\tsr[t] = 0;\n\tsgtype[t] = 48;\n\tsco++;\n\tt = sco;\n\tsa[t] = 102 * 29 * 100;\n\tsb[t] = (9 * 29 - 12) * 100;\n\tsc[t] = 6000;\n\tsd[t] = 12000 - 200;\n\tstype[t] = 50;\n\tsxtype[t] = 2;\n\tsco++;\n\tt = sco;\n\tsa[t] = 123 * 29 * 100;\n\tsb[t] = (9 * 29 - 12) * 100;\n\tsc[t] = 3000 * 5 - 1;\n\tsd[t] = 3000 * 5;\n\tstype[t] = 52;\n\tsxtype[t] = 1;\n\tsco++;\n\tt = sco;\n\tsa[t] = 131 * 29 * 100;\n\tsb[t] = (1 * 29 - 12) * 100;\n\tsc[t] = 4700;\n\tsd[t] = 3000 * 8 - 700;\n\tstype[t] = 1;\n\tsxtype[t] = 0;\n\tsco++;\n\tt = sco;\n\tsa[t] = 143 * 29 * 100;\n\tsb[t] = (9 * 29 - 12) * 100;\n\tsc[t] = 6000;\n\tsd[t] = 12000 - 200;\n\tstype[t] = 50;\n\tsxtype[t] = 5;\n\tsco++;\n\tt = sco;\n\tsa[t] = 148 * 29 * 100;\n\tsb[t] = (9 * 29 - 12) * 100;\n\tsc[t] = 6000;\n\tsd[t] = 12000 - 200;\n\tstype[t] = 50;\n\tsxtype[t] = 5;\n\tsco++;\n\tt = sco;\n\tsa[t] = 153 * 29 * 100;\n\tsb[t] = (9 * 29 - 12) * 100;\n\tsc[t] = 6000;\n\tsd[t] = 12000 - 200;\n\tstype[t] = 50;\n\tsxtype[t] = 5;\n\tsco++;\n\tbco = 0;\n\tt = bco;\n\tba[t] = 18 * 29 * 100;\n\tbb[t] = (10 * 29 - 12) * 100;\n\tbtype[t] = 82;\n\tbxtype[t] = 1;\n\tbco++;\n\tt = bco;\n\tba[t] = 51 * 29 * 100 + 1000;\n\tbb[t] = (2 * 29 - 12 + 10) * 100;\n\tbtype[t] = 80;\n\tbxtype[t] = 1;\n\tbco++;\n\tt = bco;\n\tba[t] = 96 * 29 * 100 + 100;\n\tbb[t] = (10 * 29 - 12) * 100;\n\tbtype[t] = 105;\n\tbxtype[t] = 0;\n\tbco++;\n\tsrco = 0;\n\tt = srco;\n\tsra[t] = 111 * 29 * 100;\n\tsrb[t] = (8 * 29 - 12) * 100;\n\tsrc[t] = 90 * 100;\n\tsrtype[t] = 0;\n\tsracttype[t] = 5;\n\tsre[t] = -300;\n\tsrco++;\n\tt = srco;\n\tsra[t] = 111 * 29 * 100;\n\tsrb[t] = (0 * 29 - 12) * 100;\n\tsrc[t] = 90 * 100;\n\tsrtype[t] = 0;\n\tsracttype[t] = 5;\n\tsre[t] = -300;\n\tsrco++;\n\tt = 10;\n\tsra[t] = 116 * 29 * 100;\n\tsrb[t] = (4 * 29 - 12) * 100;\n\tsrc[t] = 90 * 100;\n\tsrtype[t] = 1;\n\tsracttype[t] = 5;\n\tsre[t] = 300;\n\tsrco++;\n\tt = 11;\n\tsra[t] = 116 * 29 * 100;\n\tsrb[t] = (12 * 29 - 12) * 100;\n\tsrc[t] = 90 * 100;\n\tsrtype[t] = 1;\n\tsracttype[t] = 5;\n\tsre[t] = 300;\n\tsrco++;\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n    if (sta == 1 && stb == 2 && stc == 2) {\n\tbgmchange(otom[1]);\n\tscrollx = 900 * 100;\n\tma = 7500;\n\tmb = 3000 * 9;\n\tbyte stagedatex[17][1001] = {\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 0, 0, 0, 0,\n\t     0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0,}\n\t    ,\n\t    {0, 0, 40, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 41, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\t     4, 4,\n\t     4, 0, 0,\n\t     0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81,}\n\t    ,\n\t    {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0,\n\t     0, 5, 5,\n\t     5, 5,\n\t     5, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 0,\n\t     5, 5, 5, 5, 5, 5, 5}\n\t    ,\n\t    {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0,\n\t     0, 6, 6,\n\t     6, 6,\n\t     6, 6, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 0,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t};\n/*\ntyobi(13*29,8*29-12,114);\nsco=0;\nt=sco;sa[t]=14*29*100+500;sb[t]=(9*29-12)*100;sc[t]=6000;sd[t]=12000-200;stype[t]=50;sxtype[t]=1;sco++;\nt=sco;sa[t]=12*29*100;sb[t]=(11*29-12)*100;sc[t]=3000;sd[t]=6000-200;stype[t]=40;sxtype[t]=0;sco++;\nt=sco;sa[t]=14*29*100+1000;sb[t]=-6000;sc[t]=5000;sd[t]=70000;stype[t]=100;sxtype[t]=1;sco++;\n*/\n\tt = sco;\n\tsa[t] = 5 * 29 * 100 + 500;\n\tsb[t] = -6000;\n\tsc[t] = 3000;\n\tsd[t] = 70000;\n\tstype[t] = 102;\n\tsxtype[t] = 8;\n\tsco++;\n\tt = 28;\n\tsa[t] = 44 * 29 * 100 + 500;\n\tsb[t] = (10 * 29 - 12) * 100;\n\tsc[t] = 6000;\n\tsd[t] = 9000 - 200;\n\tstype[t] = 50;\n\tsco++;\n\tbco = 0;\n\tt = bco;\n\tba[t] = 19 * 29 * 100;\n\tbb[t] = (2 * 29 - 12) * 100;\n\tbtype[t] = 85;\n\tbxtype[t] = 0;\n\tbco++;\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n    if (sta == 1 && stb == 3 && stc == 6) {\n\tstc = 0;\n    }\n    if (sta == 1 && stb == 3 && stc == 0) {\n\tbgmchange(otom[1]);\n\tscrollx = 3900 * 100;\n\tbyte stagedatex[17][1001] = {\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 97,\n\t     0, 0, 0,\n\t     0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 84, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 57, 0, 0, 0, 84, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 84, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     82, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 84, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51, 0, 0, 0, 84,\n\t     0, 0,\n\t     0, 0,\n\t     0, 99, 0, 0, 0, 0, 0, 0, 82, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     97, 0, 0,\n\t     0, 0, 0, 0, 57, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 1,\n\t     1, 1,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     30, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     7, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     84, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 84, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     1, 1, 1,\n\t     1, 1,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 30, 0, 0,\n\t     0, 0,\n\t     0, 0,\n\t     85, 85, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 4, 4, 4,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 81, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81, 0, 0,\n\t     0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 81, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,\n\t     81, 0,\n\t     0, 0,\n\t     0, 50, 0, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4,\n\t     0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     81, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0}\n\t    ,\n\t    {5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5,\n\t     0, 0, 0,\n\t     5, 5,\n\t     5, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 6, 6, 6, 6, 6, 6,\n\t     0, 0, 0,\n\t     6, 6,\n\t     6, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t};\n\ttco = 0;\n\ttyobi(22 * 29, 3 * 29 - 12, 1);\n\ttyobi(54 * 29, 9 * 29 - 12, 116);\n\ttyobi(18 * 29, 14 * 29 - 12, 117);\n\ttyobi(19 * 29, 14 * 29 - 12, 117);\n\ttyobi(20 * 29, 14 * 29 - 12, 117);\n\ttxtype[tco] = 1;\n\ttyobi(61 * 29, 9 * 29 - 12, 101);\n\ttyobi(74 * 29, 9 * 29 - 12, 7);\n\ttxtype[tco] = 2;\n\ttyobi(28 * 29, 9 * 29 - 12, 300);\n\ttxtype[tco] = 3;\n\ttyobi(7 * 29, 9 * 29 - 12, 101);\n\ttxtype[tco] = 4;\n\ttyobi(70 * 29, 8 * 29 - 12, 300);\n\ttxtype[tco] = 1;\n\ttyobi(58 * 29, 13 * 29 - 12, 115);\n\ttxtype[tco] = 1;\n\ttyobi(59 * 29, 13 * 29 - 12, 115);\n\ttxtype[tco] = 1;\n\ttyobi(60 * 29, 13 * 29 - 12, 115);\n\ttxtype[tco] = 0;\n\ttyobi(111 * 29, 6 * 29 - 12, 301);\n\ttxtype[tco] = 0;\n\ttyobi(114 * 29, 9 * 29 - 12, 120);\n\tbco = 0;\n\tt = bco;\n\tba[t] = 101 * 29 * 100;\n\tbb[t] = (5 * 29 - 12) * 100;\n\tbtype[t] = 4;\n\tbxtype[t] = 1;\n\tbco++;\n\tt = bco;\n\tba[t] = 146 * 29 * 100;\n\tbb[t] = (10 * 29 - 12) * 100;\n\tbtype[t] = 6;\n\tbxtype[t] = 1;\n\tbco++;\n\tt = sco;\n\tsa[t] = 9 * 29 * 100;\n\tsb[t] = (13 * 29 - 12) * 100;\n\tsc[t] = 9000 - 1;\n\tsd[t] = 3000;\n\tstype[t] = 52;\n\tsco++;\n\tt = sco;\n\tsa[t] = 65 * 29 * 100 + 500;\n\tsb[t] = (10 * 29 - 12) * 100;\n\tsc[t] = 6000;\n\tsd[t] = 9000 - 200;\n\tstype[t] = 50;\n\tsxtype[t] = 1;\n\tsco++;\n\tt = sco;\n\tsa[t] = 74 * 29 * 100;\n\tsb[t] = (8 * 29 - 12) * 100 - 1500;\n\tsc[t] = 6000;\n\tsd[t] = 3000;\n\tstype[t] = 103;\n\tsxtype[t] = 1;\n\tsco++;\n\tt = sco;\n\tsa[t] = 96 * 29 * 100 - 3000;\n\tsb[t] = -6000;\n\tsc[t] = 9000;\n\tsd[t] = 70000;\n\tstype[t] = 102;\n\tsxtype[t] = 10;\n\tsco++;\n\tt = sco;\n\tsa[t] = 131 * 29 * 100 - 1500;\n\tsb[t] = (1 * 29 - 12) * 100 - 3000;\n\tsc[t] = 15000;\n\tsd[t] = 14000;\n\tstype[t] = 104;\n\tsco++;\n\tt = bco;\n\tba[t] = 10 * 29 * 100 + 100;\n\tbb[t] = (11 * 29 - 12) * 100;\n\tbtype[t] = 105;\n\tbxtype[t] = 1;\n\tbco++;\n\tt = bco;\n\tba[t] = 43 * 29 * 100;\n\tbb[t] = (11 * 29 - 12) * 100;\n\tbtype[t] = 82;\n\tbxtype[t] = 1;\n\tbco++;\n\tt = bco;\n\tba[t] = 1 * 29 * 100;\n\tbb[t] = (2 * 29 - 12 + 10) * 100 - 1000;\n\tbtype[t] = 80;\n\tbxtype[t] = 0;\n\tbco++;\n\tsrco = 0;\n\tt = srco;\n\tsra[t] = 33 * 29 * 100;\n\tsrb[t] = (3 * 29 - 12) * 100;\n\tsrc[t] = 90 * 100;\n\tsrtype[t] = 0;\n\tsracttype[t] = 0;\n\tsre[t] = 0;\n\tsrsp[t] = 1;\n\tsrco++;\n\tt = srco;\n\tsra[t] = 39 * 29 * 100 - 2000;\n\tsrb[t] = (6 * 29 - 12) * 100;\n\tsrc[t] = 90 * 100;\n\tsrtype[t] = 0;\n\tsracttype[t] = 1;\n\tsre[t] = 0;\n\tsrco++;\n\tt = srco;\n\tsra[t] = 45 * 29 * 100 + 1500;\n\tsrb[t] = (10 * 29 - 12) * 100;\n\tsrc[t] = 90 * 100;\n\tsrtype[t] = 0;\n\tsracttype[t] = 0;\n\tsre[t] = 0;\n\tsrsp[t] = 2;\n\tsrco++;\n\tt = srco;\n\tsra[t] = 95 * 29 * 100;\n\tsrb[t] = (7 * 29 - 12) * 100;\n\tsrc[t] = 180 * 100;\n\tsrtype[t] = 0;\n\tsracttype[t] = 0;\n\tsre[t] = 0;\n\tsrsp[t] = 10;\n\tsrco++;\n\tt = srco;\n\tsra[t] = 104 * 29 * 100;\n\tsrb[t] = (9 * 29 - 12) * 100;\n\tsrc[t] = 90 * 100;\n\tsrtype[t] = 0;\n\tsracttype[t] = 0;\n\tsre[t] = 0;\n\tsrsp[t] = 12;\n\tsrco++;\n\tt = srco;\n\tsra[t] = 117 * 29 * 100;\n\tsrb[t] = (3 * 29 - 12) * 100;\n\tsrc[t] = 90 * 100;\n\tsrtype[t] = 0;\n\tsracttype[t] = 1;\n\tsre[t] = 0;\n\tsrsp[t] = 15;\n\tsrco++;\n\tt = srco;\n\tsra[t] = 124 * 29 * 100;\n\tsrb[t] = (5 * 29 - 12) * 100;\n\tsrc[t] = 210 * 100;\n\tsrtype[t] = 0;\n\tsracttype[t] = 0;\n\tsre[t] = 0;\n\tsrsp[t] = 10;\n\tsrco++;\n\tif (stagepoint == 1) {\n\t    stagepoint = 0;\n\t    ma = 4500;\n\t    mb = -3000;\n\t    tyuukan = 0;\n\t}\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n    if (sta == 1 && stb == 3 && stc == 1) {\n\tbgmchange(otom[2]);\n\tscrollx = 0 * 100;\n\tma = 6000;\n\tmb = 6000;\n\tstagecolor = 2;\n\tbyte stagedatex[17][1001] = {\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,\n\t     0, 0}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,}\n\t    ,\n\t    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,}\n\t    ,\n\t    {1, 54, 0, 54, 0, 54, 0, 54, 0, 54, 0, 54, 0, 54, 0, 54,\n\t     1, 0,}\n\t    ,\n\t    {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 8,\n\t     8, 8, 8,}\n\t    ,\n\t    {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t};\n\ttco = 0;\n\tstc = 0;\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n    if (sta == 1 && stb == 3 && stc == 5) {\n\tstagecolor = 3;\n\tbgmchange(otom[3]);\n\tscrollx = 0 * 100;\n\tma = 3000;\n\tmb = 33000;\n\tstagepoint = 1;\n\tbyte stagedatex[17][1001] = {\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 9, 0, 9, 0, 9, 0, 9, 0, 9, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 9, 0, 9, 0, 9, 0, 9, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 9, 0, 9, 0, 9, 0, 9, 0, 9, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}\n\t    ,\n\t    {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 8, 8,\n\t     8, 8, 8,}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t};\n\tsco = 0;\n\tt = sco;\n\tsa[t] = 14 * 29 * 100 - 5;\n\tsb[t] = (11 * 29 - 12) * 100;\n\tsc[t] = 6000;\n\tsd[t] = 15000 - 200;\n\tstype[t] = 50;\n\tsxtype[t] = 1;\n\tsco++;\n\ttxtype[tco] = 0;\n\ttyobi(12 * 29, 4 * 29 - 12, 112);\n\ttxtype[tco] = 3;\n\ttyobi(12 * 29, 8 * 29 - 12, 300);\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n    if (sta == 1 && stb == 4 && stc == 0) {\n\tbgmchange(otom[4]);\n\tscrollx = 4400 * 100;\n\tma = 12000;\n\tmb = 6000;\n\tstagecolor = 4;\n\tbyte stagedatex[17][1001] = {\n\t    {5, 5, 5, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 5, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {5, 5, 5, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 5, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     7, 7, 7, 7, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0}\n\t    ,\n\t    {5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 5, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 5, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 5,\n\t     5, 5,\n\t     5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     60, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 60, 0, 0, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 5, 0, 0,\n\t     5, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 5, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 0, 0, 30, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0,\n\t     5, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     2, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     5, 5, 0,\n\t     0, 0,\n\t     0, 0, 0, 7, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,\n\t     5, 5, 5,\n\t     0, 0,\n\t     0, 3, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 7, 7, 2, 2, 7, 5,\n\t     5, 5, 5,\n\t     0, 0,\n\t     0, 3, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     5, 5, 5,\n\t     5, 5,\n\t     0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,\n\t     5, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0,\n\t     0, 0, 0,\n\t     59, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,\n\t     5, 5, 5,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5,\n\t     5, 5, 5,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     5, 5, 5,\n\t     5, 5,\n\t     0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,\n\t     5, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 5, 5, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,\n\t     5, 5, 5,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5,\n\t     5, 5, 5,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     5, 5, 5,\n\t     5, 5,\n\t     0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,\n\t     5, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 5, 5, 5,\n\t     5, 5, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0, 5,\n\t     5, 5,\n\t     5, 0, 0,\n\t     0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 0, 59, 0, 0, 0, 0, 0, 5,\n\t     5, 5,\n\t     5, 0, 0,\n\t     0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     5, 5, 5,\n\t     5, 5,\n\t     0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,\n\t     5, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 5, 5, 5,\n\t     5, 5, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 41, 0, 5, 5, 5, 5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 86, 0, 0, 86, 0, 5, 5, 5,\n\t     5, 5,\n\t     86, 0,\n\t     0, 86, 0, 0, 86, 0, 0, 86, 0, 0, 86, 0, 0, 86, 0, 0,\n\t     86, 0, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 86, 0, 0, 86, 5,\n\t     5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 86, 5, 5, 5, 5, 5, 86, 0, 0,\n\t     86, 0, 0,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 86, 0, 0, 86, 5, 5, 5, 5, 86, 0, 0, 86,\n\t     0, 5,\n\t     5, 5, 5,\n\t     5, 5, 5, 5, 5, 5, 86, 0, 5, 5, 86, 0, 0, 86, 0, 0, 86,\n\t     0, 0,\n\t     86, 0,\n\t     0, 86, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     41, 0,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 0, 0,\n\t     0, 0,\n\t     0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t};\n\tsco = 0;\n\tt = sco;\n\tsa[t] = 35 * 29 * 100 - 1500 + 750;\n\tsb[t] = (8 * 29 - 12) * 100 - 1500;\n\tsc[t] = 1500;\n\tsd[t] = 3000;\n\tstype[t] = 105;\n\tsco++;\n\tt = sco;\n\tsa[t] = 67 * 29 * 100;\n\tsb[t] = (4 * 29 - 12) * 100;\n\tsc[t] = 9000 - 1;\n\tsd[t] = 3000 * 1 - 1;\n\tstype[t] = 51;\n\tsxtype[t] = 3;\n\tsgtype[t] = 0;\n\tsco++;\n\tt = sco;\n\tsa[t] = 73 * 29 * 100;\n\tsb[t] = (13 * 29 - 12) * 100;\n\tsc[t] = 3000 * 1 - 1;\n\tsd[t] = 3000;\n\tstype[t] = 52;\n\tsco++;\n\tt = sco;\n\tsa[t] = 123 * 29 * 100;\n\tsb[t] = (1 * 29 - 12) * 100;\n\tsc[t] = 30 * 6 * 100 - 1 + 0;\n\tsd[t] = 3000 - 200;\n\tstype[t] = 51;\n\tsxtype[t] = 10;\n\tsco++;\n\tt = sco;\n\tsa[t] = 124 * 29 * 100 + 3000;\n\tsb[t] = (2 * 29 - 12) * 100;\n\tsc[t] = 3000 * 1 - 1;\n\tsd[t] = 300000;\n\tstype[t] = 102;\n\tsxtype[t] = 20;\n\tsco++;\n\tt = sco;\n\tsa[t] = 148 * 29 * 100 + 1000;\n\tsb[t] = (-12 * 29 - 12) * 100;\n\tsc[t] = 3000 * 1 - 1;\n\tsd[t] = 300000;\n\tstype[t] = 102;\n\tsxtype[t] = 30;\n\tsco++;\n\tt = sco;\n\tsa[t] = 100 * 29 * 100 + 1000;\n\tsb[t] = -6000;\n\tsc[t] = 3000;\n\tsd[t] = 70000;\n\tstype[t] = 102;\n\tsxtype[t] = 12;\n\tsco++;\n\tt = sco;\n\tsa[t] = 0 * 29 * 100 - 0;\n\tsb[t] = 9 * 29 * 100 + 1700;\n\tsc[t] = 3000 * 7 - 1;\n\tsd[t] = 3000 * 5 - 1;\n\tstype[t] = 200;\n\tsxtype[t] = 0;\n\tsco++;\n\tt = sco;\n\tsa[t] = 11 * 29 * 100;\n\tsb[t] = -1 * 29 * 100 + 1700;\n\tsc[t] = 3000 * 8 - 1;\n\tsd[t] = 3000 * 4 - 1;\n\tstype[t] = 200;\n\tsxtype[t] = 0;\n\tsco++;\n\tbco = 0;\n\tt = bco;\n\tba[t] = 8 * 29 * 100 - 1400;\n\tbb[t] = (2 * 29 - 12) * 100 + 500;\n\tbtype[t] = 86;\n\tbxtype[t] = 0;\n\tbco++;\n\tt = bco;\n\tba[t] = 42 * 29 * 100 - 1400;\n\tbb[t] = (-2 * 29 - 12) * 100 + 500;\n\tbtype[t] = 86;\n\tbxtype[t] = 0;\n\tbco++;\n\tt = bco;\n\tba[t] = 29 * 29 * 100 + 1500;\n\tbb[t] = (7 * 29 - 12) * 100 + 1500;\n\tbtype[t] = 87;\n\tbxtype[t] = 105;\n\tbco++;\n\tt = bco;\n\tba[t] = 47 * 29 * 100 + 1500;\n\tbb[t] = (9 * 29 - 12) * 100 + 1500;\n\tbtype[t] = 87;\n\tbxtype[t] = 110;\n\tbco++;\n\tt = bco;\n\tba[t] = 70 * 29 * 100 + 1500;\n\tbb[t] = (9 * 29 - 12) * 100 + 1500;\n\tbtype[t] = 87;\n\tbxtype[t] = 105;\n\tbco++;\n\tt = bco;\n\tba[t] = 66 * 29 * 100 + 1501;\n\tbb[t] = (4 * 29 - 12) * 100 + 1500;\n\tbtype[t] = 87;\n\tbxtype[t] = 101;\n\tbco++;\n\tt = bco;\n\tba[t] = 85 * 29 * 100 + 1501;\n\tbb[t] = (4 * 29 - 12) * 100 + 1500;\n\tbtype[t] = 87;\n\tbxtype[t] = 105;\n\tbco++;\n\tt = bco;\n\tba[t] = 57 * 29 * 100;\n\tbb[t] = (2 * 29 - 12 + 10) * 100 - 500;\n\tbtype[t] = 80;\n\tbxtype[t] = 1;\n\tbco++;\n\tt = bco;\n\tba[t] = 77 * 29 * 100;\n\tbb[t] = (5 * 29 - 12) * 100;\n\tbtype[t] = 82;\n\tbxtype[t] = 2;\n\tbco++;\n\tt = bco;\n\tba[t] = 130 * 29 * 100;\n\tbb[t] = (8 * 29 - 12) * 100;\n\tbtype[t] = 30;\n\tbxtype[t] = 0;\n\tbco++;\n\tt = bco;\n\tba[t] = 142 * 29 * 100;\n\tbb[t] = (10 * 29 - 12) * 100;\n\tbtype[t] = 31;\n\tbxtype[t] = 0;\n\tbco++;\n\tnco = 0;\n\tna[nco] = 7 * 29 * 100 - 300;\n\tnb[nco] = 14 * 29 * 100 - 1200;\n\tntype[nco] = 6;\n\tnco++;\n\tif (nco >= nmax)\n\t    nco = 0;\n\tna[nco] = 41 * 29 * 100 - 300;\n\tnb[nco] = 14 * 29 * 100 - 1200;\n\tntype[nco] = 6;\n\tnco++;\n\tif (nco >= nmax)\n\t    nco = 0;\n\tna[nco] = 149 * 29 * 100 - 1100;\n\tnb[nco] = 10 * 29 * 100 - 600;\n\tntype[nco] = 100;\n\tnco++;\n\tif (nco >= nmax)\n\t    nco = 0;\n\ttco = 0;\n\ttxtype[tco] = 1;\n\ttyobi(29 * 29, 3 * 29 - 12, 130);\n\ttyobi(34 * 29, 9 * 29 - 12, 5);\n\ttyobi(35 * 29, 9 * 29 - 12, 5);\n\ttyobi(55 * 29 + 15, 6 * 29 - 12, 7);\n\ttxtype[tco] = 10;\n\ttyobi(50 * 29, 9 * 29 - 12, 114);\n\ttxtype[tco] = 5;\n\ttyobi(1 * 29, 5 * 29 - 12, 300);\n\ttxtype[tco] = 3;\n\ttyobi(86 * 29, 9 * 29 - 12, 101);\n\ttxtype[tco] = 2;\n\ttyobi(86 * 29, 6 * 29 - 12, 117);\n\tfor (t = 0; t <= 2; t++) {\n\t    txtype[tco] = 3;\n\t    tyobi((79 + t) * 29, 13 * 29 - 12, 115);\n\t}\n\ttxtype[tco] = 3;\n\ttyobi(105 * 29, 11 * 29 - 12, 120);\n\ttxtype[tco] = 3;\n\ttyobi(109 * 29, 7 * 29 - 12, 102);\n\ttxtype[tco] = 4;\n\ttyobi(111 * 29, 7 * 29 - 12, 101);\n\ttyobi(132 * 29, 8 * 29 - 12 - 3, 140);\n\ttyobi(131 * 29, 9 * 29 - 12, 141);\n\ttyobi(161 * 29, 12 * 29 - 12, 142);\n\ttyobi(66 * 29, 4 * 29 - 12, 124);\n\tsrco = 0;\n\tt = srco;\n\tsra[t] = 93 * 29 * 100;\n\tsrb[t] = (10 * 29 - 12) * 100;\n\tsrc[t] = 60 * 100;\n\tsrtype[t] = 0;\n\tsracttype[t] = 1;\n\tsre[t] = 0;\n\tsrco++;\n\tt = 20;\n\tsra[t] = 119 * 29 * 100 + 300;\n\tsrb[t] = (10 * 29 - 12) * 100;\n\tsrc[t] = 12 * 30 * 100 + 1000;\n\tsrtype[t] = 0;\n\tsracttype[t] = 0;\n\tsrsp[t] = 21;\n\tsre[t] = 0;\n\tsrco++;\n\tstc = 0;\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n    if (sta == 2 && stb == 1 && stc == 0) {\n\tma = 5600;\n\tmb = 32000;\n\tbgmchange(otom[1]);\n\tstagecolor = 1;\n\tscrollx = 2900 * (113 - 19);\n\tbyte stagedatex[17][1001] = {\n\t    {0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     82, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 4, 4, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 4, 0,\n\t     0, 82,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 0, 0,\n\t     0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4,\n\t     4, 0,\n\t     82, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 4, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0,\n\t     0, 0, 4,\n\t     4, 4,\n\t     4, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 4, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 4,\n\t     4, 0,\n\t     0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 4, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4,\n\t     4, 4, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     4, 0,\n\t     0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 4, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 7,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 4, 4, 4, 4,\n\t     4, 0, 0,\n\t     4, 7,\n\t     7, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2, 2, 98, 2, 4, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 10, 10, 0, 0, 10, 10,\n\t     10, 10,\n\t     4, 1,\n\t     1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 4, 0,\n\t     0, 0,\n\t     0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 7, 0, 4, 4,\n\t     4, 4, 4,\n\t     4, 4,\n\t     4}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 98,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,\n\t     0, 0, 0,\n\t     0, 4,\n\t     4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 4, 7, 7, 7, 4, 4, 4, 0, 0, 0, 0,\n\t     80, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,\n\t     0, 0, 0,\n\t     4, 4,\n\t     4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 7,\n\t     0, 0, 4,\n\t     4, 4,\n\t     4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 81, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 81, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     81, 0, 0, 0, 81, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 0, 50,\n\t     0, 0,\n\t     50, 81,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81, 0, 0, 0, 0, 0, 0,\n\t     4, 0,\n\t     0, 4, 4,\n\t     4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0}\n\t    ,\n\t    {5, 5, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 0,\n\t     0, 0, 0,\n\t     0, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0,\n\t     5, 5, 5}\n\t    ,\n\t    {6, 6, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 0,\n\t     0, 0, 0,\n\t     0, 6,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0,\n\t     6, 6, 6}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0}\n\t};\n\ttco = 0;\n\ttxtype[tco] = 6;\n\ttyobi(1 * 29, 9 * 29 - 12, 300);\n\ttco += 1;\n\ttxtype[tco] = 0;\n\ttyobi(40 * 29, 9 * 29 - 12, 110);\n\ttco += 1;\n\ttxtype[tco] = 7;\n\ttyobi(79 * 29, 7 * 29 - 12, 300);\n\ttco += 1;\n\ttxtype[tco] = 2;\n\ttyobi(83 * 29, 7 * 29 - 12, 102);\n\ttco += 1;\n\ttxtype[tco] = 0;\n\ttyobi(83 * 29, 2 * 29 - 12, 114);\n\ttco += 1;\n\tfor (int i = -1; i > -7; i -= 1) {\n\t    tyobi(85 * 29, i * 29 - 12, 4);\n\t    tco += 1;\n\t}\n\tsco = 0;\n\tsa[sco] = 30 * 29 * 100;\n\tsb[sco] = (13 * 29 - 12) * 100;\n\tsc[sco] = 12000 - 1;\n\tsd[sco] = 3000;\n\tstype[sco] = 52;\n\tsxtype[sco] = 0;\n\tsco += 1;\n\tsa[sco] = 51 * 29 * 100;\n\tsb[sco] = (4 * 29 - 12) * 100;\n\tsc[sco] = 9000 - 1;\n\tsd[sco] = 3000;\n\tstype[sco] = 51;\n\tsxtype[sco] = 0;\n\tsco += 1;\n\tsa[sco] = 84 * 29 * 100;\n\tsb[sco] = (13 * 29 - 12) * 100;\n\tsc[sco] = 9000 - 1;\n\tsd[sco] = 3000;\n\tstype[sco] = 52;\n\tsxtype[sco] = 0;\n\tsco += 1;\n\tsa[sco] = 105 * 29 * 100;\n\tsb[sco] = (13 * 29 - 12) * 100;\n\tsc[sco] = 15000 - 1;\n\tsd[sco] = 3000;\n\tstype[sco] = 52;\n\tsxtype[sco] = 0;\n\tsco += 1;\n\tbco = 0;\n\tba[bco] = 6 * 29 * 100;\n\tbb[bco] = (3 * 29 - 12) * 100;\n\tbtype[bco] = 80;\n\tbxtype[bco] = 0;\n\tbco += 1;\n\tba[bco] = 13 * 29 * 100;\n\tbb[bco] = (6 * 29 - 12) * 100;\n\tbtype[bco] = 4;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 23 * 29 * 100;\n\tbb[bco] = (7 * 29 - 12) * 100;\n\tbtype[bco] = 80;\n\tbxtype[bco] = 0;\n\tbco += 1;\n\tba[bco] = 25 * 29 * 100;\n\tbb[bco] = (7 * 29 - 12) * 100;\n\tbtype[bco] = 80;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 27 * 29 * 100;\n\tbb[bco] = (7 * 29 - 12) * 100;\n\tbtype[bco] = 80;\n\tbxtype[bco] = 0;\n\tbco += 1;\n\tba[bco] = 88 * 29 * 100;\n\tbb[bco] = (12 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n    if (sta == 2 && stb == 2 && stc == 0) {\n\tbgmchange(otom[1]);\n\tstagecolor = 1;\n\tscrollx = 2900 * (19 - 19);\n\tbyte stagedatex[17][1001] = {\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0}\n\t    ,\n\t    {0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5}\n\t    ,\n\t    {6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t};\n\tsa[sco] = 14 * 29 * 100 + 200;\n\tsb[sco] = -6000;\n\tsc[sco] = 5000;\n\tsd[sco] = 70000;\n\tstype[sco] = 100;\n\tsco += 1;\n\tsa[sco] = 12 * 29 * 100 + 1200;\n\tsb[sco] = -6000;\n\tsc[sco] = 7000;\n\tsd[sco] = 70000;\n\tstype[sco] = 101;\n\tsco += 1;\n\tsa[sco] = 12 * 29 * 100;\n\tsb[sco] = (13 * 29 - 12) * 100;\n\tsc[sco] = 6000 - 1;\n\tsd[sco] = 3000;\n\tstype[sco] = 52;\n\tsgtype[sco] = 0;\n\tsco += 1;\n\tsa[sco] = 14 * 29 * 100;\n\tsb[sco] = (9 * 29 - 12) * 100;\n\tsc[sco] = 6000;\n\tsd[sco] = 12000 - 200;\n\tstype[sco] = 50;\n\tsxtype[sco] = 1;\n\tsco += 1;\n\ttyobi(6 * 29, 9 * 29 - 12, 110);\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n    if (sta == 2 && stb == 2 && stc == 1) {\n\tbgmchange(otom[2]);\n\tstagecolor = 2;\n\tma = 7500;\n\tmb = 9000;\n\tscrollx = 2900 * (137 - 19);\n\tbyte stagedatex[17][1001] = {\n\t    {0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\t     4, 4, 4,\n\t     4, 4,\n\t     4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4,\n\t     4, 4, 4,\n\t     4, 98,\n\t     4, 4, 4, 4, 4, 4, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\t     4, 98, 1}\n\t    ,\n\t    {4, 0, 0, 0, 0, 0, 0, 10, 10, 10, 10, 10, 10, 10, 10,\n\t     10, 10,\n\t     10, 10,\n\t     10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 7, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     10, 10,\n\t     10, 10,\n\t     10, 10, 10, 10, 10, 10, 10, 0, 0, 1, 1, 1, 1, 1, 1, 0,\n\t     0, 0,\n\t     10, 10,\n\t     10, 10, 10, 10, 10, 10, 10, 0, 0, 1}\n\t    ,\n\t    {4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 1}\n\t    ,\n\t    {4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0,\n\t     0, 0, 0,\n\t     0, 7,\n\t     0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 1}\n\t    ,\n\t    {4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 1}\n\t    ,\n\t    {4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 10, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4,\n\t     4, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 1, 1, 1, 1, 1, 1, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     1}\n\t    ,\n\t    {4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0,\n\t     0, 3, 0,\n\t     0, 0,\n\t     3, 0, 0, 0, 0, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 1}\n\t    ,\n\t    {4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 57,\n\t     0, 0, 0,\n\t     0, 0, 57, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4,\n\t     4, 4, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 7,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 10, 4, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     44, 0,\n\t     0, 1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     1}\n\t    ,\n\t    {4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 7, 7, 7,\n\t     0, 97,\n\t     0, 0, 0,\n\t     1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 1}\n\t    ,\n\t    {4, 7, 7, 7, 7, 7, 7, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 1, 0, 0, 0,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 1, 1, 1, 4, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0, 44,\n\t     0, 0, 1}\n\t    ,\n\t    {4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 1, 0, 0, 0,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 1, 1, 0, 0, 0, 97, 0,\n\t     0, 0, 1}\n\t    ,\n\t    {4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 1, 0, 0, 0,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1,\n\t     1, 1, 1}\n\t    ,\n\t    {4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 1, 0, 0, 0,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1,\n\t     1, 1, 1}\n\t    ,\n\t    {5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 1, 0, 0, 0,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 1, 1, 1, 5, 5, 5, 0, 0, 1, 1, 0, 0, 0, 1, 1,\n\t     1, 1, 1}\n\t    ,\n\t    {6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 0, 0, 1, 0, 0, 0,\n\t     1, 1, 1,\n\t     1, 1,\n\t     1, 1, 1, 1, 1, 1, 6, 6, 6, 0, 0, 1, 1, 0, 0, 0, 1, 1,\n\t     1, 1, 1}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0}\n\t};\n\tbco = 0;\n\tba[bco] = 32 * 29 * 100 - 1400;\n\tbb[bco] = (-2 * 29 - 12) * 100 + 500;\n\tbtype[bco] = 86;\n\tbxtype[bco] = 0;\n\tbco += 1;\n\tba[bco] = (31 * 29 - 12) * 100;\n\tbb[bco] = (7 * 29 - 12) * 100;\n\tbtype[bco] = 7;\n\tbxtype[bco] = 0;\n\tbco += 1;\n\tba[bco] = 38 * 29 * 100 + 1500;\n\tbb[bco] = (6 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 87;\n\tbxtype[bco] = 107;\n\tbco += 1;\n\tba[bco] = 38 * 29 * 100 + 1500;\n\tbb[bco] = (6 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 88;\n\tbxtype[bco] = 107;\n\tbco += 1;\n\tba[bco] = 42 * 29 * 100 + 1500;\n\tbb[bco] = (6 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 87;\n\tbxtype[bco] = 107;\n\tbco += 1;\n\tba[bco] = 42 * 29 * 100 + 1500;\n\tbb[bco] = (6 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 88;\n\tbxtype[bco] = 107;\n\tbco += 1;\n\tba[bco] = 46 * 29 * 100 + 1500;\n\tbb[bco] = (6 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 87;\n\tbxtype[bco] = 107;\n\tbco += 1;\n\tba[bco] = 46 * 29 * 100 + 1500;\n\tbb[bco] = (6 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 88;\n\tbxtype[bco] = 107;\n\tbco += 1;\n\tba[bco] = 58 * 29 * 100;\n\tbb[bco] = (7 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 66 * 29 * 100;\n\tbb[bco] = (7 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 76 * 29 * 100 - 1400;\n\tbb[bco] = (-2 * 29 - 12) * 100 + 500;\n\tbtype[bco] = 86;\n\tbxtype[bco] = 0;\n\tbco += 1;\n\tsco = 0;\n\tsa[sco] = 2 * 29 * 100;\n\tsb[sco] = (13 * 29 - 12) * 100;\n\tsc[sco] = 300000 - 6001;\n\tsd[sco] = 3000;\n\tstype[sco] = 52;\n\tsxtype[sco] = 0;\n\tsco += 1;\n\tsa[sco] = 3 * 29 * 100;\n\tsb[sco] = (7 * 29 - 12) * 100;\n\tsc[sco] = 3000;\n\tsd[sco] = 3000;\n\tstype[sco] = 105;\n\tsxtype[sco] = 0;\n\tsco += 1;\n\tsa[sco] = 107 * 29 * 100;\n\tsb[sco] = (9 * 29 - 12) * 100;\n\tsc[sco] = 9000 - 1;\n\tsd[sco] = 24000;\n\tstype[sco] = 52;\n\tsxtype[sco] = 1;\n\tsco += 1;\n\tsa[sco] = 111 * 29 * 100;\n\tsb[sco] = (7 * 29 - 12) * 100;\n\tsc[sco] = 3000;\n\tsd[sco] = 6000 - 200;\n\tstype[sco] = 40;\n\tsxtype[sco] = 0;\n\tsco += 1;\n\tsa[sco] = 113 * 29 * 100 + 1100;\n\tsb[sco] = (0 * 29 - 12) * 100;\n\tsc[sco] = 4700;\n\tsd[sco] = 27000 - 1000;\n\tstype[sco] = 0;\n\tsxtype[sco] = 0;\n\tsco += 1;\n\tsa[sco] = 128 * 29 * 100;\n\tsb[sco] = (9 * 29 - 12) * 100;\n\tsc[sco] = 9000 - 1;\n\tsd[sco] = 24000;\n\tstype[sco] = 52;\n\tsxtype[sco] = 1;\n\tsco += 1;\n\tsa[sco] = 131 * 29 * 100;\n\tsb[sco] = (9 * 29 - 12) * 100;\n\tsc[sco] = 3000;\n\tsd[sco] = 6000 - 200;\n\tstype[sco] = 40;\n\tsxtype[sco] = 2;\n\tsco += 1;\n\tsa[sco] = 133 * 29 * 100 + 1100;\n\tsb[sco] = (0 * 29 - 12) * 100;\n\tsc[sco] = 4700;\n\tsd[sco] = 32000;\n\tstype[sco] = 0;\n\tsxtype[sco] = 0;\n\tsco += 1;\n\ttco = 0;\n\ttxtype[tco] = 0;\n\ttyobi(0 * 29, 0 * 29 - 12, 4);\n\ttco = 1;\n\ttxtype[tco] = 0;\n\ttyobi(2 * 29, 9 * 29 - 12, 4);\n\ttco = 2;\n\ttxtype[tco] = 0;\n\ttyobi(3 * 29, 9 * 29 - 12, 4);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(5 * 29, 9 * 29 - 12, 115);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(6 * 29, 9 * 29 - 12, 115);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(5 * 29, 10 * 29 - 12, 115);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(6 * 29, 10 * 29 - 12, 115);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(5 * 29, 11 * 29 - 12, 115);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(6 * 29, 11 * 29 - 12, 115);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(5 * 29, 12 * 29 - 12, 115);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(6 * 29, 12 * 29 - 12, 115);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(70 * 29, 7 * 29 - 12, 115);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(71 * 29, 7 * 29 - 12, 115);\n\ttco += 1;\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n    if (sta == 2 && stb == 2 && stc == 2) {\n\tbgmchange(otom[1]);\n\tstagecolor = 1;\n\tscrollx = 2900 * (36 - 19);\n\tma = 7500;\n\tmb = 3000 * 9;\n\tbyte stagedatex[17][1001] = {\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 99, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50,\n\t     51, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4,\n\t     4, 4, 4,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4,\n\t     4, 4, 4,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4,\n\t     4, 4, 4,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 4, 4, 4, 4, 4,\n\t     4, 4,\n\t     4, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4,\n\t     4, 4, 4,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4,\n\t     4, 4, 4,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4,\n\t     4, 4,\n\t     4, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 41, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\t     4, 4,\n\t     4, 0, 0,\n\t     0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 54, 0, 0}\n\t    ,\n\t    {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     0, 0,\n\t     0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5}\n\t    ,\n\t    {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     0, 0,\n\t     0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t};\n\tbco = 0;\n\tba[bco] = 9 * 29 * 100;\n\tbb[bco] = (12 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 10 * 29 * 100;\n\tbb[bco] = (11 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 11 * 29 * 100;\n\tbb[bco] = (10 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 12 * 29 * 100;\n\tbb[bco] = (9 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 13 * 29 * 100;\n\tbb[bco] = (8 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 14 * 29 * 100;\n\tbb[bco] = (7 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 15 * 29 * 100;\n\tbb[bco] = (6 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 16 * 29 * 100;\n\tbb[bco] = (5 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 17 * 29 * 100;\n\tbb[bco] = (5 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 18 * 29 * 100;\n\tbb[bco] = (5 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 19 * 29 * 100;\n\tbb[bco] = (5 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 20 * 29 * 100;\n\tbb[bco] = (5 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n    if (sta == 2 && stb == 3 && stc == 0) {\n\tma = 7500;\n\tmb = 3000 * 8;\n\tbgmchange(otom[1]);\n\tstagecolor = 1;\n\tscrollx = 2900 * (126 - 19);\n\tbyte stagedatex[17][1001] = {\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     4, 4,\n\t     4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\t     4, 4, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     82, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0,\n\t     0, 0, 0,\n\t     4, 4,\n\t     4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 0, 0,\n\t     0, 0,\n\t     0, 0,\n\t     56, 0, 0, 0, 0, 0, 0, 0, 0, 4, 10, 10, 10, 10, 10, 10,\n\t     10, 10,\n\t     10,\n\t     10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 51, 0, 1, 0,\n\t     0, 0,\n\t     0, 4, 4,\n\t     4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 1, 0,\n\t     0, 0,\n\t     1, 0, 0, 0, 0, 0, 82, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     50, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 0, 0, 0, 1,\n\t     7, 0, 0,\n\t     0, 4,\n\t     4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     4, 4,\n\t     4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     4, 4,\n\t     4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 4, 4, 4, 0, 54, 0,\n\t     54, 0, 4,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 4, 4,\n\t     4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 4, 4, 4, 4,\n\t     4, 4, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     7, 4,\n\t     7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0,\n\t     0, 4, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 58, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0,\n\t     0, 4, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 7, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 4, 0, 0, 0, 0, 0, 0,\n\t     0, 4, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 0, 4, 1, 1, 1, 4,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0, 4, 0, 0, 0, 0, 0, 0,\n\t     0, 4,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 7,\n\t     0, 0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 30, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0,\n\t     0, 4, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 3,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0,\n\t     0, 4, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 4, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5,\n\t     5, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0,\n\t     0, 4, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 5, 0, 5, 5, 5, 5, 5}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6,\n\t     6, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0,\n\t     0, 4, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 6, 6, 0, 6, 6, 6, 6, 6}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t};\n\ttco = 0;\n\ttxtype[tco] = 0;\n\tfor (int i = -1; i > -7; i -= 1) {\n\t    tyobi(55 * 29, i * 29 - 12, 4);\n\t    tco += 1;\n\t}\n\ttxtype[tco] = 0;\n\ttyobi(64 * 29, 12 * 29 - 12, 120);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(66 * 29, 3 * 29 - 12, 115);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(67 * 29, 3 * 29 - 12, 115);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(68 * 29, 3 * 29 - 12, 115);\n\ttco += 1;\n\ttxtype[tco] = 8;\n\ttyobi(60 * 29, 6 * 29 - 12, 300);\n\ttco += 1;\n\t/*\n\t   bco = 1;\n\t   ba[bco]=(54*29-12)*100;\n\t   bb[bco]=(1*29-12)*100;\n\t   btype[bco]=80;\n\t   bxtype[bco]=0;\n\t   bco += 1;\n\t */\n\tsco = 0;\n\tba[sco] = (102 * 29 - 12) * 100;\n\tbb[sco] = (10 * 29 - 12) * 100;\n\tbtype[sco] = 50;\n\tbxtype[sco] = 1;\n\tsco += 1;\n\tsrco = 0;\n\tsra[srco] = 1 * 29 * 100;\n\tsrb[srco] = (10 * 29 - 12) * 100;\n\tsrc[srco] = 5 * 3000;\n\tsrtype[srco] = 0;\n\tsracttype[srco] = 1;\n\tsre[srco] = 0;\n\tsrsp[srco] = 10;\n\tsrco++;\n\tsra[srco] = 18 * 29 * 100;\n\tsrb[srco] = (4 * 29 - 12) * 100;\n\tsrc[srco] = 3 * 3000;\n\tsrtype[srco] = 0;\n\tsracttype[srco] = 0;\n\tsre[srco] = 0;\n\tsrsp[srco] = 10;\n\tsrco++;\n\tsra[srco] = 35 * 29 * 100;\n\tsrb[srco] = (4 * 29 - 12) * 100;\n\tsrc[srco] = 5 * 3000;\n\tsrtype[srco] = 0;\n\tsracttype[srco] = 0;\n\tsre[srco] = 0;\n\tsrsp[srco] = 10;\n\tsrco++;\n\tsra[srco] = 35 * 29 * 100;\n\tsrb[srco] = (8 * 29 - 12) * 100;\n\tsrc[srco] = 5 * 3000;\n\tsrtype[srco] = 0;\n\tsracttype[srco] = 0;\n\tsre[srco] = 0;\n\tsrsp[srco] = 10;\n\tsrco++;\n\tsra[srco] = 94 * 29 * 100;\n\tsrb[srco] = (6 * 29 - 12) * 100;\n\tsrc[srco] = 3 * 3000;\n\tsrtype[srco] = 0;\n\tsracttype[srco] = 0;\n\tsre[srco] = 0;\n\tsrsp[srco] = 1;\n\tsrco++;\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n    if (sta == 2 && stb == 4 && (stc == 0 || stc == 10 || stc == 12)) {\n\tif (stc == 0) {\n\t    ma = 7500;\n\t    mb = 3000 * 4;\n\t} else {\n\t    ma = 19500;\n\t    mb = 3000 * 11;\n\t    stc = 0;\n\t}\n\tbgmchange(otom[4]);\n\tstagecolor = 4;\n\tscrollx = 2900 * (40 - 19);\n\tbyte stagedatex[17][1001] = {\n\t    {5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}\n\t    ,\n\t    {5, 5, 5, 5, 5, 5, 5, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 10,\n\t     0, 0,\n\t     0, 10,\n\t     10, 10, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5}\n\t    ,\n\t    {5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 7, 7, 10, 10, 10, 5, 5, 5, 5, 5}\n\t    ,\n\t    {5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5}\n\t    ,\n\t    {5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5}\n\t    ,\n\t    {5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 5, 5, 5, 5, 7,\n\t     7, 7, 3,\n\t     7, 0,\n\t     7, 5, 0, 0, 5, 5, 5, 0, 58, 0, 5, 0, 0, 5, 5}\n\t    ,\n\t    {5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 5, 5, 5, 5, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5}\n\t    ,\n\t    {5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5}\n\t    ,\n\t    {5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5}\n\t    ,\n\t    {5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5}\n\t    ,\n\t    {5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5}\n\t    ,\n\t    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 59, 0, 5, 5, 5, 5, 0,\n\t     0, 0,\n\t     0, 0,\n\t     0, 0, 5, 0, 0, 0, 0, 5, 59, 0, 0, 5, 5, 5, 5, 5}\n\t    ,\n\t    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 5, 5, 5, 5, 5}\n\t    ,\n\t    {5, 5, 5, 5, 5, 5, 40, 0, 5, 0, 0, 0, 0, 5, 5, 5, 5, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 5, 0, 0, 0, 0, 5, 0, 59, 0, 5, 5, 5, 5, 5}\n\t    ,\n\t    {5, 86, 5, 5, 5, 5, 41, 0, 5, 86, 0, 0, 86, 5, 5, 5, 5,\n\t     86, 0,\n\t     0, 86,\n\t     0, 0, 86, 5, 0, 86, 5, 5, 5, 86, 0, 0, 5, 5, 5, 5, 5}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 59, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0, 0, 0, 0, 0}\n\t};\n\ttco = 0;\n\ttxtype[tco] = 0;\n\ttyobi(0 * 29, -1 * 29 - 12, 5);\n\ttco += 1;\n\ttxtype[tco] = 0;\n\ttyobi(4 * 29, -1 * 29 - 12, 5);\n\ttco += 1;\n\ttxtype[tco] = 0;\n\ttyobi(1 * 29, 14 * 29 - 12, 5);\n\ttco += 1;\n\ttxtype[tco] = 0;\n\ttyobi(6 * 29, 14 * 29 - 12, 5);\n\ttco += 1;\n\ttxtype[tco] = 0;\n\ttyobi(7 * 29, 14 * 29 - 12, 5);\n\ttco += 1;\n\tbco = 0;\n\tba[bco] = 2 * 29 * 100 - 1400;\n\tbb[bco] = (-2 * 29 - 12) * 100 + 500;\n\tbtype[bco] = 86;\n\tbxtype[bco] = 0;\n\tbco += 1;\n\tba[bco] = 20 * 29 * 100 + 1500;\n\tbb[bco] = (5 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 87;\n\tbxtype[bco] = 107;\n\tbco += 1;\n\tsco = 0;\n\tsa[sco] = 17 * 29 * 100;\n\tsb[sco] = (9 * 29 - 12) * 100;\n\tsc[sco] = 21000 - 1;\n\tsd[sco] = 3000 - 1;\n\tstype[sco] = 52;\n\tsxtype[sco] = 2;\n\tsco += 1;\n\tsa[sco] = 27 * 29 * 100;\n\tsb[sco] = (13 * 29 - 12) * 100;\n\tsc[sco] = 6000;\n\tsd[sco] = 6000;\n\tstype[sco] = 50;\n\tsxtype[sco] = 6;\n\tsco += 1;\n\tsa[sco] = 34 * 29 * 100;\n\tsb[sco] = (5 * 29 - 12) * 100;\n\tsc[sco] = 6000;\n\tsd[sco] = 30000;\n\tstype[sco] = 50;\n\tsxtype[sco] = 1;\n\tsco += 1;\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n    if (sta == 2 && stb == 4 && stc == 1) {\n\tma = 4500;\n\tmb = 3000 * 11;\n\tbgmchange(otom[4]);\n\tstagecolor = 4;\n\tscrollx = 2900 * (21 - 19);\n\tbyte stagedatex[17][1001] = {\n\t    {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     98}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 7, 7, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 5, 5, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {0, 10, 10, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0,\n\t     0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 44, 0,\n\t     0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 97, 0, 0,\n\t     0}\n\t    ,\n\t    {0, 40, 0, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 5, 5, 5,\n\t     5}\n\t    ,\n\t    {86, 41, 0, 86, 0, 5, 86, 0, 0, 86, 0, 5, 86, 0, 0, 86,\n\t     0, 0,\n\t     86}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t};\n\ttco = 0;\n\ttxtype[tco] = 1;\n\ttyobi(12 * 29, 13 * 29 - 12, 115);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(13 * 29, 13 * 29 - 12, 115);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(14 * 29, 13 * 29 - 12, 115);\n\ttco += 1;\n\tsco = 0;\n\tsa[sco] = 6 * 29 * 100;\n\tsb[sco] = (6 * 29 - 12) * 100;\n\tsc[sco] = 18000 - 1;\n\tsd[sco] = 6000 - 1;\n\tstype[sco] = 52;\n\tsxtype[sco] = 0;\n\tsco += 1;\n\tsa[sco] = 12 * 29 * 100;\n\tsb[sco] = (8 * 29 - 12) * 100;\n\tsc[sco] = 9000 - 1;\n\tsd[sco] = 3000 - 1;\n\tstype[sco] = 52;\n\tsxtype[sco] = 2;\n\tsco += 1;\n\tsa[sco] = 15 * 29 * 100;\n\tsb[sco] = (11 * 29 - 12) * 100;\n\tsc[sco] = 3000;\n\tsd[sco] = 6000;\n\tstype[sco] = 40;\n\tsxtype[sco] = 2;\n\tsco += 1;\n\tsa[sco] = 17 * 29 * 100 + 1100;\n\tsb[sco] = (0 * 29 - 12) * 100;\n\tsc[sco] = 4700;\n\tsd[sco] = 38000;\n\tstype[sco] = 0;\n\tsxtype[sco] = 0;\n\tsco += 1;\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n    if (sta == 2 && stb == 4 && stc == 2) {\n\tma = 4500;\n\tmb = 3000 * 11;\n\tbgmchange(otom[5]);\n\tstagecolor = 4;\n\tscrollx = 2900 * (128 - 19);\n\tbyte stagedatex[17][1001] = {\n\t    {5, 5, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}\n\t    ,\n\t    {5, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 5, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 5, 5,\n\t     5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {5, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 5, 0,\n\t     0, 0,\n\t     0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 5, 5,\n\t     5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {5, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 5, 0,\n\t     0, 0,\n\t     0, 5, 0, 5, 5, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 5, 5,\n\t     5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {5, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 7,\n\t     7, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0,\n\t     0, 5, 0,\n\t     0, 5,\n\t     0, 5, 0, 10, 10, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0,\n\t     0, 60, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 5,\n\t     5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0,\n\t     0, 5, 0,\n\t     0, 5,\n\t     0, 5, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     5, 5,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0,\n\t     0, 5, 3,\n\t     0, 5,\n\t     0, 3, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     5, 5,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0,\n\t     0, 5, 0,\n\t     0, 5,\n\t     0, 5, 5, 5, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 7, 7, 7, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     5, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {3, 0, 0, 3, 0, 0, 3, 7, 0, 3, 7, 7, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0,\n\t     5, 0, 0,\n\t     0, 5,\n\t     0, 5, 10, 10, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0,\n\t     5, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 7, 7, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 5,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {5, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 5,\n\t     0, 5, 0, 0, 0, 5, 0, 5, 7, 0, 0, 0, 0, 0, 5, 0, 0, 0,\n\t     5, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 3, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {5, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 5,\n\t     0, 0, 0, 30, 0, 5, 0, 0, 0, 0, 0, 0, 7, 7, 5, 0, 0, 0,\n\t     5, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 5, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t    ,\n\t    {5, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 5,\n\t     5, 5, 0,\n\t     0, 5,\n\t     0, 0, 7, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0,\n\t     5, 0, 0,\n\t     0, 5,\n\t     5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0,\n\t     0, 5, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}\n\t    ,\n\t    {5, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 5,\n\t     0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0,\n\t     5, 59,\n\t     0, 59,\n\t     5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}\n\t    ,\n\t    {5, 40, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 5,\n\t     0, 0, 0, 5, 0, 5, 0, 5, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0,\n\t     5, 0,\n\t     59, 0, 5,\n\t     5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}\n\t    ,\n\t    {5, 41, 0, 5, 86, 0, 5, 86, 0, 5, 5, 5, 5, 86, 0, 0, 86,\n\t     0, 0,\n\t     86, 0,\n\t     0, 86, 0, 0, 86, 0, 0, 86, 0, 0, 86, 0, 0, 86, 0, 0, 5,\n\t     86, 0,\n\t     0, 86,\n\t     0, 0, 86, 5, 0, 86, 0, 5, 86, 5, 0, 5, 86, 0, 0, 5, 5,\n\t     5, 5,\n\t     86, 0,\n\t     0, 5, 86, 59, 0, 5, 5, 5, 5, 5, 86, 0, 0, 86, 5, 5, 86,\n\t     0, 0,\n\t     86, 0,\n\t     0, 86, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 86, 0, 0, 86,\n\t     0, 0,\n\t     86, 0, 0,\n\t     86, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     59, 0,\n\t     0, 0, 0, 0, 59, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 59,\n\t     0, 59,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t};\n\ttco = 0;\n\ttxtype[tco] = 0;\n\ttyobi(1 * 29, 14 * 29 - 12, 5);\n\ttco += 1;\n\ttxtype[tco] = 0;\n\ttyobi(2 * 29, 14 * 29 - 12, 5);\n\ttco += 1;\n\ttxtype[tco] = 9;\n\ttyobi(3 * 29, 4 * 29 - 12, 300);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(32 * 29, 9 * 29 - 12, 115);\n\ttco += 1;\n\ttxtype[tco] = 0;\n\ttyobi(76 * 29, 14 * 29 - 12, 5);\n\ttco += 1;\n\ttxtype[tco] = 0;\n\ttyobi(108 * 29, 11 * 29 - 12, 141);\n\ttco += 1;\n\ttxtype[tco] = 0;\n\ttyobi(109 * 29, 10 * 29 - 12 - 3, 140);\n\ttco += 1;\n\ttxtype[tco] = 0;\n\ttyobi(121 * 29, 10 * 29 - 12, 142);\n\ttco += 1;\n\tbco = 0;\n\tba[bco] = 0 * 29 * 100 + 1500;\n\tbb[bco] = (8 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 88;\n\tbxtype[bco] = 105;\n\tbco += 1;\n\tba[bco] = 2 * 29 * 100;\n\tbb[bco] = (0 * 29 - 12) * 100;\n\tbtype[bco] = 80;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 3 * 29 * 100 + 1500;\n\tbb[bco] = (8 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 87;\n\tbxtype[bco] = 105;\n\tbco += 1;\n\tba[bco] = 6 * 29 * 100 + 1500;\n\tbb[bco] = (8 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 88;\n\tbxtype[bco] = 107;\n\tbco += 1;\n\tba[bco] = 9 * 29 * 100 + 1500;\n\tbb[bco] = (8 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 88;\n\tbxtype[bco] = 107;\n\tbco += 1;\n\tba[bco] = 25 * 29 * 100 - 1400;\n\tbb[bco] = (2 * 29 - 12) * 100 - 400;\n\tbtype[bco] = 86;\n\tbxtype[bco] = 0;\n\tbco += 1;\n\tba[bco] = 40 * 29 * 100;\n\tbb[bco] = (8 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 0;\n\tbco += 1;\n\tba[bco] = 42 * 29 * 100;\n\tbb[bco] = (8 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 0;\n\tbco += 1;\n\tba[bco] = 43 * 29 * 100 + 1500;\n\tbb[bco] = (6 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 88;\n\tbxtype[bco] = 105;\n\tbco += 1;\n\tba[bco] = 47 * 29 * 100 + 1500;\n\tbb[bco] = (6 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 87;\n\tbxtype[bco] = 105;\n\tbco += 1;\n\tba[bco] = 57 * 29 * 100;\n\tbb[bco] = (7 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 0;\n\tbco += 1;\n\tba[bco] = 77 * 29 * 100 - 1400;\n\tbb[bco] = (2 * 29 - 12) * 100 - 400;\n\tbtype[bco] = 86;\n\tbxtype[bco] = 0;\n\tbco += 1;\n\tba[bco] = 83 * 29 * 100 - 1400;\n\tbb[bco] = (2 * 29 - 12) * 100 - 400;\n\tbtype[bco] = 86;\n\tbxtype[bco] = 0;\n\tbco += 1;\n\tba[bco] = 88 * 29 * 100 + 1500;\n\tbb[bco] = (9 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 87;\n\tbxtype[bco] = 105;\n\tbco += 1;\n\tba[bco] = 88 * 29 * 100 + 1500;\n\tbb[bco] = (9 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 88;\n\tbxtype[bco] = 105;\n\tbco += 1;\n\tba[bco] = 90 * 29 * 100;\n\tbb[bco] = (9 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 0;\n\tbco += 1;\n\tba[bco] = 107 * 29 * 100;\n\tbb[bco] = (10 * 29 - 12) * 100;\n\tbtype[bco] = 30;\n\tbxtype[bco] = 0;\n\tbco += 1;\n\tsco = 0;\n\tsa[sco] = 13 * 29 * 100;\n\tsb[sco] = (8 * 29 - 12) * 100;\n\tsc[sco] = 33000 - 1;\n\tsd[sco] = 3000 - 1;\n\tstype[sco] = 52;\n\tsxtype[sco] = 2;\n\tsco += 1;\n\tsa[sco] = 13 * 29 * 100;\n\tsb[sco] = (0 * 29 - 12) * 100;\n\tsc[sco] = 33000 - 1;\n\tsd[sco] = 3000 - 1;\n\tstype[sco] = 51;\n\tsxtype[sco] = 3;\n\tsco += 1;\n\tsa[sco] = 10 * 29 * 100;\n\tsb[sco] = (13 * 29 - 12) * 100;\n\tsc[sco] = 6000;\n\tsd[sco] = 6000;\n\tstype[sco] = 50;\n\tsxtype[sco] = 6;\n\tsco += 1;\n\tsa[sco] = 46 * 29 * 100;\n\tsb[sco] = (12 * 29 - 12) * 100;\n\tsc[sco] = 9000 - 1;\n\tsd[sco] = 3000 - 1;\n\tstype[sco] = 52;\n\tsxtype[sco] = 2;\n\tsco += 1;\n\tsa[sco] = 58 * 29 * 100;\n\tsb[sco] = (13 * 29 - 12) * 100;\n\tsc[sco] = 6000;\n\tsd[sco] = 6000;\n\tstype[sco] = 50;\n\tsxtype[sco] = 6;\n\tsco += 1;\n\tsa[sco] = 101 * 29 * 100 - 1500;\n\tsb[sco] = (10 * 29 - 12) * 100 - 3000;\n\tsc[sco] = 12000;\n\tsd[sco] = 12000;\n\tstype[sco] = 104;\n\tsxtype[sco] = 0;\n\tsco += 1;\n\tsa[sco] = 102 * 29 * 100 + 3000;\n\tsb[sco] = (2 * 29 - 12) * 100;\n\tsc[sco] = 3000 - 1;\n\tsd[sco] = 300000;\n\tstype[sco] = 102;\n\tsxtype[sco] = 20;\n\tsco += 1;\n\tsrco = 0;\n\tsra[srco] = 74 * 29 * 100 - 1500;\n\tsrb[srco] = (7 * 29 - 12) * 100;\n\tsrc[srco] = 2 * 3000;\n\tsrtype[srco] = 0;\n\tsracttype[srco] = 1;\n\tsre[srco] = 0;\n\tsrsp[srco] = 0;\n\tsrco = 20;\n\tsra[srco] = 97 * 29 * 100;\n\tsrb[srco] = (12 * 29 - 12) * 100;\n\tsrc[srco] = 12 * 3000;\n\tsrtype[srco] = 0;\n\tsracttype[srco] = 0;\n\tsre[srco] = 0;\n\tsrsp[srco] = 21;\n\tsrco += 1;\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n    if (sta == 3 && stb == 1 && stc == 0) {\n\tma = 5600;\n\tmb = 32000;\n\tbgmchange(otom[1]);\n\tstagecolor = 5;\n\tscrollx = 2900 * (112 - 19);\n\tbyte stagedatex[17][1001] = {\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 7,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 4, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     82, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 4, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 4, 7,\n\t     7, 7, 7,\n\t     7, 7,\n\t     7, 7, 7, 7, 7, 7, 7, 7, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 7, 0, 4, 4, 4,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 7, 7, 7, 7, 4, 0,\n\t     0, 82,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 10, 10, 0, 0, 10, 10,\n\t     4, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 4, 0, 0, 0, 0, 4,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0}\n\t    ,\n\t    {0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 7, 0, 0, 4,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 4, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 4, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 4, 4, 4, 4, 4, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 7, 4, 4, 4, 4, 0, 4,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 4, 4, 4, 4, 4, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     4, 4, 4, 4, 0, 0, 0, 4, 0, 7, 7, 4, 4, 4, 4, 0, 4, 4,\n\t     4, 4, 4,\n\t     4, 4}\n\t    ,\n\t    {0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 7, 0, 0, 4, 0, 4, 4, 4, 4, 4, 4, 0,\n\t     0, 0, 0,\n\t     0, 4,\n\t     4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4,\n\t     4, 4, 4,\n\t     4, 4}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 4, 4, 4, 4, 4, 0,\n\t     0, 0, 0,\n\t     4, 4,\n\t     4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4,\n\t     4, 4, 4,\n\t     4, 4}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30,\n\t     0, 0,\n\t     0, 0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 4,\n\t     4, 4,\n\t     4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4,\n\t     4, 4, 4,\n\t     4, 4}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     1, 0,\n\t     51, 1, 0, 81, 0, 0, 1, 1, 1, 1, 1, 7, 0, 0, 0, 0, 0, 4,\n\t     0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 7,\n\t     0, 0, 4,\n\t     4, 4,\n\t     4, 4, 4, 4, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 4,\n\t     4, 4, 4,\n\t     4, 4,\n\t     4}\n\t    ,\n\t    {0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 5, 5,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,\n\t     0, 1, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 7,\n\t     5, 5, 5,\n\t     5, 5,\n\t     5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 5, 5, 5, 5, 5, 5, 5,\n\t     5, 5, 5,\n\t     5, 5}\n\t    ,\n\t    {0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 6, 6,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 6, 0, 0, 0, 6, 6, 6, 6, 6, 6, 0, 0, 0,\n\t     6, 6, 6,\n\t     6, 6,\n\t     6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 6, 6, 6, 6, 6, 6, 6,\n\t     6, 6, 6,\n\t     6, 6}\n\t    ,\n\t    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0,\n\t     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t     0, 0, 0,\n\t     0, 0}\n\t};\n\ttco = 0;\n\ttxtype[tco] = 10;\n\ttyobi(2 * 29, 9 * 29 - 12, 300);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(63 * 29, 13 * 29 - 12, 115);\n\ttco += 1;\n\ttxtype[tco] = 1;\n\ttyobi(64 * 29, 13 * 29 - 12, 115);\n\ttco += 1;\n\tsco = 0;\n\tsa[sco] = 13 * 29 * 100;\n\tsb[sco] = (13 * 29 - 12) * 100;\n\tsc[sco] = 9000 - 1;\n\tsd[sco] = 3000;\n\tstype[sco] = 52;\n\tsxtype[sco] = 0;\n\tsco += 1;\n\tsa[sco] = 84 * 29 * 100;\n\tsb[sco] = (13 * 29 - 12) * 100;\n\tsc[sco] = 9000 - 1;\n\tsd[sco] = 3000;\n\tstype[sco] = 52;\n\tsxtype[sco] = 0;\n\tsco += 1;\n\tbco = 0;\n\tba[bco] = 108 * 29 * 100;\n\tbb[bco] = (6 * 29 - 12) * 100;\n\tbtype[bco] = 6;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 33 * 29 * 100;\n\tbb[bco] = (10 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 36 * 29 * 100;\n\tbb[bco] = (0 * 29 - 12) * 100;\n\tbtype[bco] = 80;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tba[bco] = 78 * 29 * 100 + 1500;\n\tbb[bco] = (7 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 88;\n\tbxtype[bco] = 105;\n\tbco += 1;\n\tba[bco] = 80 * 29 * 100 + 1500;\n\tbb[bco] = (7 * 29 - 12) * 100 + 1500;\n\tbtype[bco] = 87;\n\tbxtype[bco] = 105;\n\tbco += 1;\n\tba[bco] = 85 * 29 * 100;\n\tbb[bco] = (11 * 29 - 12) * 100;\n\tbtype[bco] = 82;\n\tbxtype[bco] = 1;\n\tbco += 1;\n\tsrco = 0;\n\tsra[srco] = 41 * 29 * 100;\n\tsrb[srco] = (3 * 29 - 12) * 100;\n\tsrc[srco] = 3 * 3000;\n\tsrtype[srco] = 0;\n\tsracttype[srco] = 0;\n\tsre[srco] = 0;\n\tsrsp[srco] = 3;\n\tsrco = 0;\n\tfor (tt = 0; tt <= 1000; tt++) {\n\t    for (t = 0; t <= 16; t++) {\n\t\tstagedate[t][tt] = 0;\n\t\tstagedate[t][tt] = stagedatex[t][tt];\n\t    }\n\t}\n    }\n}\nvoid bgmchange(Mix_Music * x)\n{\n    Mix_HaltMusic();\n    otom[0] = x;\n    Mix_PlayMusic(otom[0], -1);;\n    if(x == otom[2]) Mix_VolumeMusic(MIX_MAX_VOLUME * 40 / 100);\n    else Mix_VolumeMusic(MIX_MAX_VOLUME * 50 / 100);\n}\nvoid tyobi(int x, int y, int type)\n{\n    ta[tco] = x * 100;\n    tb[tco] = y * 100;\n    ttype[tco] = type;\n    tco++;\n    if (tco >= tmax)\n\ttco = 0;\n}\nvoid brockbreak(int t)\n{\n    if (titem[t] == 1) {\n    }\n    if (titem[t] >= 2 && titem[t] <= 7) {\n    }\n    ta[t] = -800000;\n}\nvoid ttmsg()\n{\n    xx[1] = 6000 / 100;\n    xx[2] = 4000 / 100;\n    if (tmsgtype == 1 || tmsgtype == 2) {\n\tsetc0();\n\tfillrect(xx[1], xx[2], 360, tmsgy / 100);\n\tsetc1();\n\tdrawrect(xx[1], xx[2], 360, tmsgy / 100);\n    }\n    if (tmsgtype == 2) {\n\tsetfont(20, 5);\n\tif (tmsg == 0) {\n\t    setc1();\n\t    setfont(20, 5);\n\t    txmsg(\"hoge\", 0);\n\t}\n\tif (tmsg == 1) {\n\t    setc1();\n\t    txmsg(\"\", 0);\n\t    txmsg(\" 1 \", 0);\n\t    txmsg(\"\", 1);\n\t    txmsg(\"\", 2);\n\t    txmsg\n\t\t(\"\", 4);\n\t    txmsg(\"                        \", 6);\n\t}\n\tif (tmsg == 2) {\n\t    txmsg(\"             \", 3);\n\t    txmsg(\"                         m9(^^)\", 6);\n\t}\n\tif (tmsg == 3) {\n\t    txmsg(\"    \", 3);\n\t    txmsg(\"                      ( )\", 6);\n\t}\n\tif (tmsg == 4) {\n\t    txmsg(\" \", 2);\n\t    txmsg(\" !!\", 4);\n\t}\n\tif (tmsg == 5) {\n\t    txmsg(\"\", 0);\n\t    txmsg(\" \", 1);\n\t    txmsg(\"     \", 3);\n\t    txmsg(\"                        \", 6);\n\t}\n\tif (tmsg == 6) {\n\t    txmsg(\"\", 0);\n\t    txmsg(\"       \", 1);\n\t    txmsg\n\t\t(\" \",\n\t\t 2);\n\t    txmsg(\"                     \", 3);\n\t}\n\tif (tmsg == 7) {\n\t    txmsg(\"\", 0);\n\t    txmsg(\" ?     \", 1);\n\t    txmsg(\"         \", 2);\n\t    txmsg(\"  Let's dive!    \", 3);\n\t}\n\tif (tmsg == 8) {\n\t    txmsg(\"\", 1);\n\t    txmsg(\"\", 2);\n\t    txmsg(\"!!\", 3);\n\t}\n\tif (tmsg == 9) {\n\t    txmsg(\"     \", 1);\n\t    txmsg(\" !!    \", 2);\n\t    txmsg(\" ?   \", 3);\n\t}\n\tif (tmsg == 10) {\n\t    txmsg\n\t\t(\" \",\n\t\t 1);\n\t    txmsg(\" \", 2);\n\t    txmsg(\"                       \", 3);\n\t}\n\tif (tmsg == 100) {\n\t    txmsg(\" \", 0);\n\t    txmsg(\"\", 2);\n\t    txmsg(\"\", 3);\n\t    txmsg\n\t\t(\"\", 5);\n\t    txmsg(\"                          ()\", 6);\n\t}\n\tsetfont(16, 4);\n    }\n    if (tmsgtype == 3) {\n\txx[5] = (((15 - 1) * 1200 + 1500) / 100 - tmsgy / 100);\n\tif (xx[5] > 0) {\n\t    setc0();\n\t    fillrect(xx[1], xx[2] + tmsgy / 100, 360, xx[5]);\n\t    setc1();\n\t    drawrect(xx[1], xx[2] + tmsgy / 100, 360, xx[5]);\n\t}\n    }\n}\nvoid txmsg(string x, int a)\n{\n    int xx = 6;\n    str(x, 60 + xx, 40 + xx + a * 24);\n}\nvoid setfont(int x, int y)\n{\n    SetFontSize(x);\n    SetFontThickness(y);\n}\nvoid\neyobi(int xa, int xb, int xc, int xd, int xe, int xf, int xnobia,\n      int xnobib, int xgtype, int xtm)\n{\n    ea[eco] = xa;\n    eb[eco] = xb;\n    ec[eco] = xc;\n    ed[eco] = xd;\n    ee[eco] = xe;\n    ef[eco] = xf;\n    egtype[eco] = xgtype;\n    etm[eco] = xtm;\n    enobia[eco] = xnobia;\n    enobib[eco] = xnobib;\n    eco++;\n    if (eco >= emax)\n\teco = 0;\n}\nvoid ayobi(int xa, int xb, int xc, int xd, int xnotm, int xtype,\n\t   int xxtype)\n{\n    int rz = 0;\n    for (t1 = 0; t1 <= 1; t1++) {\n\tt1 = 2;\n\tif (aa[aco] >= -9000 && aa[aco] <= 30000)\n\t    t1 = 0;\n\trz++;\n\tif (rz <= amax) {\n\t    t1 = 3;\n\t    aa[aco] = xa;\n\t    ab[aco] = xb;\n\t    ac[aco] = xc;\n\t    ad[aco] = xd;\n\t    if (xxtype > 100)\n\t\tac[aco] = xxtype;\n\t    atype[aco] = xtype;\n\t    if (xxtype >= 0 && xxtype <= 99100)\n\t\taxtype[aco] = xxtype;\n\t    anotm[aco] = xnotm;\n\t    if (aa[aco] - fx <= ma + mnobia / 2)\n\t\tamuki[aco] = 1;\n\t    if (aa[aco] - fx > ma + mnobia / 2)\n\t\tamuki[aco] = 0;\n\t    if (abrocktm[aco] >= 1)\n\t\tamuki[aco] = 1;\n\t    if (abrocktm[aco] == 20)\n\t\tamuki[aco] = 0;\n\t    anobia[aco] = anx[atype[aco]];\n\t    anobib[aco] = any[atype[aco]];\n\t    if (xtype == 7 && CheckSoundMem(oto[10]) == 0) {\n\t\tot(oto[10]);\n\t    }\n\t    if (xtype == 10 && CheckSoundMem(oto[18]) == 0) {\n\t\tot(oto[18]);\n\t    }\n\t    azimentype[aco] = 1;\n\t    switch (atype[aco]) {\n/*\ncase 0:case 1:case 2:case 5:case 6:case 7:case 8:\nazimentype[aco]=2;\nbreak;\ncase 3:case 4:\nazimentype[aco]=0;\nbreak;\ncase 49:case 50:\nazimentype[aco]=4;\nbreak;\ncase 80:case 81:case 82:case 83:case 84:case 85:\nazimentype[aco]=1;\nbreak;\ncase 100:case 101:case 102:case 103:case 104:case 105:case 106:case 107:case 108:\nazimentype[aco]=1;\nbreak;\ncase 120:case 121:case 122:\nazimentype[aco]=1;\nbreak;\ncase 130:case 131:case 132:case 133:case 134:\nazimentype[aco]=1;\nbreak;\n*/\n\t    }\n\t    if (xtype == 87) {\n\t\tatm[aco] = rand(179) + (-90);\n\t    }\n\t    aco += 1;\n\t    if (aco >= amax - 1) {\n\t\taco = 0;\n\t    }\n\t}\n    }\n}\n","#include \"DxLib.h\"\nusing namespace std;\n\n#define SHORT\n\nvoid loadg();\nvoid parseArgs(int argc, char* argv[]);\n\n//String \n\n//\n//main-10\n//-100\n\n//: This is unexcusable. How could someone in their right mind define\n//: a variable called 'main'!?\n//: The new define is after the main method\nint mainZ = 100, maintm = 0;\n\n//\nint stagecolor = 1;\nint sta = 1, stb = 4, stc = 0;\n\n//\nint fast = 1;\n\n//\nint trap = 1;\n\n//\nint tyuukan = 0;\n\n\n//\nint ending = 0;\n\n\n//()\nint stagerr, stagepoint;\n//\nint over = 0;\n\n//\nint stageonoff = 0;\n\n\n//\nvoid Mainprogram();\nvoid rpaint();\nint maint;\n\n\n//\n//(\n#define wait(i) SDL_Delay(i)\nvoid wait2(long stime, long etime, int FLAME_TIME);\nint rand(int Rand);\n#define end() exit(0)\n\n//\nUint32 color;\nUint32 gfxcolor;\nvoid setfont(int a);\nvoid setcolor(int red, int green, int blue);\nvoid setc0();\nvoid setc1();\nvoid drawpixel(int a, int b);\nvoid drawline(int a, int b, int c, int d);\nvoid drawrect(int a, int b, int c, int d);\nvoid fillrect(int a, int b, int c, int d);\nvoid drawarc(int a, int b, int c, int d);\nvoid fillarc(int a, int b, int c, int d);\nvoid FillScreen();\nSDL_Surface *grap[161][8];\nSDL_Surface *mgrap[51];\nSDL_Surface *loadimage(string b);\nSDL_Surface *loadimage(int a, int x, int y, int r, int z);\nint mirror;\nvoid drawimage(SDL_Surface * mx, int a, int b);\nvoid drawimage(SDL_Surface * mx, int a, int b, int c, int d, int e, int f);\nvoid setre();\nvoid setre2();\nvoid setno();\nMix_Music *otom[6];\nMix_Chunk *oto[19];\nvoid ot(Mix_Chunk * x);\nvoid bgmchange(Mix_Music * x);\n\n//\nvoid str(string c, int a, int b);\n\n\n//)\n\nvoid stagecls();\nvoid stage();\nvoid stagep();\n\n\n\n\n\n//1-\n//10-\n//\n\n\n\n//\nint t, tt, t1, t2, t3, t4;\n\n\n//\nint zxon, zzxon;\n\n//\nint key, keytm;\n\n//\ndouble pai = 3.1415926535;\n\n\n//\n#define smax 31\nint sx, sco;\nint sa[smax], sb[smax], sc[smax], sd[smax], stype[smax], sxtype[smax],\n    sr[smax];\nint sgtype[smax];\n\n\n\n//\nint mainmsgtype;\nint ma, mb, mnobia, mnobib, mhp;\nint mc, md, macttype, atkon, atktm, mactsok, msstar, nokori =\n    3, mactp, mact;\n\nint mtype, mxtype, mtm, mzz;\nint mzimen, mrzimen, mkasok, mmuki, mmukitm, mjumptm, mkeytm, mcleartm;\nint mmutekitm, mmutekion;\nint mztm, mztype;\nint actaon[7];\n//\nint mmsgtm, mmsgtype;\n\nint mascrollmax = 21000;\t//9000\n\n\n\n\n//\nvoid tyobi(int x, int y, int type);\nvoid brockbreak(int t);\n#define tmax 641\nint tco;\nint ta[tmax], tb[tmax], tc[tmax], td[tmax], thp[tmax], ttype[tmax];\nint titem[tmax], txtype[tmax];\n\n//\nint tmsgtm, tmsgtype, tmsgx, tmsgy, tmsgnobix, tmsgnobiy, tmsg;\nvoid ttmsg();\nvoid txmsg(string x, int a);\nvoid setfont(int x, int y);\n\n//\nvoid eyobi(int xa, int xb, int xc, int xd, int xe, int xf, int xnobia,\n\t   int xnobib, int xgtype, int xtm);\n#define emax 201\nint eco;\nint ea[emax], eb[emax], enobia[emax], enobib[emax], ec[emax], ed[emax];\nint ee[emax], ef[emax], etm[emax];\nint egtype[emax];\n\n\n\n//\nvoid ayobi(int xa, int xb, int xc, int xd, int xnotm, int xtype,\n\t   int xxtype);\nvoid tekizimen();\n#define amax 24\nint aco;\nint aa[amax], ab[amax], anobia[amax], anobib[amax], ac[amax], ad[amax];\nint ae[amax], af[amax], abrocktm[amax];\nint aacta[amax], aactb[amax], azimentype[amax], axzimen[amax];\nint atype[amax], axtype[amax], amuki[amax], ahp[amax];\nint anotm[amax], anx[160], any[160];\nint atm[amax], a2tm[amax];\nint amsgtm[amax], amsgtype[amax];\n\n//\n#define bmax 81\nint bco;\nint ba[bmax], bb[bmax], btm[bmax];\nint btype[bmax], bxtype[bmax], bz[bmax];\n\n\n//\n#define nmax 41\nint nxxmax, nco;\nint na[nmax], nb[nmax], nc[nmax], nd[nmax], ntype[nmax];\nint ne[nmax], nf[nmax], ng[nmax], nx[nmax];\n\n\n//\n#define srmax 21\nint srco;\nint sra[srmax], srb[srmax], src[srmax], srd[srmax], sre[srmax], srf[srmax];\nint srtype[srmax], srgtype[srmax], sracttype[srmax], srsp[srmax];\nint srmuki[srmax], sron[srmax], sree[srmax];\nint srsok[srmax], srmovep[srmax], srmove[srmax];\n\n\n\n\n\n//\nint fx = 0, fy = 0, fzx, fzy, scrollx, scrolly;\n//\n\n//: \"fma\" already exists, so call it something else and add a define\nint fmaZ = 0, fmb = 0;\n#define fma fmaZ\n\n//\nint kscroll = 0;\n//(2)(256-224)\nint fxmax = 48000, fymax = 42000;\n\n\n\n//\nbyte stagedate[17][2001];\n\n//\nint blacktm = 1, blackx = 0;\n\n\n\n//\nint xx[91];\ndouble xd[11];\nstring xs[31];\n\n\n//\n//: Do with this what we did with fma\nlong stimeZ;\n#define stime stimeZ\n","// -*- C++ -*-\n//===--------------------------- iosfwd -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOSFWD\n#define _LIBCPP_IOSFWD\n\n/*\n    iosfwd synopsis\n\nnamespace std\n{\n\ntemplate<class charT> struct char_traits;\ntemplate<class T>     class allocator;\n\nclass ios_base;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ios;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_streambuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_istream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ostream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_iostream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringbuf;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_istringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_ostringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_filebuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ifstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ofstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_fstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class istreambuf_iterator;\ntemplate <class charT, class traits = char_traits<charT> > class ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class state> class fpos;\ntypedef fpos<char_traits<char>::state_type>    streampos;\ntypedef fpos<char_traits<wchar_t>::state_type> wstreampos;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <wchar.h>  // for mbstate_t\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS ios_base;\n\ntemplate<class _CharT>  struct _LIBCPP_TYPE_VIS char_traits;\ntemplate<class _Tp>     class _LIBCPP_TYPE_VIS allocator;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_ios;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_streambuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_istream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_ostream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_iostream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_stringbuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_istringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_ostringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_stringstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_filebuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_ifstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_ofstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_fstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS istreambuf_iterator;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class _State>             class _LIBCPP_TYPE_VIS fpos;\ntypedef fpos<mbstate_t>    streampos;\ntypedef fpos<mbstate_t>    wstreampos;\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntypedef fpos<mbstate_t>    u16streampos;\ntypedef fpos<mbstate_t>    u32streampos;\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef long long streamoff;        // for char_traits in <string>\n\ntemplate <class _CharT,             // for <stdexcept>\n          class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_string;\ntypedef basic_string<char, char_traits<char>, allocator<char> > string;\ntypedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOSFWD\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a);\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b);\n    template<class U> bool owner_before(weak_ptr<U> const& b);\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <cstring>\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n    #include <cassert>\n#endif\n\n#if __has_feature(cxx_atomic)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// addressof\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return (_Tp*)&(char&)__x;\n}\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TYPE_VIS pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two test(...);\n    template <class _Up> static char test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#if !defined(_LIBCPP_HAS_NO_ADVANCED_SFINAE) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TYPE_VIS allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, pointer, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a)\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n            __begin2 += _Np;\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(::operator new(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {::operator delete((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(::operator new(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {::operator delete((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TYPE_VIS raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T1)\n#endif\n                                ,\n                                bool = is_empty<_T2>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T2)\n#endif\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : __first_(__p.first()),\n          __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            __first_ = __p.first();\n            __second_ = __p.second();\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : __first_(_VSTD::forward<_T1>(__p.first())),\n          __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            __first_ = _VSTD::forward<_T1>(__p.first());\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            __second_ = __p.second();\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T2(__p.second()), __first_(__p.first()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T2::operator=(__p.second());\n            __first_ = __p.first();\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2>(__p.second())), __first_(_VSTD::move(__p.first())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T2::operator=(_VSTD::forward<_T2>(__p.second()));\n            __first_ = _VSTD::move(__p.first());\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), _T2(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            _T2::operator=(__p.second());\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), _T2(_VSTD::move(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            _T2::operator=(_VSTD::move(__p.second()));\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : base(__p) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            base::operator=(__p);\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : base(_VSTD::move(__p)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            base::operator=(_VSTD::move(__p));\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_scalar<_Ptr1>::value &&\n                                         !is_pointer<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, true>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS default_delete\n{\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TYPE_VIS unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TYPE_VIS unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp,\n              class = typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value>::type\n             >\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp,\n              class = typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value>::type\n             >\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp,\n              class = typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value>::type\n             >\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp,\n              class = typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value>::type\n             >\n    _LIBCPP_INLINE_VISIBILITY void reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset() _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer())\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\ntemplate <class _Tp> struct hash;\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)\n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = *(const _Size*)__data;\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = *(const _Size*)__s;\n      const _Size __b = *(const _Size*)(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = *(const uint32_t*)(__s);\n      const uint32_t __b = *(const uint32_t*)(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = *(const _Size*)(__s) * __k1;\n    const _Size __b = *(const _Size*)(__s + 8);\n    const _Size __c = *(const _Size*)(__s + __len - 8) * __k2;\n    const _Size __d = *(const _Size*)(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(*(const _Size*)(__s),\n                                         *(const _Size*)(__s + 8),\n                                         *(const _Size*)(__s + 16),\n                                         *(const _Size*)(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = *(const _Size*)(__s + 24);\n    _Size __a = *(const _Size*)(__s) +\n                (__len + *(const _Size*)(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += *(const _Size*)(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += *(const _Size*)(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = *(const _Size*)(__s + 16) + *(const _Size*)(__s + __len - 32);\n    __z += *(const _Size*)(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += *(const _Size*)(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += *(const _Size*)(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)\n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = *(const _Size*)(__s + __len - 40);\n  _Size __y = *(const _Size*)(__s + __len - 16) +\n              *(const _Size*)(__s + __len - 56);\n  _Size __z = __hash_len_16(*(const _Size*)(__s + __len - 48) + __len,\n                          *(const _Size*)(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + *(const _Size*)(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + *(const _Size*)(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + *(const _Size*)(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + *(const _Size*)(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + *(const _Size*)(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TYPE_VIS hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, ++__r)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, ++__r, --__n)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, --__n)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS weak_ptr;\n\nclass __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_owners_ + 1;}\n};\n\nclass __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? &__data_.first().second() : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_pointer>::other __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_emplace>::other __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS shared_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        explicit shared_ptr(_Yp* __p);\n    template<class _Yp, class _Dp,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        shared_ptr(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a);\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        shared_ptr(auto_ptr<_Yp>&& __r);\n#else\n    template<class _Yp,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        shared_ptr(auto_ptr<_Yp> __r);\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp,\n                 class = typename enable_if\n                 <\n                    !is_array<_Yp>::value &&\n                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value\n                 >::type\n             >\n       shared_ptr(unique_ptr<_Yp, _Dp>&&,\n       typename enable_if<!is_lvalue_reference<_Dp>::value, __nat>::type = __nat());\n    template <class _Yp, class _Dp,\n                 class = typename enable_if\n                 <\n                    !is_array<_Yp>::value &&\n                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value\n                 >::type\n             >\n       shared_ptr(unique_ptr<_Yp, _Dp>&&,\n       typename enable_if<is_lvalue_reference<_Dp>::value, __nat>::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp,\n                 class = typename enable_if\n                 <\n                    !is_array<_Yp>::value &&\n                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value\n                 >::type\n             > shared_ptr(unique_ptr<_Yp, _Dp>,\n       typename enable_if<!is_lvalue_reference<_Dp>::value, __nat>::type = __nat());\n    template <class _Yp, class _Dp,\n                 class = typename enable_if\n                 <\n                    !is_array<_Yp>::value &&\n                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value\n                 >::type\n             >\n       shared_ptr(unique_ptr<_Yp, _Dp>,\n       typename enable_if<is_lvalue_reference<_Dp>::value, __nat>::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) _NOEXCEPT\n        {\n            if (__e)\n                __e->__weak_this_ = *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS shared_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS weak_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc, class>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp, class>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r)\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r)\n#endif\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp, class>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n           typename enable_if<!is_lvalue_reference<_Dp>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp, class>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n           typename enable_if<is_lvalue_reference<_Dp>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*,\n                                 reference_wrapper<typename remove_reference<_Dp>::type>,\n                                 allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS weak_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS shared_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        throw bad_weak_ptr();\n#else\n        assert(!\"bad_weak_ptr\");\n#endif\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\ntemplate <class _Tp> struct owner_less;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n#if __has_feature(cxx_atomic)\n\nclass __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // __has_feature(cxx_atomic)\n\n//enum class\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n\nvoid declare_reachable(void* __p);\nvoid declare_no_pointers(char* __p, size_t __n);\nvoid undeclare_no_pointers(char* __p, size_t __n);\npointer_safety get_pointer_safety() _NOEXCEPT;\nvoid* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\nvoid* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos, size_type n = npos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const_pointer s, const allocator_type& a = allocator_type());\n    basic_string(const_pointer s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    basic_string& operator=(const_pointer s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(const_pointer s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(const basic_string& str, size_type pos, size_type n);\n    basic_string& append(const_pointer s, size_type n);\n    basic_string& append(const_pointer s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n);\n    basic_string& assign(const_pointer s, size_type n);\n    basic_string& assign(const_pointer s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    basic_string& insert(size_type pos, const_pointer s, size_type n);\n    basic_string& insert(size_type pos, const_pointer s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const_pointer s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const_pointer s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, const_pointer s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const_pointer s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(pointer s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value)\n\n    const_pointer c_str() const noexcept;\n    const_pointer data() const noexcept;\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(const_pointer s, size_type pos, size_type n) const noexcept;\n    size_type find(const_pointer s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type rfind(const_pointer s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const_pointer s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(const_pointer s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const_pointer s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(const_pointer s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const_pointer s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const_pointer s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const_pointer s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(const_pointer s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const_pointer s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2) const;\n    int compare(const_pointer s) const noexcept;\n    int compare(size_type pos1, size_type n1, const_pointer s) const;\n    int compare(size_type pos1, size_type n1, const_pointer s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n#if defined(_LIBCPP_NO_EXCEPTIONS) || defined(_LIBCPP_DEBUG)\n#include <cassert>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TYPE_VIS fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TYPE_VIS char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\nint\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return memcmp(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t length(const char_type* __s) {return strlen(__s);}\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return (const char_type*)memchr(__s, to_int_type(__a), __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)memmove(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)memcpy(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return wmemcmp(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t length(const char_type* __s)\n        {return wcslen(__s);}\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return (const char_type*)wmemchr(__s, __a, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)wmemmove(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)wmemcpy(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return (char_type*)wmemset(__s, __a, __n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xDFFF);}\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<char16_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<char32_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass __basic_string_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"basic_string\");\n#else\n    assert(!\"basic_string length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"basic_string\");\n#else\n    assert(!\"basic_string out_of_range\");\n#endif\n}\n\n#ifdef _MSC_VER\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _MSC_VER\n_LIBCPP_EXTERN_TEMPLATE(class __basic_string_common<true>)\n#ifdef _MSC_VER\n#pragma warning( pop )\n#endif // _MSC_VER\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n#ifdef _LIBCPP_DEBUG\n    typedef __debug_iter<basic_string, pointer>          iterator;\n    typedef __debug_iter<basic_string, const_pointer>    const_iterator;\n\n    friend class __debug_iter<basic_string, pointer>;\n    friend class __debug_iter<basic_string, const_pointer>;\n#elif defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__mask = size_type(~0) >> 1};\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n    union __lx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__lx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\n#ifdef _LIBCPP_DEBUG\n\n    pair<iterator*, const_iterator*> __iterator_list_;\n\n    _LIBCPP_INLINE_VISIBILITY iterator*&       __get_iterator_list(iterator*)       {return __iterator_list_.first;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator*& __get_iterator_list(const_iterator*) {return __iterator_list_.second;}\n\n#endif  // _LIBCPP_DEBUG\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a);\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const_pointer __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const_pointer __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const_pointer __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const_pointer __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n = npos,\n                 const allocator_type& __a = allocator_type());\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n                   is_nothrow_move_assignable<allocator_type>::value);\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const_pointer __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_DEBUG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(data());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(data() + size());}\n#else  // _LIBCPP_DEBUG\n    _LIBCPP_INLINE_VISIBILITY iterator       begin()       {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const {return const_iterator(this, data());}\n    _LIBCPP_INLINE_VISIBILITY iterator       end()         {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY const_iterator end() const   {return const_iterator(this, data() + size());}\n#endif  // _LIBCPP_DEBUG\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap() : __min_cap) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos);\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const_pointer __s)         {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n);\n    basic_string& append(const_pointer __s, size_type __n);\n    basic_string& append(const_pointer __s);\n    basic_string& append(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        append(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        append(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n);\n    basic_string& assign(const_pointer __s, size_type __n);\n    basic_string& assign(const_pointer __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n);\n    basic_string& insert(size_type __pos, const_pointer __s, size_type __n);\n    basic_string& insert(size_type __pos, const_pointer __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const_pointer __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const_pointer __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const_pointer __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const_pointer __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(pointer __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer data() const _NOEXCEPT  {return __get_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const_pointer __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const_pointer __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(const_pointer __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const_pointer __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const_pointer __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const_pointer __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_of(const_pointer __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const_pointer __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const_pointer __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const_pointer __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_not_of(const_pointer __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const_pointer __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2) const;\n    int compare(const_pointer __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const_pointer __s) const;\n    int compare(size_type __pos1, size_type __n1, const_pointer __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#else\n        {return __r_.first().__s.__size_ >> 1;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return __r_.first().__s.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return __r_.first().__s.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align(size_type __s) _NOEXCEPT\n            {return __s + (__a-1) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? __min_cap :\n                 __align<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    void __init(const_pointer __s, size_type __sz, size_type __reserve);\n    void __init(const_pointer __s, size_type __sz);\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    typename enable_if\n    <\n         __is_input_iterator  <_InputIterator>::value &&\n        !__is_forward_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const_pointer __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type&, allocator_type&, false_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n#ifndef _LIBCPP_DEBUG\n_LIBCPP_INLINE_VISIBILITY inline\n#endif\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#ifdef _LIBCPP_DEBUG\n    iterator::__remove_all(this);\n    const_iterator::__remove_all(this);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n#ifndef _LIBCPP_DEBUG\n_LIBCPP_INLINE_VISIBILITY inline\n#endif\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#ifdef _LIBCPP_DEBUG\n                                                                        __pos\n#endif\n                                                                      )\n{\n#ifdef _LIBCPP_DEBUG\n    const_iterator __beg = begin();\n    if (__iterator_list_.first)\n    {\n        for (iterator* __p = __iterator_list_.first; __p;)\n        {\n            if (*__p - __beg > static_cast<difference_type>(__pos))\n            {\n                iterator* __n = __p;\n                __p = __p->__next;\n                __n->__remove_owner();\n            }\n            else\n                __p = __p->__next;\n        }\n    }\n    if (__iterator_list_.second)\n    {\n        for (const_iterator* __p = __iterator_list_.second; __p;)\n        {\n            if (*__p - __beg > static_cast<difference_type>(__pos))\n            {\n                const_iterator* __n = __p;\n                __p = __p->__next;\n                __n->__remove_owner();\n            }\n            else\n                __p = __p->__next;\n        }\n    }\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n    : __r_(__a)\n{\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const_pointer __s, size_type __sz, size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(__p, __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const_pointer __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(__p, __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const_pointer __s)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    __init(__s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const_pointer __s, const allocator_type& __a)\n    : __r_(__a)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    __init(__s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const_pointer __s, size_type __n)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    __init(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const_pointer __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    __init(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(__str.__get_long_pointer(), __str.__get_long_size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(__str.__get_long_pointer(), __str.__get_long_size());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#ifdef _LIBCPP_DEBUG\n    __str.__invalidate_all_iterators();\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__a == __str.__alloc() || !__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(__str.__get_long_pointer(), __str.__get_long_size());\n    __str.__zero();\n#ifdef _LIBCPP_DEBUG\n    __str.__invalidate_all_iterators();\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const_pointer __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(__p, __old_p, __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(__p + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(__p + __n_copy + __n_add, __old_p + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(__p, __old_p, __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(__p + __n_copy + __n_add, __old_p + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const_pointer __s, size_type __n)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        pointer __p = __get_pointer();\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str);\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n               is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str)\n{\n    return assign(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const_pointer __s)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const_pointer __s, size_type __n)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            pointer __p = __get_pointer();\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(__p + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__sz == __cap)\n        __grow_by(__cap, 1, __sz, __sz, 0);\n    pointer __p = __get_pointer() + __sz;\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __set_size(__sz+1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_InputIterator __first, _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer() + __sz;\n        for (; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n        traits_type::assign(*__p, value_type());\n        __set_size(__sz + __n);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const_pointer __s)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const_pointer __s, size_type __n)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            pointer __p = __get_pointer();\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        pointer __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = __get_pointer();\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = __get_long_pointer();\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n    size_type __old_sz = size();\n    difference_type __ip = __pos - begin();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    pointer __p = __get_pointer();\n    _VSTD::rotate(__p + __ip, __p + __old_sz, __p + size());\n    return iterator(__p + __ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        pointer __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = __get_pointer();\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = __get_long_pointer();\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const_pointer __s)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    pointer __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = __get_long_pointer();\n    }\n    else\n    {\n        __p = __get_pointer();\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const_pointer __s, size_type __n2)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        pointer __p = __get_pointer();\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    pointer __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = __get_pointer();\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = __get_long_pointer();\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    for (; true; ++__i1, ++__j1)\n    {\n        if (__i1 == __i2)\n        {\n            if (__j1 != __j2)\n                insert(__i1, __j1, __j2);\n            break;\n        }\n        if (__j1 == __j2)\n        {\n            erase(__i1, __i2);\n            break;\n        }\n        traits_type::assign(const_cast<value_type&>(*__i1), *__j1);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const_pointer __s)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const_pointer __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const_pointer __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        pointer __p = __get_pointer();\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n#ifdef _LIBCPP_DEBUG\n    assert(!empty());\n#endif\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - 1;\n#else\n    return __m - 1;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == 0)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(__new_data, __p, size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const\n{\n#ifdef __LIBCPP_DEBUG\n    assert(__pos <= size());\n#endif\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos)\n{\n#ifdef __LIBCPP_DEBUG\n    assert(__pos < size());\n#endif\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n#ifdef _LIBCPP_DEBUG\n    assert(!empty());\n#endif\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n#ifdef _LIBCPP_DEBUG\n    assert(!empty());\n#endif\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n#ifdef _LIBCPP_DEBUG\n    assert(!empty());\n#endif\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n#ifdef _LIBCPP_DEBUG\n    assert(!empty());\n#endif\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(pointer __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_alloc(__alloc(), __str.__alloc());\n#ifdef _LIBCPP_DEBUG\n    __invalidate_all_iterators();\n    __str.__invalidate_all_iterators();\n#endif  // _LIBCPP_DEBUG\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const_pointer __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __sz = size();\n    if (__pos > __sz || __sz - __pos < __n)\n        return npos;\n    if (__n == 0)\n        return __pos;\n    const_pointer __p = data();\n    const_pointer __r = _VSTD::search(__p + __pos, __p + __sz, __s, __s + __n,\n                                     __traits_eq<traits_type>());\n    if (__r == __p + __sz)\n        return npos;\n    return static_cast<size_type>(__r - __p);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return find(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const_pointer __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return find(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    size_type __sz = size();\n    if (__pos >= __sz)\n        return npos;\n    const_pointer __p = data();\n    const_pointer __r = traits_type::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return npos;\n    return static_cast<size_type>(__r - __p);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const_pointer __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __sz = size();\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const_pointer __p = data();\n    const_pointer __r = _VSTD::find_end(__p, __p + __pos, __s, __s + __n,\n                                       __traits_eq<traits_type>());\n    if (__n > 0 && __r == __p + __pos)\n        return npos;\n    return static_cast<size_type>(__r - __p);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return rfind(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const_pointer __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return rfind(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    size_type __sz = size();\n    if (__sz)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        const_pointer __p = data();\n        for (const_pointer __ps = __p + __pos; __ps != __p;)\n        {\n            if (traits_type::eq(*--__ps, __c))\n                return static_cast<size_type>(__ps - __p);\n        }\n    }\n    return npos;\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const_pointer __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __sz = size();\n    if (__pos >= __sz || __n == 0)\n        return npos;\n    const_pointer __p = data();\n    const_pointer __r = _VSTD::find_first_of(__p + __pos, __p + __sz, __s,\n                                            __s + __n, __traits_eq<traits_type>());\n    if (__r == __p + __sz)\n        return npos;\n    return static_cast<size_type>(__r - __p);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find_first_of(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const_pointer __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return find_first_of(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const_pointer __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    if (__n != 0)\n    {\n        size_type __sz = size();\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        const_pointer __p = data();\n        for (const_pointer __ps = __p + __pos; __ps != __p;)\n        {\n            const_pointer __r = traits_type::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<size_type>(__ps - __p);\n        }\n    }\n    return npos;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return find_last_of(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const_pointer __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return find_last_of(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const_pointer __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __sz = size();\n    if (__pos < __sz)\n    {\n        const_pointer __p = data();\n        const_pointer __pe = __p + __sz;\n        for (const_pointer __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (traits_type::find(__s, __n, *__ps) == 0)\n                return static_cast<size_type>(__ps - __p);\n    }\n    return npos;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return find_first_not_of(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const_pointer __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return find_first_not_of(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    size_type __sz = size();\n    if (__pos < __sz)\n    {\n        const_pointer __p = data();\n        const_pointer __pe = __p + __sz;\n        for (const_pointer __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!traits_type::eq(*__ps, __c))\n                return static_cast<size_type>(__ps - __p);\n    }\n    return npos;\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const_pointer __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __sz = size();\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    const_pointer __p = data();\n    for (const_pointer __ps = __p + __pos; __ps != __p;)\n        if (traits_type::find(__s, __n, *--__ps) == 0)\n            return static_cast<size_type>(__ps - __p);\n    return npos;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return find_last_not_of(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const_pointer __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return find_last_not_of(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    size_type __sz = size();\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    const_pointer __p = data();\n    for (const_pointer __ps = __p + __pos; __ps != __p;)\n        if (!traits_type::eq(*--__ps, __c))\n            return static_cast<size_type>(__ps - __p);\n    return npos;\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __str.size();\n    int __result = traits_type::compare(data(), __str.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    size_type __sz = __str.size();\n    if (__pos2 > __sz)\n        this->__throw_out_of_range();\n    return compare(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2,\n                                                                  __sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const_pointer __s) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const_pointer __s) const\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const_pointer __s,\n                                                   size_type __n2) const\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.size() == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                            __rhs.data(),\n                                                            __lhs.size()) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) == 0;\n}\n\n// operator!=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\nint                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\nlong               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\nunsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\nlong long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\nunsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\nfloat       stof (const string& __str, size_t* __idx = 0);\ndouble      stod (const string& __str, size_t* __idx = 0);\nlong double stold(const string& __str, size_t* __idx = 0);\n\nstring to_string(int __val);\nstring to_string(unsigned __val);\nstring to_string(long __val);\nstring to_string(unsigned long __val);\nstring to_string(long long __val);\nstring to_string(unsigned long long __val);\nstring to_string(float __val);\nstring to_string(double __val);\nstring to_string(long double __val);\n\nint                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\nlong               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\nunsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\nlong long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\nunsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\nfloat       stof (const wstring& __str, size_t* __idx = 0);\ndouble      stod (const wstring& __str, size_t* __idx = 0);\nlong double stold(const wstring& __str, size_t* __idx = 0);\n\nwstring to_wstring(int __val);\nwstring to_wstring(unsigned __val);\nwstring to_wstring(long __val);\nwstring to_wstring(unsigned long __val);\nwstring to_wstring(long long __val);\nwstring to_wstring(unsigned long long __val);\nwstring to_wstring(float __val);\nwstring to_wstring(double __val);\nwstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _Ptr>\nsize_t _LIBCPP_INLINE_VISIBILITY __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TYPE_VIS hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n_LIBCPP_EXTERN_TEMPLATE(class basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class basic_string<wchar_t>)\n\nextern template\n    string\n    operator+<char, char_traits<char>, allocator<char> >(char const*, string const&);\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","#include \"DxLib.h\"\n\nextern int ma, t, tt;\nextern SDL_Surface *grap[161][8];\nextern SDL_Surface *mgrap[51];\nint x1;\nextern Mix_Music *otom[6];\nextern Mix_Chunk *oto[19];\n\nextern int anx[160], any[160];\nextern int ne[40], nf[40];\n\nvoid loadg(void)\n{\n\n    for (t = 0; t < 51; t++) {\n\tmgrap[t] = 0;\n    }\n    for (int i = 0; i < 161; i++)\n\tfor (int j = 0; j < 8; j++)\n\t    grap[i][j] = NULL;\n\n/*\nfor (t=0;t<161;t++){\nfor (tt=0;tt<8;tt++){\ngrap[t][tt]=0;\n}}\n*/\n\n//ma-=100;//mb==5000;\n//end();\n\n\n//\n\n// \n//SetTransColor( 9*16+9 , 255 , 255 ) ;\n\n//\n    mgrap[0] = LoadGraph(\"res/player.PNG\");\n//\n    mgrap[1] = LoadGraph(\"res/brock.PNG\");\n//\n    mgrap[2] = LoadGraph(\"res/item.PNG\");\n//\n    mgrap[3] = LoadGraph(\"res/teki.PNG\");\n//\n    mgrap[4] = LoadGraph(\"res/haikei.PNG\");\n//2\n    mgrap[5] = LoadGraph(\"res/brock2.PNG\");\n//\n    mgrap[6] = LoadGraph(\"res/omake.PNG\");\n//2\n    mgrap[7] = LoadGraph(\"res/omake2.PNG\");\n//\n    mgrap[30] = LoadGraph(\"res/syobon3.PNG\");\n\n\n//\n    grap[40][0] = DerivationGraph(0, 0, 30, 36, mgrap[0]);\n    grap[0][0] = DerivationGraph(31 * 4, 0, 30, 36, mgrap[0]);\n    grap[1][0] = DerivationGraph(31 * 1, 0, 30, 36, mgrap[0]);\n    grap[2][0] = DerivationGraph(31 * 2, 0, 30, 36, mgrap[0]);\n    grap[3][0] = DerivationGraph(31 * 3, 0, 30, 36, mgrap[0]);\n    grap[41][0] = DerivationGraph(50, 0, 51, 73, mgrap[6]);\n\n    x1 = 1;\n//\n    for (t = 0; t <= 6; t++) {\n\tgrap[t][x1] = DerivationGraph(33 * t, 0, 30, 30, mgrap[x1]);\n\tgrap[t + 30][x1] = DerivationGraph(33 * t, 33, 30, 30, mgrap[x1]);\n\tgrap[t + 60][x1] = DerivationGraph(33 * t, 66, 30, 30, mgrap[x1]);\n\tgrap[t + 90][x1] = DerivationGraph(33 * t, 99, 30, 30, mgrap[x1]);\n    }\n    grap[8][x1] = DerivationGraph(33 * 7, 0, 30, 30, mgrap[x1]);\n    grap[16][x1] = DerivationGraph(33 * 6, 0, 24, 27, mgrap[2]);\n    grap[10][x1] = DerivationGraph(33 * 9, 0, 30, 30, mgrap[x1]);\n    grap[40][x1] = DerivationGraph(33 * 9, 33, 30, 30, mgrap[x1]);\n    grap[70][x1] = DerivationGraph(33 * 9, 66, 30, 30, mgrap[x1]);\n    grap[100][x1] = DerivationGraph(33 * 9, 99, 30, 30, mgrap[x1]);\n//2\n    x1 = 5;\n    for (t = 0; t <= 6; t++) {\n\tgrap[t][x1] = DerivationGraph(33 * t, 0, 30, 30, mgrap[x1]);\n    }\n    grap[10][5] = DerivationGraph(33 * 1, 33, 30, 30, mgrap[x1]);\n    grap[11][5] = DerivationGraph(33 * 2, 33, 30, 30, mgrap[x1]);\n    grap[12][5] = DerivationGraph(33 * 0, 66, 30, 30, mgrap[x1]);\n    grap[13][5] = DerivationGraph(33 * 1, 66, 30, 30, mgrap[x1]);\n    grap[14][5] = DerivationGraph(33 * 2, 66, 30, 30, mgrap[x1]);\n\n//\n    x1 = 2;\n    for (t = 0; t <= 5; t++) {\n\tgrap[t][x1] = DerivationGraph(33 * t, 0, 30, 30, mgrap[x1]);\n    }\n\n//\n    x1 = 3;\n    grap[0][x1] = DerivationGraph(33 * 0, 0, 30, 30, mgrap[x1]);\n    grap[1][x1] = DerivationGraph(33 * 1, 0, 30, 43, mgrap[x1]);\n    grap[2][x1] = DerivationGraph(33 * 2, 0, 30, 30, mgrap[x1]);\n    grap[3][x1] = DerivationGraph(33 * 3, 0, 30, 44, mgrap[x1]);\n    grap[4][x1] = DerivationGraph(33 * 4, 0, 33, 35, mgrap[x1]);\n    grap[5][x1] = DerivationGraph(0, 0, 37, 55, mgrap[7]);\n    grap[6][x1] = DerivationGraph(38 * 2, 0, 36, 50, mgrap[7]);\n    grap[150][x1] = DerivationGraph(38 * 2 + 37 * 2, 0, 36, 50, mgrap[7]);\n    grap[7][x1] = DerivationGraph(33 * 6 + 1, 0, 32, 32, mgrap[x1]);\n    grap[8][x1] = DerivationGraph(38 * 2 + 37 * 3, 0, 37, 47, mgrap[7]);\n    grap[151][x1] = DerivationGraph(38 * 3 + 37 * 3, 0, 37, 47, mgrap[7]);\n    grap[9][x1] = DerivationGraph(33 * 7 + 1, 0, 26, 30, mgrap[x1]);\n    grap[10][x1] = DerivationGraph(214, 0, 46, 16, mgrap[6]);\n\n//\n    grap[30][x1] = DerivationGraph(0, 56, 30, 36, mgrap[7]);\n    grap[155][x1] = DerivationGraph(31 * 3, 56, 30, 36, mgrap[7]);\n    grap[31][x1] = DerivationGraph(50, 74, 49, 79, mgrap[6]);\n\n\n    grap[80][x1] = DerivationGraph(151, 31, 70, 40, mgrap[4]);\n    grap[81][x1] = DerivationGraph(151, 72, 70, 40, mgrap[4]);\n    grap[130][x1] = DerivationGraph(151 + 71, 72, 70, 40, mgrap[4]);\n    grap[82][x1] = DerivationGraph(33 * 1, 0, 30, 30, mgrap[5]);\n    grap[83][x1] = DerivationGraph(0, 0, 49, 48, mgrap[6]);\n    grap[84][x1] = DerivationGraph(33 * 5 + 1, 0, 30, 30, mgrap[x1]);\n    grap[86][x1] = DerivationGraph(102, 66, 49, 59, mgrap[6]);\n    grap[152][x1] = DerivationGraph(152, 66, 49, 59, mgrap[6]);\n\n    grap[90][x1] = DerivationGraph(102, 0, 64, 63, mgrap[6]);\n\n    grap[100][x1] = DerivationGraph(33 * 1, 0, 30, 30, mgrap[2]);\n    grap[101][x1] = DerivationGraph(33 * 7, 0, 30, 30, mgrap[2]);\n    grap[102][x1] = DerivationGraph(33 * 3, 0, 30, 30, mgrap[2]);\n\n//grap[104][x1] = DerivationGraph( 33*2, 0, 30, 30, mgrap[5]) ;\n    grap[105][x1] = DerivationGraph(33 * 5, 0, 30, 30, mgrap[2]);\n    grap[110][x1] = DerivationGraph(33 * 4, 0, 30, 30, mgrap[2]);\n\n\n//\n    x1 = 4;\n    grap[0][x1] = DerivationGraph(0, 0, 150, 90, mgrap[x1]);\n    grap[1][x1] = DerivationGraph(151, 0, 65, 29, mgrap[x1]);\n    grap[2][x1] = DerivationGraph(151, 31, 70, 40, mgrap[x1]);\n    grap[3][x1] = DerivationGraph(0, 91, 100, 90, mgrap[x1]);\n    grap[4][x1] = DerivationGraph(151, 113, 51, 29, mgrap[x1]);\n    grap[5][x1] = DerivationGraph(222, 0, 28, 60, mgrap[x1]);\n    grap[6][x1] = DerivationGraph(151, 143, 90, 40, mgrap[x1]);\n    grap[30][x1] = DerivationGraph(293, 0, 149, 90, mgrap[x1]);\n    grap[31][x1] = DerivationGraph(293, 92, 64, 29, mgrap[x1]);\n\n//\n    grap[20][x1] = DerivationGraph(40, 182, 40, 60, mgrap[x1]);\n\n\n//\n    x1 = 5;\n    grap[0][x1] = DerivationGraph(167, 0, 45, 45, mgrap[6]);\n\n\n\n\n\n\n\n\n\n//\n//int GrHandle=0;\n    x1 = 3;\n    for (t = 0; t <= 140; t++) {\n\tif (grap[t][x1]) {\n\t    anx[t] = grap[t][x1]->w;\n\t    any[t] = grap[t][x1]->h;\n//GetGraphSize(grap[t][x1] ,&anx[t] ,&any[t]);\n\t    anx[t] *= 100;\n\t    any[t] *= 100;\n\t} else {\n\t    anx[t] = 0;\n\t    any[t] = 0;\n\t}\n    }\n    anx[79] = 120 * 100;\n    any[79] = 15 * 100;\n    anx[85] = 25 * 100;\n    any[85] = 30 * 10 * 100;\n\n//\n    x1 = 4;\n    for (t = 0; t < 40; t++) {\n\tif (grap[t][x1]) {\n\t    ne[t] = grap[t][x1]->w;\n\t    nf[t] = grap[t][x1]->h;\n//GetGraphSize(grap[t][x1] ,&ne[t] ,&nf[t]);\n//ne[t]*=100;nf[t]*=100;\n\t} else {\n\t    ne[t] = 0;\n\t    nf[t] = 0;\n\t}\n    }\n\n/*\nanx[0]=30;any[0]=30;\nanx[1]=30;any[1]=43;\nanx[2]=30;any[2]=30;\nanx[3]=30;any[3]=44;\n*/\n\n\n\n\n\n\n\n\n\n//ogg\n//try{\n//oto[2] = LoadSoundMem( \"SE/1.mp3\" ) ;\n    otom[1] = LoadMusicMem(\"BGM/field.ogg\"); //50\n    otom[2] = LoadMusicMem(\"BGM/dungeon.ogg\"); //40\n    otom[3] = LoadMusicMem(\"BGM/star4.ogg\"); //50\n    otom[4] = LoadMusicMem(\"BGM/castle.ogg\"); //50\n    otom[5] = LoadMusicMem(\"BGM/puyo.ogg\"); //50\n//otom[6]=LoadMusicMem( \"BGM/last.ogg\");\n//ChangeVolumeSoundMem(50, otom[6]);\n\n    oto[1] = LoadSoundMem(\"SE/jump.ogg\");\n//oto[2] = LoadSoundMem(\"SE/brockcoin.ogg\");\n    oto[3] = LoadSoundMem(\"SE/brockbreak.ogg\");\n    oto[4] = LoadSoundMem(\"SE/coin.ogg\");\n    oto[5] = LoadSoundMem(\"SE/humi.ogg\");\n    oto[6] = LoadSoundMem(\"SE/koura.ogg\");\n    oto[7] = LoadSoundMem(\"SE/dokan.ogg\");\n    oto[8] = LoadSoundMem(\"SE/brockkinoko.ogg\");\n    oto[9] = LoadSoundMem(\"SE/powerup.ogg\");\n    oto[10] = LoadSoundMem(\"SE/kirra.ogg\");\n    oto[11] = LoadSoundMem(\"SE/goal.ogg\");\n    oto[12] = LoadSoundMem(\"SE/death.ogg\");\n    oto[13] = LoadSoundMem(\"SE/Pswitch.ogg\");\n    oto[14] = LoadSoundMem(\"SE/jumpBlock.ogg\");\n    oto[15] = LoadSoundMem(\"SE/hintBlock.ogg\");\n    oto[16] = LoadSoundMem(\"SE/4-clear.ogg\");\n    oto[17] = LoadSoundMem(\"SE/allclear.ogg\");\n    oto[18] = LoadSoundMem(\"SE/tekifire.ogg\");\n\n//}catch( int num){end();}\n\n\n//-20000-20\n//SetLoopPosSoundMem( 1,oto[104]) ;\n//SetLoopSamplePosSoundMem(44100,oto[104]);\n//SetLoopSamplePosSoundMem(22050,oto[104]);\n\n}\n\nextern bool sound;\nvoid parseArgs(int argc, char* argv[])\n{\n    if(argc <= 1) return;\n    for(int i = 0; i < argc; i++)\n    {\n        if(!strcasecmp(argv[i], \"-nosound\")) sound = false;\n    }\n}\n","#include \"DxLib.h\"\n\nSDL_Joystick* joystick;\n\nbool keysHeld[SDLK_LAST];\nbool sound = true;\nvoid deinit();\nint DxLib_Init()\n{\n    atexit(deinit);\n    setlocale(LC_CTYPE, \"ja_JP.UTF-8\");\n\n    if (SDL_Init(SDL_INIT_EVERYTHING) < 0) {\n\tfprintf(stderr, \"Unable to init SDL: %s\\n\", SDL_GetError());\n\treturn -1;\n    }\n\n    if (!\n\t(screen =\n\t SDL_SetVideoMode(480 /*(int)fmax/100 */ ,\n\t\t\t  420 /*(int)fymax/100 */ , 32,\n\t\t\t  SDL_SWSURFACE | SDL_DOUBLEBUF))) {\n\tSDL_Quit();\n\treturn -1;\n    }\n\n    SDL_WM_SetCaption(\"Syobon Action ()\",\n\t\t      NULL);\n    SDL_ShowCursor(SDL_DISABLE);\r\n\r\n    if(IMG_Init(IMG_INIT_PNG) != IMG_INIT_PNG)\r\n    {\r\n        fprintf(stderr, \"Unable to init SDL_img: %s\\n\", IMG_GetError());\r\n        return -1;\r\n    }\n\n    //Initialize font\n    if (TTF_Init() == -1) {\n\tfprintf(stderr, \"Unable to init SDL_ttf: %s\\n\", TTF_GetError());\n\treturn -1;\n    }\n\n    //Audio Rate, Audio Format, Audio Channels, Audio Buffers\n#define AUDIO_CHANNELS 4\n    if (sound && Mix_OpenAudio(22050, AUDIO_S16SYS, AUDIO_CHANNELS, 1024)) {\n        fprintf(stderr, \"Unable to init SDL_mixer: %s\\n\", Mix_GetError());\n        sound = false;\n        }\n    //Try to get a joystick\n    joystick = SDL_JoystickOpen(0);\n\n    for (int i = 0; i < SDLK_LAST; i++)\n\tkeysHeld[i] = false;\n    for (int i = 0; i < FONT_MAX; i++)\n\tfont[i] = NULL;\n    srand(time(NULL));\n\n    return 0;\n}\n\n//Main screen\nSDL_Surface *screen;\n\n//Fonts\nbyte fontsize = 0;\nTTF_Font *font[FONT_MAX];\n\n//Strings\nvoid SetFontSize(byte size)\n{\n    fontsize = size;\n    if (font[size] == NULL) {\n\tfont[size] = TTF_OpenFont(\"res/sazanami-gothic.ttf\", size);\n\tif (font[size] == NULL) {\n\t    printf(\"Unable to load font: %s\\n\", TTF_GetError());\n\t    exit(1);\n\t}\n    }\n}\n\nbyte fontType = DX_FONTTYPE_NORMAL;\nvoid ChangeFontType(byte type)\n{\n    fontType = type;\n}\n\nvoid DrawString(int a, int b, const char *x, Uint32 c)\n{\n    SDL_Color color = { c >> 16, c >> 8, c };\n    SDL_Surface *rendered = TTF_RenderUTF8_Solid(font[fontsize], x, color);\n    if (fontType == DX_FONTTYPE_EDGE) {\n\tSDL_Color blk = { 0, 0, 0 };\n\tSDL_Surface *shadow = TTF_RenderUTF8_Solid(font[fontsize], x, blk);\n\tDrawGraphZ(a - 1, b - 1, shadow);\n\tDrawGraphZ(a, b - 1, shadow);\n\tDrawGraphZ(a + 1, b - 1, shadow);\n\tDrawGraphZ(a - 1, b, shadow);\n\tDrawGraphZ(a + 1, b, shadow);\n\tDrawGraphZ(a - 1, b + 1, shadow);\n\tDrawGraphZ(a, b + 1, shadow);\n\tDrawGraphZ(a + 1, b + 1, shadow);\n\tSDL_FreeSurface(shadow);\n    }\n    DrawGraphZ(a, b, rendered);\n    SDL_FreeSurface(rendered);\n}\n\nvoid DrawFormatString(int a, int b, Uint32 color, const char *str, ...)\n{\n    va_list args;\n    char *newstr = new char[strlen(str) + 16];\n    va_start(args, str);\n    vsprintf(newstr, str, args);\n    va_end(args);\n    DrawString(a, b, newstr, color);\n    delete newstr;\n}\n\n//void DrawFormatString(int a, int b, int c\n\n//Key Aliases\n#define KEY_INPUT_ESCAPE SDLK_ESCAPE\n\nbool ex = false;\n\nvoid UpdateKeys()\n{\n    SDL_Event event;\n    while (SDL_PollEvent(&event)) {\n\tswitch (event.type) {\n\tcase SDL_KEYDOWN:\n\t    keysHeld[event.key.keysym.sym] = true;\n\t    break;\n\tcase SDL_KEYUP:\n\t    keysHeld[event.key.keysym.sym] = false;\n\t    break;\n\tcase SDL_JOYAXISMOTION:\n\t    if(event.jaxis.which == 0)\n\t    {\n\t\tif(event.jaxis.axis == JOYSTICK_XAXIS)\n\t\t{\n\t\t    if(event.jaxis.value < 0) keysHeld[SDLK_LEFT] = true;\n\t\t    else if(event.jaxis.value > 0) keysHeld[SDLK_RIGHT] = true;\n\t\t    else {\n\t\t\tkeysHeld[SDLK_LEFT] = false;\n\t\t\tkeysHeld[SDLK_RIGHT] = false;\n\t\t    }\n\t\t}\n\t\telse if(event.jaxis.axis == JOYSTICK_YAXIS)\n\t\t{\n\t\t    if(event.jaxis.value < 0) keysHeld[SDLK_UP] = true;\n\t\t    else if(event.jaxis.value > 0) keysHeld[SDLK_DOWN] = true;\n\t\t    else {\n\t\t\tkeysHeld[SDLK_UP] = false;\n\t\t\tkeysHeld[SDLK_DOWN] = false;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase SDL_QUIT:\n\t    ex = true;\n\t    break;\n\t}\n    }\n}\n\nbyte ProcessMessage()\n{\n    return ex;\n}\n\nbyte CheckHitKey(int key)\n{\n    if(key == SDLK_z && keysHeld[SDLK_SEMICOLON]) return true;\n    return keysHeld[key];\n}\n\nbyte WaitKey()\n{\n    SDL_Event event;\n    while (true) {\n\twhile (SDL_PollEvent(&event))\n\t    if (event.type == SDL_KEYDOWN)\n\t\treturn event.key.keysym.sym;\n    }\n}\n\n/*Uint32 GetColor(byte r, byte g, byte b)\n{\n    return r << 8 * 3 | g << 8 * 2 | b << 8 | 0xFF;\n}*/\n\nvoid DrawGraphZ(int a, int b, SDL_Surface * mx)\n{\n    if(mx)\n    {\n        SDL_Rect offset;\n        offset.x = a;\n        offset.y = b;\n        SDL_BlitSurface(mx, NULL, screen, &offset);\n    }\n}\n\nvoid DrawTurnGraphZ(int a, int b, SDL_Surface * mx)\n{\n    if(mx)\n    {\n        SDL_Rect offset;\n        offset.x = a;\n        offset.y = b;\n\n        SDL_Surface *flipped = zoomSurface(mx, -1, 1, 0);\n        SDL_SetColorKey(flipped, SDL_SRCCOLORKEY,\n                SDL_MapRGB(flipped->format, 9 * 16 + 9, 255, 255));\n        SDL_BlitSurface(flipped, NULL, screen, &offset);\n        SDL_FreeSurface(flipped);\n    }\n}\n\nvoid DrawVertTurnGraph(int a, int b, SDL_Surface * mx)\n{\n    if(mx)\n    {\n        SDL_Rect offset;\n        offset.x = a - mx->w / 2;\n        offset.y = b - mx->h / 2;\n\n        SDL_Surface *flipped = rotozoomSurface(mx, 180, 1, 0);\n        SDL_SetColorKey(flipped, SDL_SRCCOLORKEY,\n                SDL_MapRGB(flipped->format, 9 * 16 + 9, 255, 255));\n        SDL_BlitSurface(flipped, NULL, screen, &offset);\n        SDL_FreeSurface(flipped);\n    }\n}\n\nSDL_Surface *DerivationGraph(int srcx, int srcy, int width, int height,\n\t\t\t     SDL_Surface * src)\n{\n    SDL_Surface *img =\n\tSDL_CreateRGBSurface(SDL_SWSURFACE, width, height,\n\t\t\t     screen->format->BitsPerPixel,\n\t\t\t     src->format->Rmask, src->format->Bmask,\n\t\t\t     src->format->Gmask, src->format->Amask);\n\n    SDL_Rect offset;\n    offset.x = srcx;\n    offset.y = srcy;\n    offset.w = width;\n    offset.h = height;\n\n    SDL_BlitSurface(src, &offset, img, NULL);\n    SDL_SetColorKey(img, SDL_SRCCOLORKEY,\n\t\t    SDL_MapRGB(img->format, 9 * 16 + 9, 255, 255));\n    return img;\n}\n\n//Noticably different than the original\nSDL_Surface *LoadGraph(const char *filename)\n{\n    SDL_Surface *image = IMG_Load(filename);\n\n    if (image) return image;\n\tfprintf(stderr, \"Error: Unable to load %s: %s\\n\", filename, IMG_GetError());\n\texit(1);\n}\n\nvoid PlaySoundMem(Mix_Chunk* s, int l)\n{\n    if(sound) Mix_PlayChannel(-1, s, l);\n}\n\nMix_Chunk* LoadSoundMem(const char* f)\n{\n    if(!sound) return NULL;\r\n\r\n    Mix_Chunk* s = Mix_LoadWAV(f);\r\n    if(s) return s;\r\n    fprintf(stderr, \"Error: Unable to load sound %s: %s\\n\", f, Mix_GetError());\r\n    return NULL;\n}\n\nMix_Music* LoadMusicMem(const char* f)\n{\n    if(!sound) return NULL;\r\n\r\n    Mix_Music* m = Mix_LoadMUS(f);\r\n    if(m) return m;\r\n    fprintf(stderr, \"Error: Unable to load music %s: %s\\n\", f, Mix_GetError());\n    return NULL;\n}\n\n"]}